// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This file is auto-generated by Reflang. !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#include "return-noargs.gen.hpp"

#include <algorithm>
#include <cassert>
#include <stdexcept>
#include <type_traits>

namespace reflang
{


int Function<const char *(*)(), ns::NamespacedFunction>::GetParameterCount() const
{
	return 0;
}

Parameter Function<const char *(*)(), ns::NamespacedFunction>::GetReturnType() const
{
	Parameter result;
	result.Type = "const char *";
	return result;
}

Parameter Function<const char *(*)(), ns::NamespacedFunction>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string ns__NamespacedFunction_name = "ns::NamespacedFunction";

const std::string& Function<const char *(*)(), ns::NamespacedFunction>::GetName() const
{
	return ns__NamespacedFunction_name;
}

Object Function<const char *(*)(), ns::NamespacedFunction>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(ns::NamespacedFunction());
}

namespace
{
	// Object to auto-register ns::NamespacedFunction.
	struct ns__NamespacedFunction_registrar
	{
		ns__NamespacedFunction_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<const char *(*)(), ns::NamespacedFunction>>());
		}
	} ns__NamespacedFunction_instance;
}



int Function<const char *(*)(), GlobalFunction>::GetParameterCount() const
{
	return 0;
}

Parameter Function<const char *(*)(), GlobalFunction>::GetReturnType() const
{
	Parameter result;
	result.Type = "const char *";
	return result;
}

Parameter Function<const char *(*)(), GlobalFunction>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string GlobalFunction_name = "GlobalFunction";

const std::string& Function<const char *(*)(), GlobalFunction>::GetName() const
{
	return GlobalFunction_name;
}

Object Function<const char *(*)(), GlobalFunction>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(GlobalFunction());
}

namespace
{
	// Object to auto-register GlobalFunction.
	struct GlobalFunction_registrar
	{
		GlobalFunction_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<const char *(*)(), GlobalFunction>>());
		}
	} GlobalFunction_instance;
}



int Function<DummyClass(*)(), ReturnByValue>::GetParameterCount() const
{
	return 0;
}

Parameter Function<DummyClass(*)(), ReturnByValue>::GetReturnType() const
{
	Parameter result;
	result.Type = "DummyClass";
	return result;
}

Parameter Function<DummyClass(*)(), ReturnByValue>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string ReturnByValue_name = "ReturnByValue";

const std::string& Function<DummyClass(*)(), ReturnByValue>::GetName() const
{
	return ReturnByValue_name;
}

Object Function<DummyClass(*)(), ReturnByValue>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(ReturnByValue());
}

namespace
{
	// Object to auto-register ReturnByValue.
	struct ReturnByValue_registrar
	{
		ReturnByValue_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<DummyClass(*)(), ReturnByValue>>());
		}
	} ReturnByValue_instance;
}



int Function<const DummyClass &(*)(), ReturnByReference>::GetParameterCount() const
{
	return 0;
}

Parameter Function<const DummyClass &(*)(), ReturnByReference>::GetReturnType() const
{
	Parameter result;
	result.Type = "const DummyClass &";
	return result;
}

Parameter Function<const DummyClass &(*)(), ReturnByReference>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string ReturnByReference_name = "ReturnByReference";

const std::string& Function<const DummyClass &(*)(), ReturnByReference>::GetName() const
{
	return ReturnByReference_name;
}

Object Function<const DummyClass &(*)(), ReturnByReference>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(ReturnByReference());
}

namespace
{
	// Object to auto-register ReturnByReference.
	struct ReturnByReference_registrar
	{
		ReturnByReference_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<const DummyClass &(*)(), ReturnByReference>>());
		}
	} ReturnByReference_instance;
}


}  // namespace reflang
