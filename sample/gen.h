// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This file is auto-generated by Reflang. !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#ifndef REFLANG_METADATA_SAMPLE_GEN_H
#define REFLANG_METADATA_SAMPLE_GEN_H

#include <string>

-I/Library//Developer/CommandLineTools/usr/include/c++/v1
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h"
#include "/Library//Developer/CommandLineTools/usr/include/c++/v1/new"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/alloca.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/strings.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h"
#include "/Library//Developer/CommandLineTools/usr/include/c++/v1/__debug"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h"
#include "/Library//Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h"
#include "sample/header.hpp"

namespace reflang
{


template <>
class Class<TheStruct> : public IClass
{
public:
	static const constexpr int FieldCount = 0;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'TheStruct'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const TheStruct& c, T t);

	template <typename T>
	static void IterateFields(TheStruct& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<TheStruct>::IterateFields(const TheStruct& c, T t)
{
}

template <typename T>
void Class<TheStruct>::IterateFields(TheStruct& c, T t)
{
}

template <typename T>
void Class<TheStruct>::IterateStaticFields(T t)
{
}





template <>
class Class<TheClass> : public IClass
{
public:
	static const constexpr int FieldCount = 0;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'TheClass'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const TheClass& c, T t);

	template <typename T>
	static void IterateFields(TheClass& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<TheClass>::IterateFields(const TheClass& c, T t)
{
}

template <typename T>
void Class<TheClass>::IterateFields(TheClass& c, T t)
{
}

template <typename T>
void Class<TheClass>::IterateStaticFields(T t)
{
}





template <>
class Class<MyClass> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 2;
	static const constexpr int StaticMethodCount = 1;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'MyClass'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const MyClass& c, T t);

	template <typename T>
	static void IterateFields(MyClass& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<MyClass>::IterateFields(const MyClass& c, T t)
{
	t(c.x);
}

template <typename T>
void Class<MyClass>::IterateFields(MyClass& c, T t)
{
	t(c.x);
}

template <typename T>
void Class<MyClass>::IterateStaticFields(T t)
{
}

// MyClass methods metadata.
template <>
class Method<decltype(&MyClass::foo), &MyClass::foo> : public IMethod
{
public:
	const std::string& GetName() const override;
	int GetParameterCount() const override;
	Object Invoke(const Reference& o, const std::vector<Object>& args) override;
};

template <>
class Method<decltype(&MyClass::v_foo), &MyClass::v_foo> : public IMethod
{
public:
	const std::string& GetName() const override;
	int GetParameterCount() const override;
	Object Invoke(const Reference& o, const std::vector<Object>& args) override;
};

// End of MyClass methods metadata.
// MyClass static methods metadata.

template <>
class Function<void(*)(MyClass *), MyClass::s_foo> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};
// End of MyClass static methods metadata.




template <>
class Class<__darwin_pthread_handler_rec> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_pthread_handler_rec'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_pthread_handler_rec& c, T t);

	template <typename T>
	static void IterateFields(__darwin_pthread_handler_rec& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_pthread_handler_rec>::IterateFields(const __darwin_pthread_handler_rec& c, T t)
{
	t(c.__routine);
	t(c.__arg);
	t(c.__next);
}

template <typename T>
void Class<__darwin_pthread_handler_rec>::IterateFields(__darwin_pthread_handler_rec& c, T t)
{
	t(c.__routine);
	t(c.__arg);
	t(c.__next);
}

template <typename T>
void Class<__darwin_pthread_handler_rec>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_attr_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_attr_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_attr_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_attr_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_attr_t>::IterateFields(const _opaque_pthread_attr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_attr_t>::IterateFields(_opaque_pthread_attr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_attr_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_cond_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_cond_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_cond_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_cond_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_cond_t>::IterateFields(const _opaque_pthread_cond_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_cond_t>::IterateFields(_opaque_pthread_cond_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_cond_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_condattr_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_condattr_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_condattr_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_condattr_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_condattr_t>::IterateFields(const _opaque_pthread_condattr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_condattr_t>::IterateFields(_opaque_pthread_condattr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_condattr_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_mutex_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_mutex_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_mutex_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_mutex_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_mutex_t>::IterateFields(const _opaque_pthread_mutex_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_mutex_t>::IterateFields(_opaque_pthread_mutex_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_mutex_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_mutexattr_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_mutexattr_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_mutexattr_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_mutexattr_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_mutexattr_t>::IterateFields(const _opaque_pthread_mutexattr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_mutexattr_t>::IterateFields(_opaque_pthread_mutexattr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_mutexattr_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_once_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_once_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_once_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_once_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_once_t>::IterateFields(const _opaque_pthread_once_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_once_t>::IterateFields(_opaque_pthread_once_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_once_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_rwlock_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_rwlock_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_rwlock_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_rwlock_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_rwlock_t>::IterateFields(const _opaque_pthread_rwlock_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_rwlock_t>::IterateFields(_opaque_pthread_rwlock_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_rwlock_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_rwlockattr_t> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_rwlockattr_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_rwlockattr_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_rwlockattr_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_rwlockattr_t>::IterateFields(const _opaque_pthread_rwlockattr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_rwlockattr_t>::IterateFields(_opaque_pthread_rwlockattr_t& c, T t)
{
	t(c.__sig);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_rwlockattr_t>::IterateStaticFields(T t)
{
}





template <>
class Class<_opaque_pthread_t> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '_opaque_pthread_t'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const _opaque_pthread_t& c, T t);

	template <typename T>
	static void IterateFields(_opaque_pthread_t& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<_opaque_pthread_t>::IterateFields(const _opaque_pthread_t& c, T t)
{
	t(c.__sig);
	t(c.__cleanup_stack);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_t>::IterateFields(_opaque_pthread_t& c, T t)
{
	t(c.__sig);
	t(c.__cleanup_stack);
	t(c.__opaque);
}

template <typename T>
void Class<_opaque_pthread_t>::IterateStaticFields(T t)
{
}





template <>
class Function<void *(*)(const void *, int, size_t), ::memchr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const void *, const void *, size_t), ::memcmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(void *, const void *, size_t), ::memcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(void *, const void *, size_t), ::memmove> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(void *, int, size_t), ::memset> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *), ::strcat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, int), ::strchr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *), ::strcmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *), ::strcoll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *), ::strcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const char *, const char *), ::strcspn> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(int), ::strerror> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const char *), ::strlen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *, size_t), ::strncat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *, size_t), ::strncmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *, size_t), ::strncpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, const char *), ::strpbrk> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, int), ::strrchr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const char *, const char *), ::strspn> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, const char *), ::strstr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *), ::strtok> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, const char *, size_t), ::strxfrm> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *, char **), ::strtok_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, char *, size_t), ::strerror_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *), ::strdup> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(void *, const void *, int, size_t), ::memccpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *), ::stpcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *, size_t), ::stpncpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, size_t), ::strndup> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const char *, size_t), ::strnlen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(int), ::strsignal> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, const void *, size_t), ::memset_pattern4> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, const void *, size_t), ::memset_pattern8> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, const void *, size_t), ::memset_pattern16> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, const char *), ::strcasestr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, const char *, size_t), ::strnstr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, const char *, size_t), ::strlcat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, const char *, size_t), ::strlcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(int, char *), ::strmode> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char **, const char *), ::strsep> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(const void *, void *, ssize_t), ::swab> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const void *, const void *, size_t), ::bcmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(const void *, void *, size_t), ::bcopy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t), ::bzero> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, int), ::index> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, int), ::rindex> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::ffs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *), ::strcasecmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *, size_t), ::strncasecmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(long), ::ffsl> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(long long), ::ffsll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::fls> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(long), ::flsl> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(long long), ::flsll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Class<__libcpp_debug_exception> : public IClass
{
public:
	static const constexpr int FieldCount = 0;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__libcpp_debug_exception'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __libcpp_debug_exception& c, T t);

	template <typename T>
	static void IterateFields(__libcpp_debug_exception& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__libcpp_debug_exception>::IterateFields(const __libcpp_debug_exception& c, T t)
{
}

template <typename T>
void Class<__libcpp_debug_exception>::IterateFields(__libcpp_debug_exception& c, T t)
{
}

template <typename T>
void Class<__libcpp_debug_exception>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_i386_thread_state> : public IClass
{
public:
	static const constexpr int FieldCount = 16;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_i386_thread_state'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_i386_thread_state& c, T t);

	template <typename T>
	static void IterateFields(__darwin_i386_thread_state& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_i386_thread_state>::IterateFields(const __darwin_i386_thread_state& c, T t)
{
	t(c.__eax);
	t(c.__ebx);
	t(c.__ecx);
	t(c.__edx);
	t(c.__edi);
	t(c.__esi);
	t(c.__ebp);
	t(c.__esp);
	t(c.__ss);
	t(c.__eflags);
	t(c.__eip);
	t(c.__cs);
	t(c.__ds);
	t(c.__es);
	t(c.__fs);
	t(c.__gs);
}

template <typename T>
void Class<__darwin_i386_thread_state>::IterateFields(__darwin_i386_thread_state& c, T t)
{
	t(c.__eax);
	t(c.__ebx);
	t(c.__ecx);
	t(c.__edx);
	t(c.__edi);
	t(c.__esi);
	t(c.__ebp);
	t(c.__esp);
	t(c.__ss);
	t(c.__eflags);
	t(c.__eip);
	t(c.__cs);
	t(c.__ds);
	t(c.__es);
	t(c.__fs);
	t(c.__gs);
}

template <typename T>
void Class<__darwin_i386_thread_state>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_fp_control> : public IClass
{
public:
	static const constexpr int FieldCount = 11;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_fp_control'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_fp_control& c, T t);

	template <typename T>
	static void IterateFields(__darwin_fp_control& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_fp_control>::IterateFields(const __darwin_fp_control& c, T t)
{
	t(c.__invalid);
	t(c.__denorm);
	t(c.__zdiv);
	t(c.__ovrfl);
	t(c.__undfl);
	t(c.__precis);
	t(c.);
	t(c.__pc);
	t(c.__rc);
	t(c.);
	t(c.);
}

template <typename T>
void Class<__darwin_fp_control>::IterateFields(__darwin_fp_control& c, T t)
{
	t(c.__invalid);
	t(c.__denorm);
	t(c.__zdiv);
	t(c.__ovrfl);
	t(c.__undfl);
	t(c.__precis);
	t(c.);
	t(c.__pc);
	t(c.__rc);
	t(c.);
	t(c.);
}

template <typename T>
void Class<__darwin_fp_control>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_fp_status> : public IClass
{
public:
	static const constexpr int FieldCount = 14;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_fp_status'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_fp_status& c, T t);

	template <typename T>
	static void IterateFields(__darwin_fp_status& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_fp_status>::IterateFields(const __darwin_fp_status& c, T t)
{
	t(c.__invalid);
	t(c.__denorm);
	t(c.__zdiv);
	t(c.__ovrfl);
	t(c.__undfl);
	t(c.__precis);
	t(c.__stkflt);
	t(c.__errsumm);
	t(c.__c0);
	t(c.__c1);
	t(c.__c2);
	t(c.__tos);
	t(c.__c3);
	t(c.__busy);
}

template <typename T>
void Class<__darwin_fp_status>::IterateFields(__darwin_fp_status& c, T t)
{
	t(c.__invalid);
	t(c.__denorm);
	t(c.__zdiv);
	t(c.__ovrfl);
	t(c.__undfl);
	t(c.__precis);
	t(c.__stkflt);
	t(c.__errsumm);
	t(c.__c0);
	t(c.__c1);
	t(c.__c2);
	t(c.__tos);
	t(c.__c3);
	t(c.__busy);
}

template <typename T>
void Class<__darwin_fp_status>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mmst_reg> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mmst_reg'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mmst_reg& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mmst_reg& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mmst_reg>::IterateFields(const __darwin_mmst_reg& c, T t)
{
	t(c.__mmst_reg);
	t(c.__mmst_rsrv);
}

template <typename T>
void Class<__darwin_mmst_reg>::IterateFields(__darwin_mmst_reg& c, T t)
{
	t(c.__mmst_reg);
	t(c.__mmst_rsrv);
}

template <typename T>
void Class<__darwin_mmst_reg>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_xmm_reg> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_xmm_reg'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_xmm_reg& c, T t);

	template <typename T>
	static void IterateFields(__darwin_xmm_reg& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_xmm_reg>::IterateFields(const __darwin_xmm_reg& c, T t)
{
	t(c.__xmm_reg);
}

template <typename T>
void Class<__darwin_xmm_reg>::IterateFields(__darwin_xmm_reg& c, T t)
{
	t(c.__xmm_reg);
}

template <typename T>
void Class<__darwin_xmm_reg>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_ymm_reg> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_ymm_reg'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_ymm_reg& c, T t);

	template <typename T>
	static void IterateFields(__darwin_ymm_reg& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_ymm_reg>::IterateFields(const __darwin_ymm_reg& c, T t)
{
	t(c.__ymm_reg);
}

template <typename T>
void Class<__darwin_ymm_reg>::IterateFields(__darwin_ymm_reg& c, T t)
{
	t(c.__ymm_reg);
}

template <typename T>
void Class<__darwin_ymm_reg>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_zmm_reg> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_zmm_reg'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_zmm_reg& c, T t);

	template <typename T>
	static void IterateFields(__darwin_zmm_reg& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_zmm_reg>::IterateFields(const __darwin_zmm_reg& c, T t)
{
	t(c.__zmm_reg);
}

template <typename T>
void Class<__darwin_zmm_reg>::IterateFields(__darwin_zmm_reg& c, T t)
{
	t(c.__zmm_reg);
}

template <typename T>
void Class<__darwin_zmm_reg>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_opmask_reg> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_opmask_reg'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_opmask_reg& c, T t);

	template <typename T>
	static void IterateFields(__darwin_opmask_reg& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_opmask_reg>::IterateFields(const __darwin_opmask_reg& c, T t)
{
	t(c.__opmask_reg);
}

template <typename T>
void Class<__darwin_opmask_reg>::IterateFields(__darwin_opmask_reg& c, T t)
{
	t(c.__opmask_reg);
}

template <typename T>
void Class<__darwin_opmask_reg>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_i386_float_state> : public IClass
{
public:
	static const constexpr int FieldCount = 32;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_i386_float_state'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_i386_float_state& c, T t);

	template <typename T>
	static void IterateFields(__darwin_i386_float_state& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_i386_float_state>::IterateFields(const __darwin_i386_float_state& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
}

template <typename T>
void Class<__darwin_i386_float_state>::IterateFields(__darwin_i386_float_state& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
}

template <typename T>
void Class<__darwin_i386_float_state>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_i386_avx_state> : public IClass
{
public:
	static const constexpr int FieldCount = 41;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_i386_avx_state'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_i386_avx_state& c, T t);

	template <typename T>
	static void IterateFields(__darwin_i386_avx_state& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_i386_avx_state>::IterateFields(const __darwin_i386_avx_state& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
}

template <typename T>
void Class<__darwin_i386_avx_state>::IterateFields(__darwin_i386_avx_state& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
}

template <typename T>
void Class<__darwin_i386_avx_state>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_i386_avx512_state> : public IClass
{
public:
	static const constexpr int FieldCount = 57;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_i386_avx512_state'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_i386_avx512_state& c, T t);

	template <typename T>
	static void IterateFields(__darwin_i386_avx512_state& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_i386_avx512_state>::IterateFields(const __darwin_i386_avx512_state& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
	t(c.__fpu_k0);
	t(c.__fpu_k1);
	t(c.__fpu_k2);
	t(c.__fpu_k3);
	t(c.__fpu_k4);
	t(c.__fpu_k5);
	t(c.__fpu_k6);
	t(c.__fpu_k7);
	t(c.__fpu_zmmh0);
	t(c.__fpu_zmmh1);
	t(c.__fpu_zmmh2);
	t(c.__fpu_zmmh3);
	t(c.__fpu_zmmh4);
	t(c.__fpu_zmmh5);
	t(c.__fpu_zmmh6);
	t(c.__fpu_zmmh7);
}

template <typename T>
void Class<__darwin_i386_avx512_state>::IterateFields(__darwin_i386_avx512_state& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
	t(c.__fpu_k0);
	t(c.__fpu_k1);
	t(c.__fpu_k2);
	t(c.__fpu_k3);
	t(c.__fpu_k4);
	t(c.__fpu_k5);
	t(c.__fpu_k6);
	t(c.__fpu_k7);
	t(c.__fpu_zmmh0);
	t(c.__fpu_zmmh1);
	t(c.__fpu_zmmh2);
	t(c.__fpu_zmmh3);
	t(c.__fpu_zmmh4);
	t(c.__fpu_zmmh5);
	t(c.__fpu_zmmh6);
	t(c.__fpu_zmmh7);
}

template <typename T>
void Class<__darwin_i386_avx512_state>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_i386_exception_state> : public IClass
{
public:
	static const constexpr int FieldCount = 4;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_i386_exception_state'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_i386_exception_state& c, T t);

	template <typename T>
	static void IterateFields(__darwin_i386_exception_state& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_i386_exception_state>::IterateFields(const __darwin_i386_exception_state& c, T t)
{
	t(c.__trapno);
	t(c.__cpu);
	t(c.__err);
	t(c.__faultvaddr);
}

template <typename T>
void Class<__darwin_i386_exception_state>::IterateFields(__darwin_i386_exception_state& c, T t)
{
	t(c.__trapno);
	t(c.__cpu);
	t(c.__err);
	t(c.__faultvaddr);
}

template <typename T>
void Class<__darwin_i386_exception_state>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_debug_state32> : public IClass
{
public:
	static const constexpr int FieldCount = 8;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_debug_state32'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_debug_state32& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_debug_state32& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_debug_state32>::IterateFields(const __darwin_x86_debug_state32& c, T t)
{
	t(c.__dr0);
	t(c.__dr1);
	t(c.__dr2);
	t(c.__dr3);
	t(c.__dr4);
	t(c.__dr5);
	t(c.__dr6);
	t(c.__dr7);
}

template <typename T>
void Class<__darwin_x86_debug_state32>::IterateFields(__darwin_x86_debug_state32& c, T t)
{
	t(c.__dr0);
	t(c.__dr1);
	t(c.__dr2);
	t(c.__dr3);
	t(c.__dr4);
	t(c.__dr5);
	t(c.__dr6);
	t(c.__dr7);
}

template <typename T>
void Class<__darwin_x86_debug_state32>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_thread_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 21;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_thread_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_thread_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_thread_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_thread_state64>::IterateFields(const __darwin_x86_thread_state64& c, T t)
{
	t(c.__rax);
	t(c.__rbx);
	t(c.__rcx);
	t(c.__rdx);
	t(c.__rdi);
	t(c.__rsi);
	t(c.__rbp);
	t(c.__rsp);
	t(c.__r8);
	t(c.__r9);
	t(c.__r10);
	t(c.__r11);
	t(c.__r12);
	t(c.__r13);
	t(c.__r14);
	t(c.__r15);
	t(c.__rip);
	t(c.__rflags);
	t(c.__cs);
	t(c.__fs);
	t(c.__gs);
}

template <typename T>
void Class<__darwin_x86_thread_state64>::IterateFields(__darwin_x86_thread_state64& c, T t)
{
	t(c.__rax);
	t(c.__rbx);
	t(c.__rcx);
	t(c.__rdx);
	t(c.__rdi);
	t(c.__rsi);
	t(c.__rbp);
	t(c.__rsp);
	t(c.__r8);
	t(c.__r9);
	t(c.__r10);
	t(c.__r11);
	t(c.__r12);
	t(c.__r13);
	t(c.__r14);
	t(c.__r15);
	t(c.__rip);
	t(c.__rflags);
	t(c.__cs);
	t(c.__fs);
	t(c.__gs);
}

template <typename T>
void Class<__darwin_x86_thread_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_thread_full_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 4;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_thread_full_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_thread_full_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_thread_full_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_thread_full_state64>::IterateFields(const __darwin_x86_thread_full_state64& c, T t)
{
	t(c.ss64);
	t(c.__ds);
	t(c.__es);
	t(c.__ss);
}

template <typename T>
void Class<__darwin_x86_thread_full_state64>::IterateFields(__darwin_x86_thread_full_state64& c, T t)
{
	t(c.ss64);
	t(c.__ds);
	t(c.__es);
	t(c.__ss);
}

template <typename T>
void Class<__darwin_x86_thread_full_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_float_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 40;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_float_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_float_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_float_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_float_state64>::IterateFields(const __darwin_x86_float_state64& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_xmm8);
	t(c.__fpu_xmm9);
	t(c.__fpu_xmm10);
	t(c.__fpu_xmm11);
	t(c.__fpu_xmm12);
	t(c.__fpu_xmm13);
	t(c.__fpu_xmm14);
	t(c.__fpu_xmm15);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
}

template <typename T>
void Class<__darwin_x86_float_state64>::IterateFields(__darwin_x86_float_state64& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_xmm8);
	t(c.__fpu_xmm9);
	t(c.__fpu_xmm10);
	t(c.__fpu_xmm11);
	t(c.__fpu_xmm12);
	t(c.__fpu_xmm13);
	t(c.__fpu_xmm14);
	t(c.__fpu_xmm15);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
}

template <typename T>
void Class<__darwin_x86_float_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_avx_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 57;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_avx_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_avx_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_avx_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_avx_state64>::IterateFields(const __darwin_x86_avx_state64& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_xmm8);
	t(c.__fpu_xmm9);
	t(c.__fpu_xmm10);
	t(c.__fpu_xmm11);
	t(c.__fpu_xmm12);
	t(c.__fpu_xmm13);
	t(c.__fpu_xmm14);
	t(c.__fpu_xmm15);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
	t(c.__fpu_ymmh8);
	t(c.__fpu_ymmh9);
	t(c.__fpu_ymmh10);
	t(c.__fpu_ymmh11);
	t(c.__fpu_ymmh12);
	t(c.__fpu_ymmh13);
	t(c.__fpu_ymmh14);
	t(c.__fpu_ymmh15);
}

template <typename T>
void Class<__darwin_x86_avx_state64>::IterateFields(__darwin_x86_avx_state64& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_xmm8);
	t(c.__fpu_xmm9);
	t(c.__fpu_xmm10);
	t(c.__fpu_xmm11);
	t(c.__fpu_xmm12);
	t(c.__fpu_xmm13);
	t(c.__fpu_xmm14);
	t(c.__fpu_xmm15);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
	t(c.__fpu_ymmh8);
	t(c.__fpu_ymmh9);
	t(c.__fpu_ymmh10);
	t(c.__fpu_ymmh11);
	t(c.__fpu_ymmh12);
	t(c.__fpu_ymmh13);
	t(c.__fpu_ymmh14);
	t(c.__fpu_ymmh15);
}

template <typename T>
void Class<__darwin_x86_avx_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_avx512_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 97;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_avx512_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_avx512_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_avx512_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_avx512_state64>::IterateFields(const __darwin_x86_avx512_state64& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_xmm8);
	t(c.__fpu_xmm9);
	t(c.__fpu_xmm10);
	t(c.__fpu_xmm11);
	t(c.__fpu_xmm12);
	t(c.__fpu_xmm13);
	t(c.__fpu_xmm14);
	t(c.__fpu_xmm15);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
	t(c.__fpu_ymmh8);
	t(c.__fpu_ymmh9);
	t(c.__fpu_ymmh10);
	t(c.__fpu_ymmh11);
	t(c.__fpu_ymmh12);
	t(c.__fpu_ymmh13);
	t(c.__fpu_ymmh14);
	t(c.__fpu_ymmh15);
	t(c.__fpu_k0);
	t(c.__fpu_k1);
	t(c.__fpu_k2);
	t(c.__fpu_k3);
	t(c.__fpu_k4);
	t(c.__fpu_k5);
	t(c.__fpu_k6);
	t(c.__fpu_k7);
	t(c.__fpu_zmmh0);
	t(c.__fpu_zmmh1);
	t(c.__fpu_zmmh2);
	t(c.__fpu_zmmh3);
	t(c.__fpu_zmmh4);
	t(c.__fpu_zmmh5);
	t(c.__fpu_zmmh6);
	t(c.__fpu_zmmh7);
	t(c.__fpu_zmmh8);
	t(c.__fpu_zmmh9);
	t(c.__fpu_zmmh10);
	t(c.__fpu_zmmh11);
	t(c.__fpu_zmmh12);
	t(c.__fpu_zmmh13);
	t(c.__fpu_zmmh14);
	t(c.__fpu_zmmh15);
	t(c.__fpu_zmm16);
	t(c.__fpu_zmm17);
	t(c.__fpu_zmm18);
	t(c.__fpu_zmm19);
	t(c.__fpu_zmm20);
	t(c.__fpu_zmm21);
	t(c.__fpu_zmm22);
	t(c.__fpu_zmm23);
	t(c.__fpu_zmm24);
	t(c.__fpu_zmm25);
	t(c.__fpu_zmm26);
	t(c.__fpu_zmm27);
	t(c.__fpu_zmm28);
	t(c.__fpu_zmm29);
	t(c.__fpu_zmm30);
	t(c.__fpu_zmm31);
}

template <typename T>
void Class<__darwin_x86_avx512_state64>::IterateFields(__darwin_x86_avx512_state64& c, T t)
{
	t(c.__fpu_reserved);
	t(c.__fpu_fcw);
	t(c.__fpu_fsw);
	t(c.__fpu_ftw);
	t(c.__fpu_rsrv1);
	t(c.__fpu_fop);
	t(c.__fpu_ip);
	t(c.__fpu_cs);
	t(c.__fpu_rsrv2);
	t(c.__fpu_dp);
	t(c.__fpu_ds);
	t(c.__fpu_rsrv3);
	t(c.__fpu_mxcsr);
	t(c.__fpu_mxcsrmask);
	t(c.__fpu_stmm0);
	t(c.__fpu_stmm1);
	t(c.__fpu_stmm2);
	t(c.__fpu_stmm3);
	t(c.__fpu_stmm4);
	t(c.__fpu_stmm5);
	t(c.__fpu_stmm6);
	t(c.__fpu_stmm7);
	t(c.__fpu_xmm0);
	t(c.__fpu_xmm1);
	t(c.__fpu_xmm2);
	t(c.__fpu_xmm3);
	t(c.__fpu_xmm4);
	t(c.__fpu_xmm5);
	t(c.__fpu_xmm6);
	t(c.__fpu_xmm7);
	t(c.__fpu_xmm8);
	t(c.__fpu_xmm9);
	t(c.__fpu_xmm10);
	t(c.__fpu_xmm11);
	t(c.__fpu_xmm12);
	t(c.__fpu_xmm13);
	t(c.__fpu_xmm14);
	t(c.__fpu_xmm15);
	t(c.__fpu_rsrv4);
	t(c.__fpu_reserved1);
	t(c.__avx_reserved1);
	t(c.__fpu_ymmh0);
	t(c.__fpu_ymmh1);
	t(c.__fpu_ymmh2);
	t(c.__fpu_ymmh3);
	t(c.__fpu_ymmh4);
	t(c.__fpu_ymmh5);
	t(c.__fpu_ymmh6);
	t(c.__fpu_ymmh7);
	t(c.__fpu_ymmh8);
	t(c.__fpu_ymmh9);
	t(c.__fpu_ymmh10);
	t(c.__fpu_ymmh11);
	t(c.__fpu_ymmh12);
	t(c.__fpu_ymmh13);
	t(c.__fpu_ymmh14);
	t(c.__fpu_ymmh15);
	t(c.__fpu_k0);
	t(c.__fpu_k1);
	t(c.__fpu_k2);
	t(c.__fpu_k3);
	t(c.__fpu_k4);
	t(c.__fpu_k5);
	t(c.__fpu_k6);
	t(c.__fpu_k7);
	t(c.__fpu_zmmh0);
	t(c.__fpu_zmmh1);
	t(c.__fpu_zmmh2);
	t(c.__fpu_zmmh3);
	t(c.__fpu_zmmh4);
	t(c.__fpu_zmmh5);
	t(c.__fpu_zmmh6);
	t(c.__fpu_zmmh7);
	t(c.__fpu_zmmh8);
	t(c.__fpu_zmmh9);
	t(c.__fpu_zmmh10);
	t(c.__fpu_zmmh11);
	t(c.__fpu_zmmh12);
	t(c.__fpu_zmmh13);
	t(c.__fpu_zmmh14);
	t(c.__fpu_zmmh15);
	t(c.__fpu_zmm16);
	t(c.__fpu_zmm17);
	t(c.__fpu_zmm18);
	t(c.__fpu_zmm19);
	t(c.__fpu_zmm20);
	t(c.__fpu_zmm21);
	t(c.__fpu_zmm22);
	t(c.__fpu_zmm23);
	t(c.__fpu_zmm24);
	t(c.__fpu_zmm25);
	t(c.__fpu_zmm26);
	t(c.__fpu_zmm27);
	t(c.__fpu_zmm28);
	t(c.__fpu_zmm29);
	t(c.__fpu_zmm30);
	t(c.__fpu_zmm31);
}

template <typename T>
void Class<__darwin_x86_avx512_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_exception_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 4;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_exception_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_exception_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_exception_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_exception_state64>::IterateFields(const __darwin_x86_exception_state64& c, T t)
{
	t(c.__trapno);
	t(c.__cpu);
	t(c.__err);
	t(c.__faultvaddr);
}

template <typename T>
void Class<__darwin_x86_exception_state64>::IterateFields(__darwin_x86_exception_state64& c, T t)
{
	t(c.__trapno);
	t(c.__cpu);
	t(c.__err);
	t(c.__faultvaddr);
}

template <typename T>
void Class<__darwin_x86_exception_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_debug_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 8;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_debug_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_debug_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_debug_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_debug_state64>::IterateFields(const __darwin_x86_debug_state64& c, T t)
{
	t(c.__dr0);
	t(c.__dr1);
	t(c.__dr2);
	t(c.__dr3);
	t(c.__dr4);
	t(c.__dr5);
	t(c.__dr6);
	t(c.__dr7);
}

template <typename T>
void Class<__darwin_x86_debug_state64>::IterateFields(__darwin_x86_debug_state64& c, T t)
{
	t(c.__dr0);
	t(c.__dr1);
	t(c.__dr2);
	t(c.__dr3);
	t(c.__dr4);
	t(c.__dr5);
	t(c.__dr6);
	t(c.__dr7);
}

template <typename T>
void Class<__darwin_x86_debug_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_x86_cpmu_state64> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_x86_cpmu_state64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_x86_cpmu_state64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_x86_cpmu_state64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_x86_cpmu_state64>::IterateFields(const __darwin_x86_cpmu_state64& c, T t)
{
	t(c.__ctrs);
}

template <typename T>
void Class<__darwin_x86_cpmu_state64>::IterateFields(__darwin_x86_cpmu_state64& c, T t)
{
	t(c.__ctrs);
}

template <typename T>
void Class<__darwin_x86_cpmu_state64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mcontext32> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mcontext32'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mcontext32& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mcontext32& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mcontext32>::IterateFields(const __darwin_mcontext32& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext32>::IterateFields(__darwin_mcontext32& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext32>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mcontext_avx32> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mcontext_avx32'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mcontext_avx32& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mcontext_avx32& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mcontext_avx32>::IterateFields(const __darwin_mcontext_avx32& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx32>::IterateFields(__darwin_mcontext_avx32& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx32>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mcontext_avx512_32> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mcontext_avx512_32'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mcontext_avx512_32& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mcontext_avx512_32& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mcontext_avx512_32>::IterateFields(const __darwin_mcontext_avx512_32& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx512_32>::IterateFields(__darwin_mcontext_avx512_32& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx512_32>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mcontext64> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mcontext64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mcontext64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mcontext64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mcontext64>::IterateFields(const __darwin_mcontext64& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext64>::IterateFields(__darwin_mcontext64& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mcontext_avx64> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mcontext_avx64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mcontext_avx64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mcontext_avx64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mcontext_avx64>::IterateFields(const __darwin_mcontext_avx64& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx64>::IterateFields(__darwin_mcontext_avx64& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_mcontext_avx512_64> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_mcontext_avx512_64'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_mcontext_avx512_64& c, T t);

	template <typename T>
	static void IterateFields(__darwin_mcontext_avx512_64& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_mcontext_avx512_64>::IterateFields(const __darwin_mcontext_avx512_64& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx512_64>::IterateFields(__darwin_mcontext_avx512_64& c, T t)
{
	t(c.__es);
	t(c.__ss);
	t(c.__fs);
}

template <typename T>
void Class<__darwin_mcontext_avx512_64>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_sigaltstack> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_sigaltstack'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_sigaltstack& c, T t);

	template <typename T>
	static void IterateFields(__darwin_sigaltstack& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_sigaltstack>::IterateFields(const __darwin_sigaltstack& c, T t)
{
	t(c.ss_sp);
	t(c.ss_size);
	t(c.ss_flags);
}

template <typename T>
void Class<__darwin_sigaltstack>::IterateFields(__darwin_sigaltstack& c, T t)
{
	t(c.ss_sp);
	t(c.ss_size);
	t(c.ss_flags);
}

template <typename T>
void Class<__darwin_sigaltstack>::IterateStaticFields(T t)
{
}





template <>
class Class<__darwin_ucontext> : public IClass
{
public:
	static const constexpr int FieldCount = 6;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__darwin_ucontext'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __darwin_ucontext& c, T t);

	template <typename T>
	static void IterateFields(__darwin_ucontext& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__darwin_ucontext>::IterateFields(const __darwin_ucontext& c, T t)
{
	t(c.uc_onstack);
	t(c.uc_sigmask);
	t(c.uc_stack);
	t(c.uc_link);
	t(c.uc_mcsize);
	t(c.uc_mcontext);
}

template <typename T>
void Class<__darwin_ucontext>::IterateFields(__darwin_ucontext& c, T t)
{
	t(c.uc_onstack);
	t(c.uc_sigmask);
	t(c.uc_stack);
	t(c.uc_link);
	t(c.uc_mcsize);
	t(c.uc_mcontext);
}

template <typename T>
void Class<__darwin_ucontext>::IterateStaticFields(T t)
{
}





template <>
class Class<sigevent> : public IClass
{
public:
	static const constexpr int FieldCount = 5;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'sigevent'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const sigevent& c, T t);

	template <typename T>
	static void IterateFields(sigevent& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<sigevent>::IterateFields(const sigevent& c, T t)
{
	t(c.sigev_notify);
	t(c.sigev_signo);
	t(c.sigev_value);
	t(c.sigev_notify_function);
	t(c.sigev_notify_attributes);
}

template <typename T>
void Class<sigevent>::IterateFields(sigevent& c, T t)
{
	t(c.sigev_notify);
	t(c.sigev_signo);
	t(c.sigev_value);
	t(c.sigev_notify_function);
	t(c.sigev_notify_attributes);
}

template <typename T>
void Class<sigevent>::IterateStaticFields(T t)
{
}





template <>
class Class<__siginfo> : public IClass
{
public:
	static const constexpr int FieldCount = 10;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__siginfo'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __siginfo& c, T t);

	template <typename T>
	static void IterateFields(__siginfo& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__siginfo>::IterateFields(const __siginfo& c, T t)
{
	t(c.si_signo);
	t(c.si_errno);
	t(c.si_code);
	t(c.si_pid);
	t(c.si_uid);
	t(c.si_status);
	t(c.si_addr);
	t(c.si_value);
	t(c.si_band);
	t(c.__pad);
}

template <typename T>
void Class<__siginfo>::IterateFields(__siginfo& c, T t)
{
	t(c.si_signo);
	t(c.si_errno);
	t(c.si_code);
	t(c.si_pid);
	t(c.si_uid);
	t(c.si_status);
	t(c.si_addr);
	t(c.si_value);
	t(c.si_band);
	t(c.__pad);
}

template <typename T>
void Class<__siginfo>::IterateStaticFields(T t)
{
}





template <>
class Class<__siginfo> : public IClass
{
public:
	static const constexpr int FieldCount = 10;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__siginfo'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __siginfo& c, T t);

	template <typename T>
	static void IterateFields(__siginfo& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__siginfo>::IterateFields(const __siginfo& c, T t)
{
	t(c.si_signo);
	t(c.si_errno);
	t(c.si_code);
	t(c.si_pid);
	t(c.si_uid);
	t(c.si_status);
	t(c.si_addr);
	t(c.si_value);
	t(c.si_band);
	t(c.__pad);
}

template <typename T>
void Class<__siginfo>::IterateFields(__siginfo& c, T t)
{
	t(c.si_signo);
	t(c.si_errno);
	t(c.si_code);
	t(c.si_pid);
	t(c.si_uid);
	t(c.si_status);
	t(c.si_addr);
	t(c.si_value);
	t(c.si_band);
	t(c.__pad);
}

template <typename T>
void Class<__siginfo>::IterateStaticFields(T t)
{
}





template <>
class Class<__sigaction> : public IClass
{
public:
	static const constexpr int FieldCount = 4;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__sigaction'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __sigaction& c, T t);

	template <typename T>
	static void IterateFields(__sigaction& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__sigaction>::IterateFields(const __sigaction& c, T t)
{
	t(c.__sigaction_u);
	t(c.sa_tramp);
	t(c.sa_mask);
	t(c.sa_flags);
}

template <typename T>
void Class<__sigaction>::IterateFields(__sigaction& c, T t)
{
	t(c.__sigaction_u);
	t(c.sa_tramp);
	t(c.sa_mask);
	t(c.sa_flags);
}

template <typename T>
void Class<__sigaction>::IterateStaticFields(T t)
{
}





template <>
class Class<sigaction> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'sigaction'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const sigaction& c, T t);

	template <typename T>
	static void IterateFields(sigaction& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<sigaction>::IterateFields(const sigaction& c, T t)
{
	t(c.__sigaction_u);
	t(c.sa_mask);
	t(c.sa_flags);
}

template <typename T>
void Class<sigaction>::IterateFields(sigaction& c, T t)
{
	t(c.__sigaction_u);
	t(c.sa_mask);
	t(c.sa_flags);
}

template <typename T>
void Class<sigaction>::IterateStaticFields(T t)
{
}





template <>
class Class<sigvec> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'sigvec'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const sigvec& c, T t);

	template <typename T>
	static void IterateFields(sigvec& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<sigvec>::IterateFields(const sigvec& c, T t)
{
	t(c.sv_handler);
	t(c.sv_mask);
	t(c.sv_flags);
}

template <typename T>
void Class<sigvec>::IterateFields(sigvec& c, T t)
{
	t(c.sv_handler);
	t(c.sv_mask);
	t(c.sv_flags);
}

template <typename T>
void Class<sigvec>::IterateStaticFields(T t)
{
}





template <>
class Class<sigstack> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'sigstack'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const sigstack& c, T t);

	template <typename T>
	static void IterateFields(sigstack& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<sigstack>::IterateFields(const sigstack& c, T t)
{
	t(c.ss_sp);
	t(c.ss_onstack);
}

template <typename T>
void Class<sigstack>::IterateFields(sigstack& c, T t)
{
	t(c.ss_sp);
	t(c.ss_onstack);
}

template <typename T>
void Class<sigstack>::IterateStaticFields(T t)
{
}





template <>
class Function<void (*)(int)(*)(int, void (*)(int)), ::signal> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Class<timeval> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'timeval'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const timeval& c, T t);

	template <typename T>
	static void IterateFields(timeval& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<timeval>::IterateFields(const timeval& c, T t)
{
	t(c.tv_sec);
	t(c.tv_usec);
}

template <typename T>
void Class<timeval>::IterateFields(timeval& c, T t)
{
	t(c.tv_sec);
	t(c.tv_usec);
}

template <typename T>
void Class<timeval>::IterateStaticFields(T t)
{
}





template <>
class Class<rusage> : public IClass
{
public:
	static const constexpr int FieldCount = 16;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rusage'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rusage& c, T t);

	template <typename T>
	static void IterateFields(rusage& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rusage>::IterateFields(const rusage& c, T t)
{
	t(c.ru_utime);
	t(c.ru_stime);
	t(c.ru_maxrss);
	t(c.ru_ixrss);
	t(c.ru_idrss);
	t(c.ru_isrss);
	t(c.ru_minflt);
	t(c.ru_majflt);
	t(c.ru_nswap);
	t(c.ru_inblock);
	t(c.ru_oublock);
	t(c.ru_msgsnd);
	t(c.ru_msgrcv);
	t(c.ru_nsignals);
	t(c.ru_nvcsw);
	t(c.ru_nivcsw);
}

template <typename T>
void Class<rusage>::IterateFields(rusage& c, T t)
{
	t(c.ru_utime);
	t(c.ru_stime);
	t(c.ru_maxrss);
	t(c.ru_ixrss);
	t(c.ru_idrss);
	t(c.ru_isrss);
	t(c.ru_minflt);
	t(c.ru_majflt);
	t(c.ru_nswap);
	t(c.ru_inblock);
	t(c.ru_oublock);
	t(c.ru_msgsnd);
	t(c.ru_msgrcv);
	t(c.ru_nsignals);
	t(c.ru_nvcsw);
	t(c.ru_nivcsw);
}

template <typename T>
void Class<rusage>::IterateStaticFields(T t)
{
}





template <>
class Class<rusage_info_v0> : public IClass
{
public:
	static const constexpr int FieldCount = 11;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rusage_info_v0'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rusage_info_v0& c, T t);

	template <typename T>
	static void IterateFields(rusage_info_v0& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rusage_info_v0>::IterateFields(const rusage_info_v0& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
}

template <typename T>
void Class<rusage_info_v0>::IterateFields(rusage_info_v0& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
}

template <typename T>
void Class<rusage_info_v0>::IterateStaticFields(T t)
{
}





template <>
class Class<rusage_info_v1> : public IClass
{
public:
	static const constexpr int FieldCount = 17;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rusage_info_v1'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rusage_info_v1& c, T t);

	template <typename T>
	static void IterateFields(rusage_info_v1& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rusage_info_v1>::IterateFields(const rusage_info_v1& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
}

template <typename T>
void Class<rusage_info_v1>::IterateFields(rusage_info_v1& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
}

template <typename T>
void Class<rusage_info_v1>::IterateStaticFields(T t)
{
}





template <>
class Class<rusage_info_v2> : public IClass
{
public:
	static const constexpr int FieldCount = 19;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rusage_info_v2'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rusage_info_v2& c, T t);

	template <typename T>
	static void IterateFields(rusage_info_v2& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rusage_info_v2>::IterateFields(const rusage_info_v2& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
	t(c.ri_diskio_bytesread);
	t(c.ri_diskio_byteswritten);
}

template <typename T>
void Class<rusage_info_v2>::IterateFields(rusage_info_v2& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
	t(c.ri_diskio_bytesread);
	t(c.ri_diskio_byteswritten);
}

template <typename T>
void Class<rusage_info_v2>::IterateStaticFields(T t)
{
}





template <>
class Class<rusage_info_v3> : public IClass
{
public:
	static const constexpr int FieldCount = 28;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rusage_info_v3'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rusage_info_v3& c, T t);

	template <typename T>
	static void IterateFields(rusage_info_v3& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rusage_info_v3>::IterateFields(const rusage_info_v3& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
	t(c.ri_diskio_bytesread);
	t(c.ri_diskio_byteswritten);
	t(c.ri_cpu_time_qos_default);
	t(c.ri_cpu_time_qos_maintenance);
	t(c.ri_cpu_time_qos_background);
	t(c.ri_cpu_time_qos_utility);
	t(c.ri_cpu_time_qos_legacy);
	t(c.ri_cpu_time_qos_user_initiated);
	t(c.ri_cpu_time_qos_user_interactive);
	t(c.ri_billed_system_time);
	t(c.ri_serviced_system_time);
}

template <typename T>
void Class<rusage_info_v3>::IterateFields(rusage_info_v3& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
	t(c.ri_diskio_bytesread);
	t(c.ri_diskio_byteswritten);
	t(c.ri_cpu_time_qos_default);
	t(c.ri_cpu_time_qos_maintenance);
	t(c.ri_cpu_time_qos_background);
	t(c.ri_cpu_time_qos_utility);
	t(c.ri_cpu_time_qos_legacy);
	t(c.ri_cpu_time_qos_user_initiated);
	t(c.ri_cpu_time_qos_user_interactive);
	t(c.ri_billed_system_time);
	t(c.ri_serviced_system_time);
}

template <typename T>
void Class<rusage_info_v3>::IterateStaticFields(T t)
{
}





template <>
class Class<rusage_info_v4> : public IClass
{
public:
	static const constexpr int FieldCount = 36;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rusage_info_v4'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rusage_info_v4& c, T t);

	template <typename T>
	static void IterateFields(rusage_info_v4& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rusage_info_v4>::IterateFields(const rusage_info_v4& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
	t(c.ri_diskio_bytesread);
	t(c.ri_diskio_byteswritten);
	t(c.ri_cpu_time_qos_default);
	t(c.ri_cpu_time_qos_maintenance);
	t(c.ri_cpu_time_qos_background);
	t(c.ri_cpu_time_qos_utility);
	t(c.ri_cpu_time_qos_legacy);
	t(c.ri_cpu_time_qos_user_initiated);
	t(c.ri_cpu_time_qos_user_interactive);
	t(c.ri_billed_system_time);
	t(c.ri_serviced_system_time);
	t(c.ri_logical_writes);
	t(c.ri_lifetime_max_phys_footprint);
	t(c.ri_instructions);
	t(c.ri_cycles);
	t(c.ri_billed_energy);
	t(c.ri_serviced_energy);
	t(c.ri_interval_max_phys_footprint);
	t(c.ri_unused);
}

template <typename T>
void Class<rusage_info_v4>::IterateFields(rusage_info_v4& c, T t)
{
	t(c.ri_uuid);
	t(c.ri_user_time);
	t(c.ri_system_time);
	t(c.ri_pkg_idle_wkups);
	t(c.ri_interrupt_wkups);
	t(c.ri_pageins);
	t(c.ri_wired_size);
	t(c.ri_resident_size);
	t(c.ri_phys_footprint);
	t(c.ri_proc_start_abstime);
	t(c.ri_proc_exit_abstime);
	t(c.ri_child_user_time);
	t(c.ri_child_system_time);
	t(c.ri_child_pkg_idle_wkups);
	t(c.ri_child_interrupt_wkups);
	t(c.ri_child_pageins);
	t(c.ri_child_elapsed_abstime);
	t(c.ri_diskio_bytesread);
	t(c.ri_diskio_byteswritten);
	t(c.ri_cpu_time_qos_default);
	t(c.ri_cpu_time_qos_maintenance);
	t(c.ri_cpu_time_qos_background);
	t(c.ri_cpu_time_qos_utility);
	t(c.ri_cpu_time_qos_legacy);
	t(c.ri_cpu_time_qos_user_initiated);
	t(c.ri_cpu_time_qos_user_interactive);
	t(c.ri_billed_system_time);
	t(c.ri_serviced_system_time);
	t(c.ri_logical_writes);
	t(c.ri_lifetime_max_phys_footprint);
	t(c.ri_instructions);
	t(c.ri_cycles);
	t(c.ri_billed_energy);
	t(c.ri_serviced_energy);
	t(c.ri_interval_max_phys_footprint);
	t(c.ri_unused);
}

template <typename T>
void Class<rusage_info_v4>::IterateStaticFields(T t)
{
}





template <>
class Class<rlimit> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'rlimit'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const rlimit& c, T t);

	template <typename T>
	static void IterateFields(rlimit& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<rlimit>::IterateFields(const rlimit& c, T t)
{
	t(c.rlim_cur);
	t(c.rlim_max);
}

template <typename T>
void Class<rlimit>::IterateFields(rlimit& c, T t)
{
	t(c.rlim_cur);
	t(c.rlim_max);
}

template <typename T>
void Class<rlimit>::IterateStaticFields(T t)
{
}





template <>
class Class<proc_rlimit_control_wakeupmon> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'proc_rlimit_control_wakeupmon'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const proc_rlimit_control_wakeupmon& c, T t);

	template <typename T>
	static void IterateFields(proc_rlimit_control_wakeupmon& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<proc_rlimit_control_wakeupmon>::IterateFields(const proc_rlimit_control_wakeupmon& c, T t)
{
	t(c.wm_flags);
	t(c.wm_rate);
}

template <typename T>
void Class<proc_rlimit_control_wakeupmon>::IterateFields(proc_rlimit_control_wakeupmon& c, T t)
{
	t(c.wm_flags);
	t(c.wm_rate);
}

template <typename T>
void Class<proc_rlimit_control_wakeupmon>::IterateStaticFields(T t)
{
}





template <>
class Function<int(*)(int, id_t), ::getpriority> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, int), ::getiopolicy_np> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, struct rlimit *), ::getrlimit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, struct rusage *), ::getrusage> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, id_t, int), ::setpriority> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, int, int), ::setiopolicy_np> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, const struct rlimit *), ::setrlimit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Class<wait> : public IClass
{
public:
	static const constexpr int FieldCount = 4;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'wait'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const wait& c, T t);

	template <typename T>
	static void IterateFields(wait& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<wait>::IterateFields(const wait& c, T t)
{
	t(c.w_Termsig);
	t(c.w_Coredump);
	t(c.w_Retcode);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateFields(wait& c, T t)
{
	t(c.w_Termsig);
	t(c.w_Coredump);
	t(c.w_Retcode);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateStaticFields(T t)
{
}





template <>
class Class<wait> : public IClass
{
public:
	static const constexpr int FieldCount = 4;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'wait'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const wait& c, T t);

	template <typename T>
	static void IterateFields(wait& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<wait>::IterateFields(const wait& c, T t)
{
	t(c.w_Termsig);
	t(c.w_Coredump);
	t(c.w_Retcode);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateFields(wait& c, T t)
{
	t(c.w_Termsig);
	t(c.w_Coredump);
	t(c.w_Retcode);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateStaticFields(T t)
{
}





template <>
class Class<wait> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'wait'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const wait& c, T t);

	template <typename T>
	static void IterateFields(wait& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<wait>::IterateFields(const wait& c, T t)
{
	t(c.w_Stopval);
	t(c.w_Stopsig);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateFields(wait& c, T t)
{
	t(c.w_Stopval);
	t(c.w_Stopsig);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateStaticFields(T t)
{
}





template <>
class Class<wait> : public IClass
{
public:
	static const constexpr int FieldCount = 3;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'wait'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const wait& c, T t);

	template <typename T>
	static void IterateFields(wait& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<wait>::IterateFields(const wait& c, T t)
{
	t(c.w_Stopval);
	t(c.w_Stopsig);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateFields(wait& c, T t)
{
	t(c.w_Stopval);
	t(c.w_Stopsig);
	t(c.w_Filler);
}

template <typename T>
void Class<wait>::IterateStaticFields(T t)
{
}





template <>
class Function<pid_t(*)(int *), ::wait> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<pid_t(*)(pid_t, int *, int), ::waitpid> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<pid_t(*)(int *, int, struct rusage *), ::wait3> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(size_t), ::alloca> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(size_t), ::malloc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(size_t, size_t), ::calloc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *), ::free> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(void *, size_t), ::realloc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(size_t), ::valloc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void **, size_t, size_t), ::posix_memalign> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(), ::abort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::abs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void (*)()), ::atexit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<double(*)(const char *), ::atof> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::atoi> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(const char *), ::atol> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long long(*)(const char *), ::atoll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<div_t(*)(int, int), ::div> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(int), ::exit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *), ::getenv> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(long), ::labs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<ldiv_t(*)(long, long), ::ldiv> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long long(*)(long long), ::llabs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<lldiv_t(*)(long long, long long), ::lldiv> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, size_t), ::mblen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(), ::rand> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(unsigned int), ::srand> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<double(*)(const char *, char **), ::strtod> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<float(*)(const char *, char **), ::strtof> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(const char *, char **, int), ::strtol> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long double(*)(const char *, char **), ::strtold> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long long(*)(const char *, char **, int), ::strtoll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned long(*)(const char *, char **, int), ::strtoul> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned long long(*)(const char *, char **, int), ::strtoull> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::system> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, wchar_t), ::wctomb> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(int), ::_Exit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(const char *), ::a64l> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<double(*)(), ::drand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(double, int, int *, int *), ::ecvt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<double(*)(unsigned short [3]), ::erand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(double, int, int *, int *), ::fcvt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(double, int, char *), ::gcvt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char **, char *const *, char **), ::getsubopt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::grantpt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(unsigned int, char *, size_t), ::initstate> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(unsigned short [3]), ::jrand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(long), ::l64a> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(unsigned short [7]), ::lcong48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(), ::lrand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *), ::mktemp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *), ::mkstemp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(), ::mrand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(unsigned short [3]), ::nrand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::posix_openpt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(int), ::ptsname> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, char *, size_t), ::ptsname_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *), ::putenv> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(), ::random> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(unsigned int *), ::rand_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, char *), ::realpath> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned short *(*)(unsigned short [3]), ::seed48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *, int), ::setenv> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(const char *), ::setkey> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *), ::setstate> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(long), ::srand48> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(unsigned int), ::srandom> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::unlockpt> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::unsetenv> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<uint32_t(*)(), ::arc4random> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(unsigned char *, int), ::arc4random_addrandom> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t), ::arc4random_buf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(), ::arc4random_stir> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<uint32_t(*)(uint32_t), ::arc4random_uniform> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void (^)()), ::atexit_b> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, const char *, int), ::cgetcap> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(), ::cgetclose> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char **, char **, const char *), ::cgetent> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char **, char **), ::cgetfirst> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *), ::cgetmatch> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char **, char **), ::cgetnext> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, const char *, long *), ::cgetnum> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::cgetset> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, const char *, char **), ::cgetstr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, const char *, char **), ::cgetustr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, int), ::daemon> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(dev_t, mode_t), ::devname> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(int *, long *), ::getbsize> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(double [], int), ::getloadavg> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<const char *(*)(), ::getprogname> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(const char *), ::setprogname> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(), ::sranddev> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(), ::srandomdev> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(void *, size_t), ::reallocf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long long(*)(const char *, char **, int), ::strtoq> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned long long(*)(const char *, char **, int), ::strtouq> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(std::size_t), operator new> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(std::size_t, const std::nothrow_t &), operator new> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *), operator delete> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, const std::nothrow_t &), operator delete> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, std::size_t), operator delete> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(std::size_t), operator new[]> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *), operator delete[]> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, const std::nothrow_t &), operator delete[]> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(void *, std::size_t), operator delete[]> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, const char *, int, const char *), ::renameat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *, unsigned int), ::renamex_np> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Class<__sbuf> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__sbuf'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __sbuf& c, T t);

	template <typename T>
	static void IterateFields(__sbuf& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__sbuf>::IterateFields(const __sbuf& c, T t)
{
	t(c._base);
	t(c._size);
}

template <typename T>
void Class<__sbuf>::IterateFields(__sbuf& c, T t)
{
	t(c._base);
	t(c._size);
}

template <typename T>
void Class<__sbuf>::IterateStaticFields(T t)
{
}





template <>
class Class<__sFILEX> : public IClass
{
public:
	static const constexpr int FieldCount = 0;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__sFILEX'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __sFILEX& c, T t);

	template <typename T>
	static void IterateFields(__sFILEX& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__sFILEX>::IterateFields(const __sFILEX& c, T t)
{
}

template <typename T>
void Class<__sFILEX>::IterateFields(__sFILEX& c, T t)
{
}

template <typename T>
void Class<__sFILEX>::IterateStaticFields(T t)
{
}





template <>
class Class<__sFILE> : public IClass
{
public:
	static const constexpr int FieldCount = 20;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__sFILE'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __sFILE& c, T t);

	template <typename T>
	static void IterateFields(__sFILE& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__sFILE>::IterateFields(const __sFILE& c, T t)
{
	t(c._p);
	t(c._r);
	t(c._w);
	t(c._flags);
	t(c._file);
	t(c._bf);
	t(c._lbfsize);
	t(c._cookie);
	t(c._close);
	t(c._read);
	t(c._seek);
	t(c._write);
	t(c._ub);
	t(c._extra);
	t(c._ur);
	t(c._ubuf);
	t(c._nbuf);
	t(c._lb);
	t(c._blksize);
	t(c._offset);
}

template <typename T>
void Class<__sFILE>::IterateFields(__sFILE& c, T t)
{
	t(c._p);
	t(c._r);
	t(c._w);
	t(c._flags);
	t(c._file);
	t(c._bf);
	t(c._lbfsize);
	t(c._cookie);
	t(c._close);
	t(c._read);
	t(c._seek);
	t(c._write);
	t(c._ub);
	t(c._extra);
	t(c._ur);
	t(c._ubuf);
	t(c._nbuf);
	t(c._lb);
	t(c._blksize);
	t(c._offset);
}

template <typename T>
void Class<__sFILE>::IterateStaticFields(T t)
{
}





template <>
class Class<__sFILE> : public IClass
{
public:
	static const constexpr int FieldCount = 20;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of '__sFILE'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const __sFILE& c, T t);

	template <typename T>
	static void IterateFields(__sFILE& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<__sFILE>::IterateFields(const __sFILE& c, T t)
{
	t(c._p);
	t(c._r);
	t(c._w);
	t(c._flags);
	t(c._file);
	t(c._bf);
	t(c._lbfsize);
	t(c._cookie);
	t(c._close);
	t(c._read);
	t(c._seek);
	t(c._write);
	t(c._ub);
	t(c._extra);
	t(c._ur);
	t(c._ubuf);
	t(c._nbuf);
	t(c._lb);
	t(c._blksize);
	t(c._offset);
}

template <typename T>
void Class<__sFILE>::IterateFields(__sFILE& c, T t)
{
	t(c._p);
	t(c._r);
	t(c._w);
	t(c._flags);
	t(c._file);
	t(c._bf);
	t(c._lbfsize);
	t(c._cookie);
	t(c._close);
	t(c._read);
	t(c._seek);
	t(c._write);
	t(c._ub);
	t(c._extra);
	t(c._ur);
	t(c._ubuf);
	t(c._nbuf);
	t(c._lb);
	t(c._blksize);
	t(c._offset);
}

template <typename T>
void Class<__sFILE>::IterateStaticFields(T t)
{
}





template <>
class Function<void(*)(FILE *), ::clearerr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::fclose> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::feof> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::ferror> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::fflush> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::fgetc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, fpos_t *), ::fgetpos> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *, int, FILE *), ::fgets> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(const char *, const char *), ::fopen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const char *), ::fprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), ::fputc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, FILE *), ::fputs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(const char *, const char *, FILE *), ::freopen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const char *), ::fscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, long, int), ::fseek> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const fpos_t *), ::fsetpos> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(FILE *), ::ftell> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::getc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(), ::getchar> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *), ::gets> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(const char *), ::perror> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::printf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), ::putc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::putchar> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::puts> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::remove> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *), ::rename> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(FILE *), ::rewind> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *), ::scanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(FILE *, char *), ::setbuf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, char *, int, size_t), ::setvbuf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, const char *), ::sprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *), ::sscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(), ::tmpfile> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *), ::tmpnam> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), ::ungetc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const char *, va_list), ::vfprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, va_list), ::vprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, const char *, va_list), ::vsprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *), ::ctermid> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(int, const char *), ::fdopen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::fileno> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::pclose> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(const char *, const char *), ::popen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::__srget> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const char *, va_list), ::__svfscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), ::__swbuf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), __sputc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(FILE *), ::flockfile> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::ftrylockfile> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(FILE *), ::funlockfile> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::getc_unlocked> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(), ::getchar_unlocked> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), ::putc_unlocked> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ::putchar_unlocked> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::getw> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, FILE *), ::putw> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, const char *), ::tempnam> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, off_t, int), ::fseeko> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<off_t(*)(FILE *), ::ftello> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, size_t, const char *), ::snprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const char *, va_list), ::vfscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, va_list), ::vscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const char *, const char *, va_list), ::vsscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, const char *), ::dprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int, const char *, va_list), ::vdprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<ssize_t(*)(char **, size_t *, FILE *), ::getline> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(void *, size_t, const char *), ::fmemopen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(char **, size_t *), ::open_memstream> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char **, const char *), ::asprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(char *), ::ctermid_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(FILE *, size_t *), ::fgetln> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<const char *(*)(const char *, const char *), ::fmtcheck> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::fpurge> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(FILE *, char *, int), ::setbuffer> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *), ::setlinebuf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(char **, const char *, va_list), ::vasprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(const char *, const char *, int), ::zopen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Class<timespec> : public IClass
{
public:
	static const constexpr int FieldCount = 2;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'timespec'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const timespec& c, T t);

	template <typename T>
	static void IterateFields(timespec& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<timespec>::IterateFields(const timespec& c, T t)
{
	t(c.tv_sec);
	t(c.tv_nsec);
}

template <typename T>
void Class<timespec>::IterateFields(timespec& c, T t)
{
	t(c.tv_sec);
	t(c.tv_nsec);
}

template <typename T>
void Class<timespec>::IterateStaticFields(T t)
{
}





template <>
class Class<tm> : public IClass
{
public:
	static const constexpr int FieldCount = 11;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'tm'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const tm& c, T t);

	template <typename T>
	static void IterateFields(tm& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<tm>::IterateFields(const tm& c, T t)
{
	t(c.tm_sec);
	t(c.tm_min);
	t(c.tm_hour);
	t(c.tm_mday);
	t(c.tm_mon);
	t(c.tm_year);
	t(c.tm_wday);
	t(c.tm_yday);
	t(c.tm_isdst);
	t(c.tm_gmtoff);
	t(c.tm_zone);
}

template <typename T>
void Class<tm>::IterateFields(tm& c, T t)
{
	t(c.tm_sec);
	t(c.tm_min);
	t(c.tm_hour);
	t(c.tm_mday);
	t(c.tm_mon);
	t(c.tm_year);
	t(c.tm_wday);
	t(c.tm_yday);
	t(c.tm_isdst);
	t(c.tm_gmtoff);
	t(c.tm_zone);
}

template <typename T>
void Class<tm>::IterateStaticFields(T t)
{
}





template <>
class Function<char *(*)(const struct tm *), ::asctime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<clock_t(*)(), ::clock> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const time_t *), ::ctime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<double(*)(time_t, time_t), ::difftime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<struct tm *(*)(const char *), ::getdate> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<struct tm *(*)(const time_t *), ::gmtime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<struct tm *(*)(const time_t *), ::localtime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<time_t(*)(struct tm *), ::mktime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const char *, const char *, struct tm *), ::strptime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<time_t(*)(time_t *), ::time> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(), ::tzset> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const struct tm *, char *), ::asctime_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<char *(*)(const time_t *, char *), ::ctime_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<time_t(*)(time_t), ::posix2time> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(), ::tzsetwall> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<time_t(*)(time_t), ::time2posix> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<time_t(*)(struct tm *const), ::timelocal> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<time_t(*)(struct tm *const), ::timegm> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(clockid_t, struct timespec *), ::clock_getres> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(clockid_t, struct timespec *), ::clock_gettime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(clockid_t, const struct timespec *), ::clock_settime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isascii> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(__darwin_ct_rune_t), __wcwidth> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isalnum> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isalpha> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isblank> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), iscntrl> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isdigit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isgraph> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), islower> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isprint> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ispunct> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isspace> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isupper> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isxdigit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), toascii> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), tolower> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), toupper> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), digittoint> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), ishexnumber> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isideogram> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isnumber> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isphonogram> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isrune> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(int), isspecial> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswalnum> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswalpha> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswcntrl> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t, wctype_t), iswctype> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswdigit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswgraph> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswlower> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswprint> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswpunct> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswspace> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswupper> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswxdigit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wint_t), towlower> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wint_t), towupper> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wctype_t(*)(const char *), ::wctype> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(int), ::btowc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(FILE *), ::fgetwc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wchar_t, FILE *), ::fputwc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, FILE *), ::fputws> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, int), ::fwide> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const wchar_t *), ::fwprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const wchar_t *), ::fwscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(FILE *), ::getwc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(), ::getwchar> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const mbstate_t *), ::mbsinit> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wchar_t, FILE *), ::putwc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wchar_t), ::putwchar> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wint_t, FILE *), ::ungetwc> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const wchar_t *), ::wcslen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), ::wctob> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<double(*)(const wchar_t *, wchar_t **), ::wcstod> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *), ::wprintf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *), ::wscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, size_t), ::wcswidth> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wchar_t), ::wcwidth> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<float(*)(const wchar_t *, wchar_t **), ::wcstof> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(const wchar_t *), ::wcsdup> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswblank> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswascii> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswhexnumber> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswideogram> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswnumber> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswphonogram> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswrune> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<int(*)(wint_t), iswspecial> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wint_t, wctype_t), ::nextwctype> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wint_t(*)(wint_t, wctrans_t), ::towctrans> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<wctrans_t(*)(const char *), ::wctrans> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(std::string), foo::bar> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Class<foo::Bar> : public IClass
{
public:
	static const constexpr int FieldCount = 1;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'foo::Bar'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const foo::Bar& c, T t);

	template <typename T>
	static void IterateFields(foo::Bar& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<foo::Bar>::IterateFields(const foo::Bar& c, T t)
{
	t(c.vec);
}

template <typename T>
void Class<foo::Bar>::IterateFields(foo::Bar& c, T t)
{
	t(c.vec);
}

template <typename T>
void Class<foo::Bar>::IterateStaticFields(T t)
{
}





template <>
class Class<Logger> : public IClass
{
public:
	static const constexpr int FieldCount = 0;
	static const constexpr int StaticFieldCount = 0;
	static const constexpr int MethodCount = 0;
	static const constexpr int StaticMethodCount = 0;

	int GetFieldCount() const override;
	Reference GetField(
			const Reference& o, const std::string& name) const override;

	int GetStaticFieldCount() const override;
	Reference GetStaticField(const std::string& name) const override;

	int GetMethodCount() const override;
	std::vector<std::unique_ptr<IMethod>> GetMethod(
			const std::string& name) const override;

	int GetStaticMethodCount() const override;
	std::vector<std::unique_ptr<IFunction>> GetStaticMethod(
			const std::string& name) const override;

	const std::string& GetName() const override;

	// Calls T::operator() on each field of 'Logger'.
	// Works well with C++14 generic lambdas.
	template <typename T>
	static void IterateFields(const Logger& c, T t);

	template <typename T>
	static void IterateFields(Logger& c, T t);

	template <typename T>
	static void IterateStaticFields(T t);
};

template <typename T>
void Class<Logger>::IterateFields(const Logger& c, T t)
{
}

template <typename T>
void Class<Logger>::IterateFields(Logger& c, T t)
{
}

template <typename T>
void Class<Logger>::IterateStaticFields(T t)
{
}





template <>
class Function<Logger *(*)(), ::log_create> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};



template <>
class Function<void(*)(Logger *, const char *), ::log_write> : public IFunction
{
	int GetParameterCount() const override;
	Parameter GetReturnType() const override;
	Parameter GetParameter(int i) const override;

	const std::string& GetName() const override;

	Object Invoke(const std::vector<Object>& args) override;
};


}  // namespace reflang

#endif //REFLANG_METADATA_SAMPLE_GEN_H
