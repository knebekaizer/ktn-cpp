// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This file is auto-generated by Reflang. !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#include "sample/gen.h"

#include <algorithm>
#include <cassert>
#include <stdexcept>
#include <type_traits>

namespace reflang
{


const int Class<TheStruct>::FieldCount;
const int Class<TheStruct>::StaticFieldCount;
const int Class<TheStruct>::MethodCount;
const int Class<TheStruct>::StaticMethodCount;

int Class<TheStruct>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<TheStruct>::GetField(const Reference& r, const std::string& name) const
{
	throw Exception("Invalid name passed to GetField().");
}

int Class<TheStruct>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<TheStruct>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<TheStruct>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<TheStruct>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<TheStruct>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<TheStruct>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string TheStruct_name = "TheStruct";

const std::string& Class<TheStruct>::GetName() const
{
	return TheStruct_name;
}



namespace
{
	// Object to auto-register TheStruct.
	struct TheStruct_registrar
	{
		TheStruct_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<TheStruct>>());
		}
	} TheStruct_instance;
}


const int Class<TheClass>::FieldCount;
const int Class<TheClass>::StaticFieldCount;
const int Class<TheClass>::MethodCount;
const int Class<TheClass>::StaticMethodCount;

int Class<TheClass>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<TheClass>::GetField(const Reference& r, const std::string& name) const
{
	throw Exception("Invalid name passed to GetField().");
}

int Class<TheClass>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<TheClass>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<TheClass>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<TheClass>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<TheClass>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<TheClass>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string TheClass_name = "TheClass";

const std::string& Class<TheClass>::GetName() const
{
	return TheClass_name;
}



namespace
{
	// Object to auto-register TheClass.
	struct TheClass_registrar
	{
		TheClass_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<TheClass>>());
		}
	} TheClass_instance;
}


const int Class<MyClass>::FieldCount;
const int Class<MyClass>::StaticFieldCount;
const int Class<MyClass>::MethodCount;
const int Class<MyClass>::StaticMethodCount;

int Class<MyClass>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<MyClass>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<MyClass>())
	{
		MyClass& o = r.GetT<MyClass>();
		if (name == "x")
		{
			return Reference(o.x);
		}
	}
	else if (r.IsT<const MyClass>())
	{
		const MyClass& o = r.GetT<const MyClass>();
		if (name == "x")
		{
			return Reference(o.x);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<MyClass>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<MyClass>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<MyClass>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<MyClass>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;
	if (name == "foo")
	{
		results.push_back(std::make_unique<Method<decltype(&MyClass::foo), &MyClass::foo>>());
	}
	else if (name == "v_foo")
	{
		results.push_back(std::make_unique<Method<decltype(&MyClass::v_foo), &MyClass::v_foo>>());
	}

	return results;
}

int Class<MyClass>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<MyClass>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;
	if (name == "s_foo")
	{
		results.push_back(std::make_unique<Function<void(*)(MyClass *), MyClass::s_foo>>());
	}

	return results;
}

static const std::string MyClass_name = "MyClass";

const std::string& Class<MyClass>::GetName() const
{
	return MyClass_name;
}

// MyClass methods definitions.
static std::string MyClass_foo_name = "foo";

const std::string& Method<decltype(&MyClass::foo), &MyClass::foo>::GetName() const
{
	return MyClass_foo_name;
}

int Method<decltype(&MyClass::foo), &MyClass::foo>::GetParameterCount() const
{
	return 0;
}

Object Method<decltype(&MyClass::foo), &MyClass::foo>::Invoke(
		const Reference& o, const std::vector<Object>& args)
{
	if (args.size() != 0)
	{
		throw Exception("Invoke(): bad argument count.");
	}
	((o.GetT<MyClass>()).*(&MyClass::foo))();
	return Object();
}

static std::string MyClass_v_foo_name = "v_foo";

const std::string& Method<decltype(&MyClass::v_foo), &MyClass::v_foo>::GetName() const
{
	return MyClass_v_foo_name;
}

int Method<decltype(&MyClass::v_foo), &MyClass::v_foo>::GetParameterCount() const
{
	return 0;
}

Object Method<decltype(&MyClass::v_foo), &MyClass::v_foo>::Invoke(
		const Reference& o, const std::vector<Object>& args)
{
	if (args.size() != 0)
	{
		throw Exception("Invoke(): bad argument count.");
	}
	((o.GetT<MyClass>()).*(&MyClass::v_foo))();
	return Object();
}

// End of MyClass methods definitions.
// MyClass static methods definitions.

int Function<void(*)(MyClass *), MyClass::s_foo>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(MyClass *), MyClass::s_foo>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(MyClass *), MyClass::s_foo>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "self";
		result.type = "MyClass *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string MyClass__s_foo_name = "MyClass::s_foo";

const std::string& Function<void(*)(MyClass *), MyClass::s_foo>::GetName() const
{
	return MyClass__s_foo_name;
}

Object Function<void(*)(MyClass *), MyClass::s_foo>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	MyClass::s_foo(args[0].GetT<std::decay_t<MyClass *>>());
	return Object();
}

namespace
{
	// Object to auto-register MyClass::s_foo.
	struct MyClass__s_foo_registrar
	{
		MyClass__s_foo_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(MyClass *), MyClass::s_foo>>());
		}
	} MyClass__s_foo_instance;
}
// End of MyClass static methods definitions.


namespace
{
	// Object to auto-register MyClass.
	struct MyClass_registrar
	{
		MyClass_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<MyClass>>());
		}
	} MyClass_instance;
}


const int Class<__darwin_pthread_handler_rec>::FieldCount;
const int Class<__darwin_pthread_handler_rec>::StaticFieldCount;
const int Class<__darwin_pthread_handler_rec>::MethodCount;
const int Class<__darwin_pthread_handler_rec>::StaticMethodCount;

int Class<__darwin_pthread_handler_rec>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_pthread_handler_rec>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_pthread_handler_rec>())
	{
		__darwin_pthread_handler_rec& o = r.GetT<__darwin_pthread_handler_rec>();
		if (name == "__routine")
		{
			return Reference(o.__routine);
		}
		if (name == "__arg")
		{
			return Reference(o.__arg);
		}
		if (name == "__next")
		{
			return Reference(o.__next);
		}
	}
	else if (r.IsT<const __darwin_pthread_handler_rec>())
	{
		const __darwin_pthread_handler_rec& o = r.GetT<const __darwin_pthread_handler_rec>();
		if (name == "__routine")
		{
			return Reference(o.__routine);
		}
		if (name == "__arg")
		{
			return Reference(o.__arg);
		}
		if (name == "__next")
		{
			return Reference(o.__next);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_pthread_handler_rec>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_pthread_handler_rec>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_pthread_handler_rec>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_pthread_handler_rec>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_pthread_handler_rec>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_pthread_handler_rec>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_pthread_handler_rec_name = "__darwin_pthread_handler_rec";

const std::string& Class<__darwin_pthread_handler_rec>::GetName() const
{
	return __darwin_pthread_handler_rec_name;
}



namespace
{
	// Object to auto-register __darwin_pthread_handler_rec.
	struct __darwin_pthread_handler_rec_registrar
	{
		__darwin_pthread_handler_rec_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_pthread_handler_rec>>());
		}
	} __darwin_pthread_handler_rec_instance;
}


const int Class<_opaque_pthread_attr_t>::FieldCount;
const int Class<_opaque_pthread_attr_t>::StaticFieldCount;
const int Class<_opaque_pthread_attr_t>::MethodCount;
const int Class<_opaque_pthread_attr_t>::StaticMethodCount;

int Class<_opaque_pthread_attr_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_attr_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_attr_t>())
	{
		_opaque_pthread_attr_t& o = r.GetT<_opaque_pthread_attr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_attr_t>())
	{
		const _opaque_pthread_attr_t& o = r.GetT<const _opaque_pthread_attr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_attr_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_attr_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_attr_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_attr_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_attr_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_attr_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_attr_t_name = "_opaque_pthread_attr_t";

const std::string& Class<_opaque_pthread_attr_t>::GetName() const
{
	return _opaque_pthread_attr_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_attr_t.
	struct _opaque_pthread_attr_t_registrar
	{
		_opaque_pthread_attr_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_attr_t>>());
		}
	} _opaque_pthread_attr_t_instance;
}


const int Class<_opaque_pthread_cond_t>::FieldCount;
const int Class<_opaque_pthread_cond_t>::StaticFieldCount;
const int Class<_opaque_pthread_cond_t>::MethodCount;
const int Class<_opaque_pthread_cond_t>::StaticMethodCount;

int Class<_opaque_pthread_cond_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_cond_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_cond_t>())
	{
		_opaque_pthread_cond_t& o = r.GetT<_opaque_pthread_cond_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_cond_t>())
	{
		const _opaque_pthread_cond_t& o = r.GetT<const _opaque_pthread_cond_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_cond_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_cond_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_cond_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_cond_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_cond_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_cond_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_cond_t_name = "_opaque_pthread_cond_t";

const std::string& Class<_opaque_pthread_cond_t>::GetName() const
{
	return _opaque_pthread_cond_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_cond_t.
	struct _opaque_pthread_cond_t_registrar
	{
		_opaque_pthread_cond_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_cond_t>>());
		}
	} _opaque_pthread_cond_t_instance;
}


const int Class<_opaque_pthread_condattr_t>::FieldCount;
const int Class<_opaque_pthread_condattr_t>::StaticFieldCount;
const int Class<_opaque_pthread_condattr_t>::MethodCount;
const int Class<_opaque_pthread_condattr_t>::StaticMethodCount;

int Class<_opaque_pthread_condattr_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_condattr_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_condattr_t>())
	{
		_opaque_pthread_condattr_t& o = r.GetT<_opaque_pthread_condattr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_condattr_t>())
	{
		const _opaque_pthread_condattr_t& o = r.GetT<const _opaque_pthread_condattr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_condattr_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_condattr_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_condattr_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_condattr_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_condattr_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_condattr_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_condattr_t_name = "_opaque_pthread_condattr_t";

const std::string& Class<_opaque_pthread_condattr_t>::GetName() const
{
	return _opaque_pthread_condattr_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_condattr_t.
	struct _opaque_pthread_condattr_t_registrar
	{
		_opaque_pthread_condattr_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_condattr_t>>());
		}
	} _opaque_pthread_condattr_t_instance;
}


const int Class<_opaque_pthread_mutex_t>::FieldCount;
const int Class<_opaque_pthread_mutex_t>::StaticFieldCount;
const int Class<_opaque_pthread_mutex_t>::MethodCount;
const int Class<_opaque_pthread_mutex_t>::StaticMethodCount;

int Class<_opaque_pthread_mutex_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_mutex_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_mutex_t>())
	{
		_opaque_pthread_mutex_t& o = r.GetT<_opaque_pthread_mutex_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_mutex_t>())
	{
		const _opaque_pthread_mutex_t& o = r.GetT<const _opaque_pthread_mutex_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_mutex_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_mutex_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_mutex_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_mutex_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_mutex_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_mutex_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_mutex_t_name = "_opaque_pthread_mutex_t";

const std::string& Class<_opaque_pthread_mutex_t>::GetName() const
{
	return _opaque_pthread_mutex_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_mutex_t.
	struct _opaque_pthread_mutex_t_registrar
	{
		_opaque_pthread_mutex_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_mutex_t>>());
		}
	} _opaque_pthread_mutex_t_instance;
}


const int Class<_opaque_pthread_mutexattr_t>::FieldCount;
const int Class<_opaque_pthread_mutexattr_t>::StaticFieldCount;
const int Class<_opaque_pthread_mutexattr_t>::MethodCount;
const int Class<_opaque_pthread_mutexattr_t>::StaticMethodCount;

int Class<_opaque_pthread_mutexattr_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_mutexattr_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_mutexattr_t>())
	{
		_opaque_pthread_mutexattr_t& o = r.GetT<_opaque_pthread_mutexattr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_mutexattr_t>())
	{
		const _opaque_pthread_mutexattr_t& o = r.GetT<const _opaque_pthread_mutexattr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_mutexattr_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_mutexattr_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_mutexattr_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_mutexattr_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_mutexattr_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_mutexattr_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_mutexattr_t_name = "_opaque_pthread_mutexattr_t";

const std::string& Class<_opaque_pthread_mutexattr_t>::GetName() const
{
	return _opaque_pthread_mutexattr_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_mutexattr_t.
	struct _opaque_pthread_mutexattr_t_registrar
	{
		_opaque_pthread_mutexattr_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_mutexattr_t>>());
		}
	} _opaque_pthread_mutexattr_t_instance;
}


const int Class<_opaque_pthread_once_t>::FieldCount;
const int Class<_opaque_pthread_once_t>::StaticFieldCount;
const int Class<_opaque_pthread_once_t>::MethodCount;
const int Class<_opaque_pthread_once_t>::StaticMethodCount;

int Class<_opaque_pthread_once_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_once_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_once_t>())
	{
		_opaque_pthread_once_t& o = r.GetT<_opaque_pthread_once_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_once_t>())
	{
		const _opaque_pthread_once_t& o = r.GetT<const _opaque_pthread_once_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_once_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_once_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_once_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_once_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_once_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_once_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_once_t_name = "_opaque_pthread_once_t";

const std::string& Class<_opaque_pthread_once_t>::GetName() const
{
	return _opaque_pthread_once_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_once_t.
	struct _opaque_pthread_once_t_registrar
	{
		_opaque_pthread_once_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_once_t>>());
		}
	} _opaque_pthread_once_t_instance;
}


const int Class<_opaque_pthread_rwlock_t>::FieldCount;
const int Class<_opaque_pthread_rwlock_t>::StaticFieldCount;
const int Class<_opaque_pthread_rwlock_t>::MethodCount;
const int Class<_opaque_pthread_rwlock_t>::StaticMethodCount;

int Class<_opaque_pthread_rwlock_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_rwlock_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_rwlock_t>())
	{
		_opaque_pthread_rwlock_t& o = r.GetT<_opaque_pthread_rwlock_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_rwlock_t>())
	{
		const _opaque_pthread_rwlock_t& o = r.GetT<const _opaque_pthread_rwlock_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_rwlock_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_rwlock_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_rwlock_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_rwlock_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_rwlock_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_rwlock_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_rwlock_t_name = "_opaque_pthread_rwlock_t";

const std::string& Class<_opaque_pthread_rwlock_t>::GetName() const
{
	return _opaque_pthread_rwlock_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_rwlock_t.
	struct _opaque_pthread_rwlock_t_registrar
	{
		_opaque_pthread_rwlock_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_rwlock_t>>());
		}
	} _opaque_pthread_rwlock_t_instance;
}


const int Class<_opaque_pthread_rwlockattr_t>::FieldCount;
const int Class<_opaque_pthread_rwlockattr_t>::StaticFieldCount;
const int Class<_opaque_pthread_rwlockattr_t>::MethodCount;
const int Class<_opaque_pthread_rwlockattr_t>::StaticMethodCount;

int Class<_opaque_pthread_rwlockattr_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_rwlockattr_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_rwlockattr_t>())
	{
		_opaque_pthread_rwlockattr_t& o = r.GetT<_opaque_pthread_rwlockattr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_rwlockattr_t>())
	{
		const _opaque_pthread_rwlockattr_t& o = r.GetT<const _opaque_pthread_rwlockattr_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_rwlockattr_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_rwlockattr_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_rwlockattr_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_rwlockattr_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_rwlockattr_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_rwlockattr_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_rwlockattr_t_name = "_opaque_pthread_rwlockattr_t";

const std::string& Class<_opaque_pthread_rwlockattr_t>::GetName() const
{
	return _opaque_pthread_rwlockattr_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_rwlockattr_t.
	struct _opaque_pthread_rwlockattr_t_registrar
	{
		_opaque_pthread_rwlockattr_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_rwlockattr_t>>());
		}
	} _opaque_pthread_rwlockattr_t_instance;
}


const int Class<_opaque_pthread_t>::FieldCount;
const int Class<_opaque_pthread_t>::StaticFieldCount;
const int Class<_opaque_pthread_t>::MethodCount;
const int Class<_opaque_pthread_t>::StaticMethodCount;

int Class<_opaque_pthread_t>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<_opaque_pthread_t>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<_opaque_pthread_t>())
	{
		_opaque_pthread_t& o = r.GetT<_opaque_pthread_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__cleanup_stack")
		{
			return Reference(o.__cleanup_stack);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else if (r.IsT<const _opaque_pthread_t>())
	{
		const _opaque_pthread_t& o = r.GetT<const _opaque_pthread_t>();
		if (name == "__sig")
		{
			return Reference(o.__sig);
		}
		if (name == "__cleanup_stack")
		{
			return Reference(o.__cleanup_stack);
		}
		if (name == "__opaque")
		{
			return Reference(o.__opaque);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<_opaque_pthread_t>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<_opaque_pthread_t>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<_opaque_pthread_t>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<_opaque_pthread_t>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<_opaque_pthread_t>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<_opaque_pthread_t>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string _opaque_pthread_t_name = "_opaque_pthread_t";

const std::string& Class<_opaque_pthread_t>::GetName() const
{
	return _opaque_pthread_t_name;
}



namespace
{
	// Object to auto-register _opaque_pthread_t.
	struct _opaque_pthread_t_registrar
	{
		_opaque_pthread_t_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<_opaque_pthread_t>>());
		}
	} _opaque_pthread_t_instance;
}


int Function<void *(*)(const void *, int, size_t), ::memchr>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void *(*)(const void *, int, size_t), ::memchr>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(const void *, int, size_t), ::memchr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__c";
		result.type = "int";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memchr_name = "::memchr";

const std::string& Function<void *(*)(const void *, int, size_t), ::memchr>::GetName() const
{
	return __memchr_name;
}

Object Function<void *(*)(const void *, int, size_t), ::memchr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memchr(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memchr.
	struct __memchr_registrar
	{
		__memchr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(const void *, int, size_t), ::memchr>>());
		}
	} __memchr_instance;
}



int Function<int(*)(const void *, const void *, size_t), ::memcmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const void *, const void *, size_t), ::memcmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const void *, const void *, size_t), ::memcmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memcmp_name = "::memcmp";

const std::string& Function<int(*)(const void *, const void *, size_t), ::memcmp>::GetName() const
{
	return __memcmp_name;
}

Object Function<int(*)(const void *, const void *, size_t), ::memcmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memcmp(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memcmp.
	struct __memcmp_registrar
	{
		__memcmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const void *, const void *, size_t), ::memcmp>>());
		}
	} __memcmp_instance;
}



int Function<void *(*)(void *, const void *, size_t), ::memcpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void *(*)(void *, const void *, size_t), ::memcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(void *, const void *, size_t), ::memcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "void *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memcpy_name = "::memcpy";

const std::string& Function<void *(*)(void *, const void *, size_t), ::memcpy>::GetName() const
{
	return __memcpy_name;
}

Object Function<void *(*)(void *, const void *, size_t), ::memcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memcpy(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memcpy.
	struct __memcpy_registrar
	{
		__memcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(void *, const void *, size_t), ::memcpy>>());
		}
	} __memcpy_instance;
}



int Function<void *(*)(void *, const void *, size_t), ::memmove>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void *(*)(void *, const void *, size_t), ::memmove>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(void *, const void *, size_t), ::memmove>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "void *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memmove_name = "::memmove";

const std::string& Function<void *(*)(void *, const void *, size_t), ::memmove>::GetName() const
{
	return __memmove_name;
}

Object Function<void *(*)(void *, const void *, size_t), ::memmove>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memmove(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memmove.
	struct __memmove_registrar
	{
		__memmove_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(void *, const void *, size_t), ::memmove>>());
		}
	} __memmove_instance;
}



int Function<void *(*)(void *, int, size_t), ::memset>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void *(*)(void *, int, size_t), ::memset>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(void *, int, size_t), ::memset>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__b";
		result.type = "void *";
		break;
	case 1:
		result.name = "__c";
		result.type = "int";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memset_name = "::memset";

const std::string& Function<void *(*)(void *, int, size_t), ::memset>::GetName() const
{
	return __memset_name;
}

Object Function<void *(*)(void *, int, size_t), ::memset>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memset(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memset.
	struct __memset_registrar
	{
		__memset_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(void *, int, size_t), ::memset>>());
		}
	} __memset_instance;
}



int Function<char *(*)(char *, const char *), ::strcat>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(char *, const char *), ::strcat>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *), ::strcat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "char *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcat_name = "::strcat";

const std::string& Function<char *(*)(char *, const char *), ::strcat>::GetName() const
{
	return __strcat_name;
}

Object Function<char *(*)(char *, const char *), ::strcat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcat(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcat.
	struct __strcat_registrar
	{
		__strcat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *), ::strcat>>());
		}
	} __strcat_instance;
}



int Function<char *(*)(const char *, int), ::strchr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, int), ::strchr>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, int), ::strchr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strchr_name = "::strchr";

const std::string& Function<char *(*)(const char *, int), ::strchr>::GetName() const
{
	return __strchr_name;
}

Object Function<char *(*)(const char *, int), ::strchr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strchr(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strchr.
	struct __strchr_registrar
	{
		__strchr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, int), ::strchr>>());
		}
	} __strchr_instance;
}



int Function<int(*)(const char *, const char *), ::strcmp>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, const char *), ::strcmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *), ::strcmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcmp_name = "::strcmp";

const std::string& Function<int(*)(const char *, const char *), ::strcmp>::GetName() const
{
	return __strcmp_name;
}

Object Function<int(*)(const char *, const char *), ::strcmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcmp(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcmp.
	struct __strcmp_registrar
	{
		__strcmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *), ::strcmp>>());
		}
	} __strcmp_instance;
}



int Function<int(*)(const char *, const char *), ::strcoll>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, const char *), ::strcoll>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *), ::strcoll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcoll_name = "::strcoll";

const std::string& Function<int(*)(const char *, const char *), ::strcoll>::GetName() const
{
	return __strcoll_name;
}

Object Function<int(*)(const char *, const char *), ::strcoll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcoll(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcoll.
	struct __strcoll_registrar
	{
		__strcoll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *), ::strcoll>>());
		}
	} __strcoll_instance;
}



int Function<char *(*)(char *, const char *), ::strcpy>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(char *, const char *), ::strcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *), ::strcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "char *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcpy_name = "::strcpy";

const std::string& Function<char *(*)(char *, const char *), ::strcpy>::GetName() const
{
	return __strcpy_name;
}

Object Function<char *(*)(char *, const char *), ::strcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcpy(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcpy.
	struct __strcpy_registrar
	{
		__strcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *), ::strcpy>>());
		}
	} __strcpy_instance;
}



int Function<size_t(*)(const char *, const char *), ::strcspn>::GetParameterCount() const
{
	return 2;
}

Parameter Function<size_t(*)(const char *, const char *), ::strcspn>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const char *, const char *), ::strcspn>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__charset";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcspn_name = "::strcspn";

const std::string& Function<size_t(*)(const char *, const char *), ::strcspn>::GetName() const
{
	return __strcspn_name;
}

Object Function<size_t(*)(const char *, const char *), ::strcspn>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcspn(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcspn.
	struct __strcspn_registrar
	{
		__strcspn_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const char *, const char *), ::strcspn>>());
		}
	} __strcspn_instance;
}



int Function<char *(*)(int), ::strerror>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(int), ::strerror>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(int), ::strerror>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__errnum";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strerror_name = "::strerror";

const std::string& Function<char *(*)(int), ::strerror>::GetName() const
{
	return __strerror_name;
}

Object Function<char *(*)(int), ::strerror>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strerror(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strerror.
	struct __strerror_registrar
	{
		__strerror_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(int), ::strerror>>());
		}
	} __strerror_instance;
}



int Function<size_t(*)(const char *), ::strlen>::GetParameterCount() const
{
	return 1;
}

Parameter Function<size_t(*)(const char *), ::strlen>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const char *), ::strlen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strlen_name = "::strlen";

const std::string& Function<size_t(*)(const char *), ::strlen>::GetName() const
{
	return __strlen_name;
}

Object Function<size_t(*)(const char *), ::strlen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strlen(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strlen.
	struct __strlen_registrar
	{
		__strlen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const char *), ::strlen>>());
		}
	} __strlen_instance;
}



int Function<char *(*)(char *, const char *, size_t), ::strncat>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(char *, const char *, size_t), ::strncat>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *, size_t), ::strncat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "char *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strncat_name = "::strncat";

const std::string& Function<char *(*)(char *, const char *, size_t), ::strncat>::GetName() const
{
	return __strncat_name;
}

Object Function<char *(*)(char *, const char *, size_t), ::strncat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strncat(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strncat.
	struct __strncat_registrar
	{
		__strncat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *, size_t), ::strncat>>());
		}
	} __strncat_instance;
}



int Function<int(*)(const char *, const char *, size_t), ::strncmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const char *, const char *, size_t), ::strncmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *, size_t), ::strncmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strncmp_name = "::strncmp";

const std::string& Function<int(*)(const char *, const char *, size_t), ::strncmp>::GetName() const
{
	return __strncmp_name;
}

Object Function<int(*)(const char *, const char *, size_t), ::strncmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strncmp(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strncmp.
	struct __strncmp_registrar
	{
		__strncmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *, size_t), ::strncmp>>());
		}
	} __strncmp_instance;
}



int Function<char *(*)(char *, const char *, size_t), ::strncpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(char *, const char *, size_t), ::strncpy>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *, size_t), ::strncpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "char *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strncpy_name = "::strncpy";

const std::string& Function<char *(*)(char *, const char *, size_t), ::strncpy>::GetName() const
{
	return __strncpy_name;
}

Object Function<char *(*)(char *, const char *, size_t), ::strncpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strncpy(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strncpy.
	struct __strncpy_registrar
	{
		__strncpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *, size_t), ::strncpy>>());
		}
	} __strncpy_instance;
}



int Function<char *(*)(const char *, const char *), ::strpbrk>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, const char *), ::strpbrk>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, const char *), ::strpbrk>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__charset";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strpbrk_name = "::strpbrk";

const std::string& Function<char *(*)(const char *, const char *), ::strpbrk>::GetName() const
{
	return __strpbrk_name;
}

Object Function<char *(*)(const char *, const char *), ::strpbrk>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strpbrk(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strpbrk.
	struct __strpbrk_registrar
	{
		__strpbrk_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, const char *), ::strpbrk>>());
		}
	} __strpbrk_instance;
}



int Function<char *(*)(const char *, int), ::strrchr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, int), ::strrchr>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, int), ::strrchr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strrchr_name = "::strrchr";

const std::string& Function<char *(*)(const char *, int), ::strrchr>::GetName() const
{
	return __strrchr_name;
}

Object Function<char *(*)(const char *, int), ::strrchr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strrchr(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strrchr.
	struct __strrchr_registrar
	{
		__strrchr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, int), ::strrchr>>());
		}
	} __strrchr_instance;
}



int Function<size_t(*)(const char *, const char *), ::strspn>::GetParameterCount() const
{
	return 2;
}

Parameter Function<size_t(*)(const char *, const char *), ::strspn>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const char *, const char *), ::strspn>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__charset";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strspn_name = "::strspn";

const std::string& Function<size_t(*)(const char *, const char *), ::strspn>::GetName() const
{
	return __strspn_name;
}

Object Function<size_t(*)(const char *, const char *), ::strspn>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strspn(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strspn.
	struct __strspn_registrar
	{
		__strspn_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const char *, const char *), ::strspn>>());
		}
	} __strspn_instance;
}



int Function<char *(*)(const char *, const char *), ::strstr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, const char *), ::strstr>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, const char *), ::strstr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__big";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__little";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strstr_name = "::strstr";

const std::string& Function<char *(*)(const char *, const char *), ::strstr>::GetName() const
{
	return __strstr_name;
}

Object Function<char *(*)(const char *, const char *), ::strstr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strstr(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strstr.
	struct __strstr_registrar
	{
		__strstr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, const char *), ::strstr>>());
		}
	} __strstr_instance;
}



int Function<char *(*)(char *, const char *), ::strtok>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(char *, const char *), ::strtok>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *), ::strtok>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "char *";
		break;
	case 1:
		result.name = "__sep";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtok_name = "::strtok";

const std::string& Function<char *(*)(char *, const char *), ::strtok>::GetName() const
{
	return __strtok_name;
}

Object Function<char *(*)(char *, const char *), ::strtok>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtok(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strtok.
	struct __strtok_registrar
	{
		__strtok_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *), ::strtok>>());
		}
	} __strtok_instance;
}



int Function<size_t(*)(char *, const char *, size_t), ::strxfrm>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(char *, const char *, size_t), ::strxfrm>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, const char *, size_t), ::strxfrm>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "char *";
		break;
	case 1:
		result.name = "__s2";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strxfrm_name = "::strxfrm";

const std::string& Function<size_t(*)(char *, const char *, size_t), ::strxfrm>::GetName() const
{
	return __strxfrm_name;
}

Object Function<size_t(*)(char *, const char *, size_t), ::strxfrm>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strxfrm(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strxfrm.
	struct __strxfrm_registrar
	{
		__strxfrm_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, const char *, size_t), ::strxfrm>>());
		}
	} __strxfrm_instance;
}



int Function<char *(*)(char *, const char *, char **), ::strtok_r>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(char *, const char *, char **), ::strtok_r>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *, char **), ::strtok_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "char *";
		break;
	case 1:
		result.name = "__sep";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__lasts";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtok_r_name = "::strtok_r";

const std::string& Function<char *(*)(char *, const char *, char **), ::strtok_r>::GetName() const
{
	return __strtok_r_name;
}

Object Function<char *(*)(char *, const char *, char **), ::strtok_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtok_r(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::strtok_r.
	struct __strtok_r_registrar
	{
		__strtok_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *, char **), ::strtok_r>>());
		}
	} __strtok_r_instance;
}



int Function<int(*)(int, char *, size_t), ::strerror_r>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(int, char *, size_t), ::strerror_r>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, char *, size_t), ::strerror_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__errnum";
		result.type = "int";
		break;
	case 1:
		result.name = "__strerrbuf";
		result.type = "char *";
		break;
	case 2:
		result.name = "__buflen";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strerror_r_name = "::strerror_r";

const std::string& Function<int(*)(int, char *, size_t), ::strerror_r>::GetName() const
{
	return __strerror_r_name;
}

Object Function<int(*)(int, char *, size_t), ::strerror_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strerror_r(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strerror_r.
	struct __strerror_r_registrar
	{
		__strerror_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, char *, size_t), ::strerror_r>>());
		}
	} __strerror_r_instance;
}



int Function<char *(*)(const char *), ::strdup>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(const char *), ::strdup>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *), ::strdup>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strdup_name = "::strdup";

const std::string& Function<char *(*)(const char *), ::strdup>::GetName() const
{
	return __strdup_name;
}

Object Function<char *(*)(const char *), ::strdup>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strdup(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strdup.
	struct __strdup_registrar
	{
		__strdup_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *), ::strdup>>());
		}
	} __strdup_instance;
}



int Function<void *(*)(void *, const void *, int, size_t), ::memccpy>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void *(*)(void *, const void *, int, size_t), ::memccpy>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(void *, const void *, int, size_t), ::memccpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "void *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__c";
		result.type = "int";
		break;
	case 3:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memccpy_name = "::memccpy";

const std::string& Function<void *(*)(void *, const void *, int, size_t), ::memccpy>::GetName() const
{
	return __memccpy_name;
}

Object Function<void *(*)(void *, const void *, int, size_t), ::memccpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memccpy(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memccpy.
	struct __memccpy_registrar
	{
		__memccpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(void *, const void *, int, size_t), ::memccpy>>());
		}
	} __memccpy_instance;
}



int Function<char *(*)(char *, const char *), ::stpcpy>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(char *, const char *), ::stpcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *), ::stpcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "char *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __stpcpy_name = "::stpcpy";

const std::string& Function<char *(*)(char *, const char *), ::stpcpy>::GetName() const
{
	return __stpcpy_name;
}

Object Function<char *(*)(char *, const char *), ::stpcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::stpcpy(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::stpcpy.
	struct __stpcpy_registrar
	{
		__stpcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *), ::stpcpy>>());
		}
	} __stpcpy_instance;
}



int Function<char *(*)(char *, const char *, size_t), ::stpncpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(char *, const char *, size_t), ::stpncpy>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *, size_t), ::stpncpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "char *";
		break;
	case 1:
		result.name = "__src";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __stpncpy_name = "::stpncpy";

const std::string& Function<char *(*)(char *, const char *, size_t), ::stpncpy>::GetName() const
{
	return __stpncpy_name;
}

Object Function<char *(*)(char *, const char *, size_t), ::stpncpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::stpncpy(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::stpncpy.
	struct __stpncpy_registrar
	{
		__stpncpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *, size_t), ::stpncpy>>());
		}
	} __stpncpy_instance;
}



int Function<char *(*)(const char *, size_t), ::strndup>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, size_t), ::strndup>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, size_t), ::strndup>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strndup_name = "::strndup";

const std::string& Function<char *(*)(const char *, size_t), ::strndup>::GetName() const
{
	return __strndup_name;
}

Object Function<char *(*)(const char *, size_t), ::strndup>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strndup(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strndup.
	struct __strndup_registrar
	{
		__strndup_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, size_t), ::strndup>>());
		}
	} __strndup_instance;
}



int Function<size_t(*)(const char *, size_t), ::strnlen>::GetParameterCount() const
{
	return 2;
}

Parameter Function<size_t(*)(const char *, size_t), ::strnlen>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const char *, size_t), ::strnlen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s1";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strnlen_name = "::strnlen";

const std::string& Function<size_t(*)(const char *, size_t), ::strnlen>::GetName() const
{
	return __strnlen_name;
}

Object Function<size_t(*)(const char *, size_t), ::strnlen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strnlen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strnlen.
	struct __strnlen_registrar
	{
		__strnlen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const char *, size_t), ::strnlen>>());
		}
	} __strnlen_instance;
}



int Function<char *(*)(int), ::strsignal>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(int), ::strsignal>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(int), ::strsignal>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__sig";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strsignal_name = "::strsignal";

const std::string& Function<char *(*)(int), ::strsignal>::GetName() const
{
	return __strsignal_name;
}

Object Function<char *(*)(int), ::strsignal>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strsignal(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strsignal.
	struct __strsignal_registrar
	{
		__strsignal_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(int), ::strsignal>>());
		}
	} __strsignal_instance;
}



int Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s>::GetParameterCount() const
{
	return 4;
}

Parameter Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s>::GetReturnType() const
{
	Parameter result;
	result.type = "errno_t";
	return result;
}

Parameter Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "void *";
		break;
	case 1:
		result.name = "__smax";
		result.type = "rsize_t";
		break;
	case 2:
		result.name = "__c";
		result.type = "int";
		break;
	case 3:
		result.name = "__n";
		result.type = "rsize_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memset_s_name = "::memset_s";

const std::string& Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s>::GetName() const
{
	return __memset_s_name;
}

Object Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memset_s(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<rsize_t>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<rsize_t>>()));
}

namespace
{
	// Object to auto-register ::memset_s.
	struct __memset_s_registrar
	{
		__memset_s_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<errno_t(*)(void *, rsize_t, int, rsize_t), ::memset_s>>());
		}
	} __memset_s_instance;
}



int Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__big";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__big_len";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__little";
		result.type = "const void *";
		break;
	case 3:
		result.name = "__little_len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memmem_name = "::memmem";

const std::string& Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem>::GetName() const
{
	return __memmem_name;
}

Object Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::memmem(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const void *>>(), args[3].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::memmem.
	struct __memmem_registrar
	{
		__memmem_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(const void *, size_t, const void *, size_t), ::memmem>>());
		}
	} __memmem_instance;
}



int Function<void(*)(void *, const void *, size_t), ::memset_pattern4>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void(*)(void *, const void *, size_t), ::memset_pattern4>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, const void *, size_t), ::memset_pattern4>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__b";
		result.type = "void *";
		break;
	case 1:
		result.name = "__pattern4";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memset_pattern4_name = "::memset_pattern4";

const std::string& Function<void(*)(void *, const void *, size_t), ::memset_pattern4>::GetName() const
{
	return __memset_pattern4_name;
}

Object Function<void(*)(void *, const void *, size_t), ::memset_pattern4>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::memset_pattern4(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::memset_pattern4.
	struct __memset_pattern4_registrar
	{
		__memset_pattern4_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, const void *, size_t), ::memset_pattern4>>());
		}
	} __memset_pattern4_instance;
}



int Function<void(*)(void *, const void *, size_t), ::memset_pattern8>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void(*)(void *, const void *, size_t), ::memset_pattern8>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, const void *, size_t), ::memset_pattern8>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__b";
		result.type = "void *";
		break;
	case 1:
		result.name = "__pattern8";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memset_pattern8_name = "::memset_pattern8";

const std::string& Function<void(*)(void *, const void *, size_t), ::memset_pattern8>::GetName() const
{
	return __memset_pattern8_name;
}

Object Function<void(*)(void *, const void *, size_t), ::memset_pattern8>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::memset_pattern8(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::memset_pattern8.
	struct __memset_pattern8_registrar
	{
		__memset_pattern8_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, const void *, size_t), ::memset_pattern8>>());
		}
	} __memset_pattern8_instance;
}



int Function<void(*)(void *, const void *, size_t), ::memset_pattern16>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void(*)(void *, const void *, size_t), ::memset_pattern16>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, const void *, size_t), ::memset_pattern16>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__b";
		result.type = "void *";
		break;
	case 1:
		result.name = "__pattern16";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __memset_pattern16_name = "::memset_pattern16";

const std::string& Function<void(*)(void *, const void *, size_t), ::memset_pattern16>::GetName() const
{
	return __memset_pattern16_name;
}

Object Function<void(*)(void *, const void *, size_t), ::memset_pattern16>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::memset_pattern16(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::memset_pattern16.
	struct __memset_pattern16_registrar
	{
		__memset_pattern16_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, const void *, size_t), ::memset_pattern16>>());
		}
	} __memset_pattern16_instance;
}



int Function<char *(*)(const char *, const char *), ::strcasestr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, const char *), ::strcasestr>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, const char *), ::strcasestr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__big";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__little";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcasestr_name = "::strcasestr";

const std::string& Function<char *(*)(const char *, const char *), ::strcasestr>::GetName() const
{
	return __strcasestr_name;
}

Object Function<char *(*)(const char *, const char *), ::strcasestr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcasestr(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcasestr.
	struct __strcasestr_registrar
	{
		__strcasestr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, const char *), ::strcasestr>>());
		}
	} __strcasestr_instance;
}



int Function<char *(*)(const char *, const char *, size_t), ::strnstr>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(const char *, const char *, size_t), ::strnstr>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, const char *, size_t), ::strnstr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__big";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__little";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strnstr_name = "::strnstr";

const std::string& Function<char *(*)(const char *, const char *, size_t), ::strnstr>::GetName() const
{
	return __strnstr_name;
}

Object Function<char *(*)(const char *, const char *, size_t), ::strnstr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strnstr(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strnstr.
	struct __strnstr_registrar
	{
		__strnstr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, const char *, size_t), ::strnstr>>());
		}
	} __strnstr_instance;
}



int Function<size_t(*)(char *, const char *, size_t), ::strlcat>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(char *, const char *, size_t), ::strlcat>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, const char *, size_t), ::strlcat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "char *";
		break;
	case 1:
		result.name = "__source";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strlcat_name = "::strlcat";

const std::string& Function<size_t(*)(char *, const char *, size_t), ::strlcat>::GetName() const
{
	return __strlcat_name;
}

Object Function<size_t(*)(char *, const char *, size_t), ::strlcat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strlcat(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strlcat.
	struct __strlcat_registrar
	{
		__strlcat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, const char *, size_t), ::strlcat>>());
		}
	} __strlcat_instance;
}



int Function<size_t(*)(char *, const char *, size_t), ::strlcpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(char *, const char *, size_t), ::strlcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, const char *, size_t), ::strlcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dst";
		result.type = "char *";
		break;
	case 1:
		result.name = "__source";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strlcpy_name = "::strlcpy";

const std::string& Function<size_t(*)(char *, const char *, size_t), ::strlcpy>::GetName() const
{
	return __strlcpy_name;
}

Object Function<size_t(*)(char *, const char *, size_t), ::strlcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strlcpy(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strlcpy.
	struct __strlcpy_registrar
	{
		__strlcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, const char *, size_t), ::strlcpy>>());
		}
	} __strlcpy_instance;
}



int Function<void(*)(int, char *), ::strmode>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(int, char *), ::strmode>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(int, char *), ::strmode>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__mode";
		result.type = "int";
		break;
	case 1:
		result.name = "__bp";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strmode_name = "::strmode";

const std::string& Function<void(*)(int, char *), ::strmode>::GetName() const
{
	return __strmode_name;
}

Object Function<void(*)(int, char *), ::strmode>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::strmode(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::strmode.
	struct __strmode_registrar
	{
		__strmode_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(int, char *), ::strmode>>());
		}
	} __strmode_instance;
}



int Function<char *(*)(char **, const char *), ::strsep>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(char **, const char *), ::strsep>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char **, const char *), ::strsep>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__stringp";
		result.type = "char **";
		break;
	case 1:
		result.name = "__delim";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strsep_name = "::strsep";

const std::string& Function<char *(*)(char **, const char *), ::strsep>::GetName() const
{
	return __strsep_name;
}

Object Function<char *(*)(char **, const char *), ::strsep>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strsep(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strsep.
	struct __strsep_registrar
	{
		__strsep_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char **, const char *), ::strsep>>());
		}
	} __strsep_instance;
}



int Function<void(*)(const void *, void *, ssize_t), ::swab>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void(*)(const void *, void *, ssize_t), ::swab>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(const void *, void *, ssize_t), ::swab>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "void *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "ssize_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __swab_name = "::swab";

const std::string& Function<void(*)(const void *, void *, ssize_t), ::swab>::GetName() const
{
	return __swab_name;
}

Object Function<void(*)(const void *, void *, ssize_t), ::swab>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::swab(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<void *>>(), args[2].GetT<std::decay_t<ssize_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::swab.
	struct __swab_registrar
	{
		__swab_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(const void *, void *, ssize_t), ::swab>>());
		}
	} __swab_instance;
}



int Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__b1";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__b2";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__len";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __timingsafe_bcmp_name = "::timingsafe_bcmp";

const std::string& Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp>::GetName() const
{
	return __timingsafe_bcmp_name;
}

Object Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::timingsafe_bcmp(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::timingsafe_bcmp.
	struct __timingsafe_bcmp_registrar
	{
		__timingsafe_bcmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const void *, const void *, size_t), ::timingsafe_bcmp>>());
		}
	} __timingsafe_bcmp_instance;
}



int Function<int(*)(const void *, const void *, size_t), ::bcmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const void *, const void *, size_t), ::bcmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const void *, const void *, size_t), ::bcmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const void *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __bcmp_name = "::bcmp";

const std::string& Function<int(*)(const void *, const void *, size_t), ::bcmp>::GetName() const
{
	return __bcmp_name;
}

Object Function<int(*)(const void *, const void *, size_t), ::bcmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::bcmp(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::bcmp.
	struct __bcmp_registrar
	{
		__bcmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const void *, const void *, size_t), ::bcmp>>());
		}
	} __bcmp_instance;
}



int Function<void(*)(const void *, void *, size_t), ::bcopy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void(*)(const void *, void *, size_t), ::bcopy>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(const void *, void *, size_t), ::bcopy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "void *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __bcopy_name = "::bcopy";

const std::string& Function<void(*)(const void *, void *, size_t), ::bcopy>::GetName() const
{
	return __bcopy_name;
}

Object Function<void(*)(const void *, void *, size_t), ::bcopy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::bcopy(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<void *>>(), args[2].GetT<std::decay_t<size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::bcopy.
	struct __bcopy_registrar
	{
		__bcopy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(const void *, void *, size_t), ::bcopy>>());
		}
	} __bcopy_instance;
}



int Function<void(*)(void *, size_t), ::bzero>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(void *, size_t), ::bzero>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t), ::bzero>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __bzero_name = "::bzero";

const std::string& Function<void(*)(void *, size_t), ::bzero>::GetName() const
{
	return __bzero_name;
}

Object Function<void(*)(void *, size_t), ::bzero>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::bzero(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::bzero.
	struct __bzero_registrar
	{
		__bzero_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t), ::bzero>>());
		}
	} __bzero_instance;
}



int Function<char *(*)(const char *, int), ::index>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, int), ::index>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, int), ::index>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __index_name = "::index";

const std::string& Function<char *(*)(const char *, int), ::index>::GetName() const
{
	return __index_name;
}

Object Function<char *(*)(const char *, int), ::index>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::index(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::index.
	struct __index_registrar
	{
		__index_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, int), ::index>>());
		}
	} __index_instance;
}



int Function<char *(*)(const char *, int), ::rindex>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, int), ::rindex>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, int), ::rindex>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __rindex_name = "::rindex";

const std::string& Function<char *(*)(const char *, int), ::rindex>::GetName() const
{
	return __rindex_name;
}

Object Function<char *(*)(const char *, int), ::rindex>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::rindex(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::rindex.
	struct __rindex_registrar
	{
		__rindex_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, int), ::rindex>>());
		}
	} __rindex_instance;
}



int Function<int(*)(int), ::ffs>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::ffs>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::ffs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ffs_name = "::ffs";

const std::string& Function<int(*)(int), ::ffs>::GetName() const
{
	return __ffs_name;
}

Object Function<int(*)(int), ::ffs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ffs(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::ffs.
	struct __ffs_registrar
	{
		__ffs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::ffs>>());
		}
	} __ffs_instance;
}



int Function<int(*)(const char *, const char *), ::strcasecmp>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, const char *), ::strcasecmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *), ::strcasecmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strcasecmp_name = "::strcasecmp";

const std::string& Function<int(*)(const char *, const char *), ::strcasecmp>::GetName() const
{
	return __strcasecmp_name;
}

Object Function<int(*)(const char *, const char *), ::strcasecmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strcasecmp(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::strcasecmp.
	struct __strcasecmp_registrar
	{
		__strcasecmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *), ::strcasecmp>>());
		}
	} __strcasecmp_instance;
}



int Function<int(*)(const char *, const char *, size_t), ::strncasecmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const char *, const char *, size_t), ::strncasecmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *, size_t), ::strncasecmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strncasecmp_name = "::strncasecmp";

const std::string& Function<int(*)(const char *, const char *, size_t), ::strncasecmp>::GetName() const
{
	return __strncasecmp_name;
}

Object Function<int(*)(const char *, const char *, size_t), ::strncasecmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strncasecmp(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::strncasecmp.
	struct __strncasecmp_registrar
	{
		__strncasecmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *, size_t), ::strncasecmp>>());
		}
	} __strncasecmp_instance;
}



int Function<int(*)(long), ::ffsl>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(long), ::ffsl>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(long), ::ffsl>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ffsl_name = "::ffsl";

const std::string& Function<int(*)(long), ::ffsl>::GetName() const
{
	return __ffsl_name;
}

Object Function<int(*)(long), ::ffsl>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ffsl(args[0].GetT<std::decay_t<long>>()));
}

namespace
{
	// Object to auto-register ::ffsl.
	struct __ffsl_registrar
	{
		__ffsl_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(long), ::ffsl>>());
		}
	} __ffsl_instance;
}



int Function<int(*)(long long), ::ffsll>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(long long), ::ffsll>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(long long), ::ffsll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ffsll_name = "::ffsll";

const std::string& Function<int(*)(long long), ::ffsll>::GetName() const
{
	return __ffsll_name;
}

Object Function<int(*)(long long), ::ffsll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ffsll(args[0].GetT<std::decay_t<long long>>()));
}

namespace
{
	// Object to auto-register ::ffsll.
	struct __ffsll_registrar
	{
		__ffsll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(long long), ::ffsll>>());
		}
	} __ffsll_instance;
}



int Function<int(*)(int), ::fls>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::fls>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::fls>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fls_name = "::fls";

const std::string& Function<int(*)(int), ::fls>::GetName() const
{
	return __fls_name;
}

Object Function<int(*)(int), ::fls>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fls(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::fls.
	struct __fls_registrar
	{
		__fls_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::fls>>());
		}
	} __fls_instance;
}



int Function<int(*)(long), ::flsl>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(long), ::flsl>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(long), ::flsl>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __flsl_name = "::flsl";

const std::string& Function<int(*)(long), ::flsl>::GetName() const
{
	return __flsl_name;
}

Object Function<int(*)(long), ::flsl>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::flsl(args[0].GetT<std::decay_t<long>>()));
}

namespace
{
	// Object to auto-register ::flsl.
	struct __flsl_registrar
	{
		__flsl_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(long), ::flsl>>());
		}
	} __flsl_instance;
}



int Function<int(*)(long long), ::flsll>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(long long), ::flsll>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(long long), ::flsll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __flsll_name = "::flsll";

const std::string& Function<int(*)(long long), ::flsll>::GetName() const
{
	return __flsll_name;
}

Object Function<int(*)(long long), ::flsll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::flsll(args[0].GetT<std::decay_t<long long>>()));
}

namespace
{
	// Object to auto-register ::flsll.
	struct __flsll_registrar
	{
		__flsll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(long long), ::flsll>>());
		}
	} __flsll_instance;
}



const int Class<__libcpp_debug_exception>::FieldCount;
const int Class<__libcpp_debug_exception>::StaticFieldCount;
const int Class<__libcpp_debug_exception>::MethodCount;
const int Class<__libcpp_debug_exception>::StaticMethodCount;

int Class<__libcpp_debug_exception>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__libcpp_debug_exception>::GetField(const Reference& r, const std::string& name) const
{
	throw Exception("Invalid name passed to GetField().");
}

int Class<__libcpp_debug_exception>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__libcpp_debug_exception>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__libcpp_debug_exception>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__libcpp_debug_exception>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__libcpp_debug_exception>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__libcpp_debug_exception>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __libcpp_debug_exception_name = "__libcpp_debug_exception";

const std::string& Class<__libcpp_debug_exception>::GetName() const
{
	return __libcpp_debug_exception_name;
}



namespace
{
	// Object to auto-register __libcpp_debug_exception.
	struct __libcpp_debug_exception_registrar
	{
		__libcpp_debug_exception_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__libcpp_debug_exception>>());
		}
	} __libcpp_debug_exception_instance;
}


const int Class<__darwin_i386_thread_state>::FieldCount;
const int Class<__darwin_i386_thread_state>::StaticFieldCount;
const int Class<__darwin_i386_thread_state>::MethodCount;
const int Class<__darwin_i386_thread_state>::StaticMethodCount;

int Class<__darwin_i386_thread_state>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_i386_thread_state>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_i386_thread_state>())
	{
		__darwin_i386_thread_state& o = r.GetT<__darwin_i386_thread_state>();
		if (name == "__eax")
		{
			return Reference(o.__eax);
		}
		if (name == "__ebx")
		{
			return Reference(o.__ebx);
		}
		if (name == "__ecx")
		{
			return Reference(o.__ecx);
		}
		if (name == "__edx")
		{
			return Reference(o.__edx);
		}
		if (name == "__edi")
		{
			return Reference(o.__edi);
		}
		if (name == "__esi")
		{
			return Reference(o.__esi);
		}
		if (name == "__ebp")
		{
			return Reference(o.__ebp);
		}
		if (name == "__esp")
		{
			return Reference(o.__esp);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__eflags")
		{
			return Reference(o.__eflags);
		}
		if (name == "__eip")
		{
			return Reference(o.__eip);
		}
		if (name == "__cs")
		{
			return Reference(o.__cs);
		}
		if (name == "__ds")
		{
			return Reference(o.__ds);
		}
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
		if (name == "__gs")
		{
			return Reference(o.__gs);
		}
	}
	else if (r.IsT<const __darwin_i386_thread_state>())
	{
		const __darwin_i386_thread_state& o = r.GetT<const __darwin_i386_thread_state>();
		if (name == "__eax")
		{
			return Reference(o.__eax);
		}
		if (name == "__ebx")
		{
			return Reference(o.__ebx);
		}
		if (name == "__ecx")
		{
			return Reference(o.__ecx);
		}
		if (name == "__edx")
		{
			return Reference(o.__edx);
		}
		if (name == "__edi")
		{
			return Reference(o.__edi);
		}
		if (name == "__esi")
		{
			return Reference(o.__esi);
		}
		if (name == "__ebp")
		{
			return Reference(o.__ebp);
		}
		if (name == "__esp")
		{
			return Reference(o.__esp);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__eflags")
		{
			return Reference(o.__eflags);
		}
		if (name == "__eip")
		{
			return Reference(o.__eip);
		}
		if (name == "__cs")
		{
			return Reference(o.__cs);
		}
		if (name == "__ds")
		{
			return Reference(o.__ds);
		}
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
		if (name == "__gs")
		{
			return Reference(o.__gs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_i386_thread_state>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_i386_thread_state>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_i386_thread_state>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_i386_thread_state>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_i386_thread_state>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_i386_thread_state>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_i386_thread_state_name = "__darwin_i386_thread_state";

const std::string& Class<__darwin_i386_thread_state>::GetName() const
{
	return __darwin_i386_thread_state_name;
}



namespace
{
	// Object to auto-register __darwin_i386_thread_state.
	struct __darwin_i386_thread_state_registrar
	{
		__darwin_i386_thread_state_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_i386_thread_state>>());
		}
	} __darwin_i386_thread_state_instance;
}


const int Class<__darwin_fp_control>::FieldCount;
const int Class<__darwin_fp_control>::StaticFieldCount;
const int Class<__darwin_fp_control>::MethodCount;
const int Class<__darwin_fp_control>::StaticMethodCount;

int Class<__darwin_fp_control>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_fp_control>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_fp_control>())
	{
		__darwin_fp_control& o = r.GetT<__darwin_fp_control>();
		if (name == "__invalid")
		{
			return Reference(o.__invalid);
		}
		if (name == "__denorm")
		{
			return Reference(o.__denorm);
		}
		if (name == "__zdiv")
		{
			return Reference(o.__zdiv);
		}
		if (name == "__ovrfl")
		{
			return Reference(o.__ovrfl);
		}
		if (name == "__undfl")
		{
			return Reference(o.__undfl);
		}
		if (name == "__precis")
		{
			return Reference(o.__precis);
		}
		if (name == "")
		{
			return Reference(o.);
		}
		if (name == "__pc")
		{
			return Reference(o.__pc);
		}
		if (name == "__rc")
		{
			return Reference(o.__rc);
		}
		if (name == "")
		{
			return Reference(o.);
		}
		if (name == "")
		{
			return Reference(o.);
		}
	}
	else if (r.IsT<const __darwin_fp_control>())
	{
		const __darwin_fp_control& o = r.GetT<const __darwin_fp_control>();
		if (name == "__invalid")
		{
			return Reference(o.__invalid);
		}
		if (name == "__denorm")
		{
			return Reference(o.__denorm);
		}
		if (name == "__zdiv")
		{
			return Reference(o.__zdiv);
		}
		if (name == "__ovrfl")
		{
			return Reference(o.__ovrfl);
		}
		if (name == "__undfl")
		{
			return Reference(o.__undfl);
		}
		if (name == "__precis")
		{
			return Reference(o.__precis);
		}
		if (name == "")
		{
			return Reference(o.);
		}
		if (name == "__pc")
		{
			return Reference(o.__pc);
		}
		if (name == "__rc")
		{
			return Reference(o.__rc);
		}
		if (name == "")
		{
			return Reference(o.);
		}
		if (name == "")
		{
			return Reference(o.);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_fp_control>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_fp_control>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_fp_control>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_fp_control>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_fp_control>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_fp_control>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_fp_control_name = "__darwin_fp_control";

const std::string& Class<__darwin_fp_control>::GetName() const
{
	return __darwin_fp_control_name;
}



namespace
{
	// Object to auto-register __darwin_fp_control.
	struct __darwin_fp_control_registrar
	{
		__darwin_fp_control_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_fp_control>>());
		}
	} __darwin_fp_control_instance;
}


const int Class<__darwin_fp_status>::FieldCount;
const int Class<__darwin_fp_status>::StaticFieldCount;
const int Class<__darwin_fp_status>::MethodCount;
const int Class<__darwin_fp_status>::StaticMethodCount;

int Class<__darwin_fp_status>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_fp_status>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_fp_status>())
	{
		__darwin_fp_status& o = r.GetT<__darwin_fp_status>();
		if (name == "__invalid")
		{
			return Reference(o.__invalid);
		}
		if (name == "__denorm")
		{
			return Reference(o.__denorm);
		}
		if (name == "__zdiv")
		{
			return Reference(o.__zdiv);
		}
		if (name == "__ovrfl")
		{
			return Reference(o.__ovrfl);
		}
		if (name == "__undfl")
		{
			return Reference(o.__undfl);
		}
		if (name == "__precis")
		{
			return Reference(o.__precis);
		}
		if (name == "__stkflt")
		{
			return Reference(o.__stkflt);
		}
		if (name == "__errsumm")
		{
			return Reference(o.__errsumm);
		}
		if (name == "__c0")
		{
			return Reference(o.__c0);
		}
		if (name == "__c1")
		{
			return Reference(o.__c1);
		}
		if (name == "__c2")
		{
			return Reference(o.__c2);
		}
		if (name == "__tos")
		{
			return Reference(o.__tos);
		}
		if (name == "__c3")
		{
			return Reference(o.__c3);
		}
		if (name == "__busy")
		{
			return Reference(o.__busy);
		}
	}
	else if (r.IsT<const __darwin_fp_status>())
	{
		const __darwin_fp_status& o = r.GetT<const __darwin_fp_status>();
		if (name == "__invalid")
		{
			return Reference(o.__invalid);
		}
		if (name == "__denorm")
		{
			return Reference(o.__denorm);
		}
		if (name == "__zdiv")
		{
			return Reference(o.__zdiv);
		}
		if (name == "__ovrfl")
		{
			return Reference(o.__ovrfl);
		}
		if (name == "__undfl")
		{
			return Reference(o.__undfl);
		}
		if (name == "__precis")
		{
			return Reference(o.__precis);
		}
		if (name == "__stkflt")
		{
			return Reference(o.__stkflt);
		}
		if (name == "__errsumm")
		{
			return Reference(o.__errsumm);
		}
		if (name == "__c0")
		{
			return Reference(o.__c0);
		}
		if (name == "__c1")
		{
			return Reference(o.__c1);
		}
		if (name == "__c2")
		{
			return Reference(o.__c2);
		}
		if (name == "__tos")
		{
			return Reference(o.__tos);
		}
		if (name == "__c3")
		{
			return Reference(o.__c3);
		}
		if (name == "__busy")
		{
			return Reference(o.__busy);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_fp_status>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_fp_status>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_fp_status>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_fp_status>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_fp_status>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_fp_status>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_fp_status_name = "__darwin_fp_status";

const std::string& Class<__darwin_fp_status>::GetName() const
{
	return __darwin_fp_status_name;
}



namespace
{
	// Object to auto-register __darwin_fp_status.
	struct __darwin_fp_status_registrar
	{
		__darwin_fp_status_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_fp_status>>());
		}
	} __darwin_fp_status_instance;
}


const int Class<__darwin_mmst_reg>::FieldCount;
const int Class<__darwin_mmst_reg>::StaticFieldCount;
const int Class<__darwin_mmst_reg>::MethodCount;
const int Class<__darwin_mmst_reg>::StaticMethodCount;

int Class<__darwin_mmst_reg>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mmst_reg>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mmst_reg>())
	{
		__darwin_mmst_reg& o = r.GetT<__darwin_mmst_reg>();
		if (name == "__mmst_reg")
		{
			return Reference(o.__mmst_reg);
		}
		if (name == "__mmst_rsrv")
		{
			return Reference(o.__mmst_rsrv);
		}
	}
	else if (r.IsT<const __darwin_mmst_reg>())
	{
		const __darwin_mmst_reg& o = r.GetT<const __darwin_mmst_reg>();
		if (name == "__mmst_reg")
		{
			return Reference(o.__mmst_reg);
		}
		if (name == "__mmst_rsrv")
		{
			return Reference(o.__mmst_rsrv);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mmst_reg>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mmst_reg>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mmst_reg>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mmst_reg>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mmst_reg>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mmst_reg>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mmst_reg_name = "__darwin_mmst_reg";

const std::string& Class<__darwin_mmst_reg>::GetName() const
{
	return __darwin_mmst_reg_name;
}



namespace
{
	// Object to auto-register __darwin_mmst_reg.
	struct __darwin_mmst_reg_registrar
	{
		__darwin_mmst_reg_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mmst_reg>>());
		}
	} __darwin_mmst_reg_instance;
}


const int Class<__darwin_xmm_reg>::FieldCount;
const int Class<__darwin_xmm_reg>::StaticFieldCount;
const int Class<__darwin_xmm_reg>::MethodCount;
const int Class<__darwin_xmm_reg>::StaticMethodCount;

int Class<__darwin_xmm_reg>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_xmm_reg>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_xmm_reg>())
	{
		__darwin_xmm_reg& o = r.GetT<__darwin_xmm_reg>();
		if (name == "__xmm_reg")
		{
			return Reference(o.__xmm_reg);
		}
	}
	else if (r.IsT<const __darwin_xmm_reg>())
	{
		const __darwin_xmm_reg& o = r.GetT<const __darwin_xmm_reg>();
		if (name == "__xmm_reg")
		{
			return Reference(o.__xmm_reg);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_xmm_reg>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_xmm_reg>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_xmm_reg>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_xmm_reg>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_xmm_reg>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_xmm_reg>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_xmm_reg_name = "__darwin_xmm_reg";

const std::string& Class<__darwin_xmm_reg>::GetName() const
{
	return __darwin_xmm_reg_name;
}



namespace
{
	// Object to auto-register __darwin_xmm_reg.
	struct __darwin_xmm_reg_registrar
	{
		__darwin_xmm_reg_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_xmm_reg>>());
		}
	} __darwin_xmm_reg_instance;
}


const int Class<__darwin_ymm_reg>::FieldCount;
const int Class<__darwin_ymm_reg>::StaticFieldCount;
const int Class<__darwin_ymm_reg>::MethodCount;
const int Class<__darwin_ymm_reg>::StaticMethodCount;

int Class<__darwin_ymm_reg>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_ymm_reg>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_ymm_reg>())
	{
		__darwin_ymm_reg& o = r.GetT<__darwin_ymm_reg>();
		if (name == "__ymm_reg")
		{
			return Reference(o.__ymm_reg);
		}
	}
	else if (r.IsT<const __darwin_ymm_reg>())
	{
		const __darwin_ymm_reg& o = r.GetT<const __darwin_ymm_reg>();
		if (name == "__ymm_reg")
		{
			return Reference(o.__ymm_reg);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_ymm_reg>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_ymm_reg>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_ymm_reg>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_ymm_reg>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_ymm_reg>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_ymm_reg>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_ymm_reg_name = "__darwin_ymm_reg";

const std::string& Class<__darwin_ymm_reg>::GetName() const
{
	return __darwin_ymm_reg_name;
}



namespace
{
	// Object to auto-register __darwin_ymm_reg.
	struct __darwin_ymm_reg_registrar
	{
		__darwin_ymm_reg_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_ymm_reg>>());
		}
	} __darwin_ymm_reg_instance;
}


const int Class<__darwin_zmm_reg>::FieldCount;
const int Class<__darwin_zmm_reg>::StaticFieldCount;
const int Class<__darwin_zmm_reg>::MethodCount;
const int Class<__darwin_zmm_reg>::StaticMethodCount;

int Class<__darwin_zmm_reg>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_zmm_reg>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_zmm_reg>())
	{
		__darwin_zmm_reg& o = r.GetT<__darwin_zmm_reg>();
		if (name == "__zmm_reg")
		{
			return Reference(o.__zmm_reg);
		}
	}
	else if (r.IsT<const __darwin_zmm_reg>())
	{
		const __darwin_zmm_reg& o = r.GetT<const __darwin_zmm_reg>();
		if (name == "__zmm_reg")
		{
			return Reference(o.__zmm_reg);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_zmm_reg>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_zmm_reg>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_zmm_reg>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_zmm_reg>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_zmm_reg>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_zmm_reg>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_zmm_reg_name = "__darwin_zmm_reg";

const std::string& Class<__darwin_zmm_reg>::GetName() const
{
	return __darwin_zmm_reg_name;
}



namespace
{
	// Object to auto-register __darwin_zmm_reg.
	struct __darwin_zmm_reg_registrar
	{
		__darwin_zmm_reg_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_zmm_reg>>());
		}
	} __darwin_zmm_reg_instance;
}


const int Class<__darwin_opmask_reg>::FieldCount;
const int Class<__darwin_opmask_reg>::StaticFieldCount;
const int Class<__darwin_opmask_reg>::MethodCount;
const int Class<__darwin_opmask_reg>::StaticMethodCount;

int Class<__darwin_opmask_reg>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_opmask_reg>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_opmask_reg>())
	{
		__darwin_opmask_reg& o = r.GetT<__darwin_opmask_reg>();
		if (name == "__opmask_reg")
		{
			return Reference(o.__opmask_reg);
		}
	}
	else if (r.IsT<const __darwin_opmask_reg>())
	{
		const __darwin_opmask_reg& o = r.GetT<const __darwin_opmask_reg>();
		if (name == "__opmask_reg")
		{
			return Reference(o.__opmask_reg);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_opmask_reg>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_opmask_reg>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_opmask_reg>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_opmask_reg>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_opmask_reg>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_opmask_reg>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_opmask_reg_name = "__darwin_opmask_reg";

const std::string& Class<__darwin_opmask_reg>::GetName() const
{
	return __darwin_opmask_reg_name;
}



namespace
{
	// Object to auto-register __darwin_opmask_reg.
	struct __darwin_opmask_reg_registrar
	{
		__darwin_opmask_reg_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_opmask_reg>>());
		}
	} __darwin_opmask_reg_instance;
}


const int Class<__darwin_i386_float_state>::FieldCount;
const int Class<__darwin_i386_float_state>::StaticFieldCount;
const int Class<__darwin_i386_float_state>::MethodCount;
const int Class<__darwin_i386_float_state>::StaticMethodCount;

int Class<__darwin_i386_float_state>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_i386_float_state>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_i386_float_state>())
	{
		__darwin_i386_float_state& o = r.GetT<__darwin_i386_float_state>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
	}
	else if (r.IsT<const __darwin_i386_float_state>())
	{
		const __darwin_i386_float_state& o = r.GetT<const __darwin_i386_float_state>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_i386_float_state>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_i386_float_state>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_i386_float_state>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_i386_float_state>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_i386_float_state>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_i386_float_state>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_i386_float_state_name = "__darwin_i386_float_state";

const std::string& Class<__darwin_i386_float_state>::GetName() const
{
	return __darwin_i386_float_state_name;
}



namespace
{
	// Object to auto-register __darwin_i386_float_state.
	struct __darwin_i386_float_state_registrar
	{
		__darwin_i386_float_state_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_i386_float_state>>());
		}
	} __darwin_i386_float_state_instance;
}


const int Class<__darwin_i386_avx_state>::FieldCount;
const int Class<__darwin_i386_avx_state>::StaticFieldCount;
const int Class<__darwin_i386_avx_state>::MethodCount;
const int Class<__darwin_i386_avx_state>::StaticMethodCount;

int Class<__darwin_i386_avx_state>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_i386_avx_state>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_i386_avx_state>())
	{
		__darwin_i386_avx_state& o = r.GetT<__darwin_i386_avx_state>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
	}
	else if (r.IsT<const __darwin_i386_avx_state>())
	{
		const __darwin_i386_avx_state& o = r.GetT<const __darwin_i386_avx_state>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_i386_avx_state>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_i386_avx_state>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_i386_avx_state>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_i386_avx_state>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_i386_avx_state>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_i386_avx_state>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_i386_avx_state_name = "__darwin_i386_avx_state";

const std::string& Class<__darwin_i386_avx_state>::GetName() const
{
	return __darwin_i386_avx_state_name;
}



namespace
{
	// Object to auto-register __darwin_i386_avx_state.
	struct __darwin_i386_avx_state_registrar
	{
		__darwin_i386_avx_state_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_i386_avx_state>>());
		}
	} __darwin_i386_avx_state_instance;
}


const int Class<__darwin_i386_avx512_state>::FieldCount;
const int Class<__darwin_i386_avx512_state>::StaticFieldCount;
const int Class<__darwin_i386_avx512_state>::MethodCount;
const int Class<__darwin_i386_avx512_state>::StaticMethodCount;

int Class<__darwin_i386_avx512_state>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_i386_avx512_state>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_i386_avx512_state>())
	{
		__darwin_i386_avx512_state& o = r.GetT<__darwin_i386_avx512_state>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
		if (name == "__fpu_k0")
		{
			return Reference(o.__fpu_k0);
		}
		if (name == "__fpu_k1")
		{
			return Reference(o.__fpu_k1);
		}
		if (name == "__fpu_k2")
		{
			return Reference(o.__fpu_k2);
		}
		if (name == "__fpu_k3")
		{
			return Reference(o.__fpu_k3);
		}
		if (name == "__fpu_k4")
		{
			return Reference(o.__fpu_k4);
		}
		if (name == "__fpu_k5")
		{
			return Reference(o.__fpu_k5);
		}
		if (name == "__fpu_k6")
		{
			return Reference(o.__fpu_k6);
		}
		if (name == "__fpu_k7")
		{
			return Reference(o.__fpu_k7);
		}
		if (name == "__fpu_zmmh0")
		{
			return Reference(o.__fpu_zmmh0);
		}
		if (name == "__fpu_zmmh1")
		{
			return Reference(o.__fpu_zmmh1);
		}
		if (name == "__fpu_zmmh2")
		{
			return Reference(o.__fpu_zmmh2);
		}
		if (name == "__fpu_zmmh3")
		{
			return Reference(o.__fpu_zmmh3);
		}
		if (name == "__fpu_zmmh4")
		{
			return Reference(o.__fpu_zmmh4);
		}
		if (name == "__fpu_zmmh5")
		{
			return Reference(o.__fpu_zmmh5);
		}
		if (name == "__fpu_zmmh6")
		{
			return Reference(o.__fpu_zmmh6);
		}
		if (name == "__fpu_zmmh7")
		{
			return Reference(o.__fpu_zmmh7);
		}
	}
	else if (r.IsT<const __darwin_i386_avx512_state>())
	{
		const __darwin_i386_avx512_state& o = r.GetT<const __darwin_i386_avx512_state>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
		if (name == "__fpu_k0")
		{
			return Reference(o.__fpu_k0);
		}
		if (name == "__fpu_k1")
		{
			return Reference(o.__fpu_k1);
		}
		if (name == "__fpu_k2")
		{
			return Reference(o.__fpu_k2);
		}
		if (name == "__fpu_k3")
		{
			return Reference(o.__fpu_k3);
		}
		if (name == "__fpu_k4")
		{
			return Reference(o.__fpu_k4);
		}
		if (name == "__fpu_k5")
		{
			return Reference(o.__fpu_k5);
		}
		if (name == "__fpu_k6")
		{
			return Reference(o.__fpu_k6);
		}
		if (name == "__fpu_k7")
		{
			return Reference(o.__fpu_k7);
		}
		if (name == "__fpu_zmmh0")
		{
			return Reference(o.__fpu_zmmh0);
		}
		if (name == "__fpu_zmmh1")
		{
			return Reference(o.__fpu_zmmh1);
		}
		if (name == "__fpu_zmmh2")
		{
			return Reference(o.__fpu_zmmh2);
		}
		if (name == "__fpu_zmmh3")
		{
			return Reference(o.__fpu_zmmh3);
		}
		if (name == "__fpu_zmmh4")
		{
			return Reference(o.__fpu_zmmh4);
		}
		if (name == "__fpu_zmmh5")
		{
			return Reference(o.__fpu_zmmh5);
		}
		if (name == "__fpu_zmmh6")
		{
			return Reference(o.__fpu_zmmh6);
		}
		if (name == "__fpu_zmmh7")
		{
			return Reference(o.__fpu_zmmh7);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_i386_avx512_state>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_i386_avx512_state>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_i386_avx512_state>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_i386_avx512_state>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_i386_avx512_state>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_i386_avx512_state>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_i386_avx512_state_name = "__darwin_i386_avx512_state";

const std::string& Class<__darwin_i386_avx512_state>::GetName() const
{
	return __darwin_i386_avx512_state_name;
}



namespace
{
	// Object to auto-register __darwin_i386_avx512_state.
	struct __darwin_i386_avx512_state_registrar
	{
		__darwin_i386_avx512_state_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_i386_avx512_state>>());
		}
	} __darwin_i386_avx512_state_instance;
}


const int Class<__darwin_i386_exception_state>::FieldCount;
const int Class<__darwin_i386_exception_state>::StaticFieldCount;
const int Class<__darwin_i386_exception_state>::MethodCount;
const int Class<__darwin_i386_exception_state>::StaticMethodCount;

int Class<__darwin_i386_exception_state>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_i386_exception_state>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_i386_exception_state>())
	{
		__darwin_i386_exception_state& o = r.GetT<__darwin_i386_exception_state>();
		if (name == "__trapno")
		{
			return Reference(o.__trapno);
		}
		if (name == "__cpu")
		{
			return Reference(o.__cpu);
		}
		if (name == "__err")
		{
			return Reference(o.__err);
		}
		if (name == "__faultvaddr")
		{
			return Reference(o.__faultvaddr);
		}
	}
	else if (r.IsT<const __darwin_i386_exception_state>())
	{
		const __darwin_i386_exception_state& o = r.GetT<const __darwin_i386_exception_state>();
		if (name == "__trapno")
		{
			return Reference(o.__trapno);
		}
		if (name == "__cpu")
		{
			return Reference(o.__cpu);
		}
		if (name == "__err")
		{
			return Reference(o.__err);
		}
		if (name == "__faultvaddr")
		{
			return Reference(o.__faultvaddr);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_i386_exception_state>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_i386_exception_state>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_i386_exception_state>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_i386_exception_state>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_i386_exception_state>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_i386_exception_state>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_i386_exception_state_name = "__darwin_i386_exception_state";

const std::string& Class<__darwin_i386_exception_state>::GetName() const
{
	return __darwin_i386_exception_state_name;
}



namespace
{
	// Object to auto-register __darwin_i386_exception_state.
	struct __darwin_i386_exception_state_registrar
	{
		__darwin_i386_exception_state_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_i386_exception_state>>());
		}
	} __darwin_i386_exception_state_instance;
}


const int Class<__darwin_x86_debug_state32>::FieldCount;
const int Class<__darwin_x86_debug_state32>::StaticFieldCount;
const int Class<__darwin_x86_debug_state32>::MethodCount;
const int Class<__darwin_x86_debug_state32>::StaticMethodCount;

int Class<__darwin_x86_debug_state32>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_debug_state32>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_debug_state32>())
	{
		__darwin_x86_debug_state32& o = r.GetT<__darwin_x86_debug_state32>();
		if (name == "__dr0")
		{
			return Reference(o.__dr0);
		}
		if (name == "__dr1")
		{
			return Reference(o.__dr1);
		}
		if (name == "__dr2")
		{
			return Reference(o.__dr2);
		}
		if (name == "__dr3")
		{
			return Reference(o.__dr3);
		}
		if (name == "__dr4")
		{
			return Reference(o.__dr4);
		}
		if (name == "__dr5")
		{
			return Reference(o.__dr5);
		}
		if (name == "__dr6")
		{
			return Reference(o.__dr6);
		}
		if (name == "__dr7")
		{
			return Reference(o.__dr7);
		}
	}
	else if (r.IsT<const __darwin_x86_debug_state32>())
	{
		const __darwin_x86_debug_state32& o = r.GetT<const __darwin_x86_debug_state32>();
		if (name == "__dr0")
		{
			return Reference(o.__dr0);
		}
		if (name == "__dr1")
		{
			return Reference(o.__dr1);
		}
		if (name == "__dr2")
		{
			return Reference(o.__dr2);
		}
		if (name == "__dr3")
		{
			return Reference(o.__dr3);
		}
		if (name == "__dr4")
		{
			return Reference(o.__dr4);
		}
		if (name == "__dr5")
		{
			return Reference(o.__dr5);
		}
		if (name == "__dr6")
		{
			return Reference(o.__dr6);
		}
		if (name == "__dr7")
		{
			return Reference(o.__dr7);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_debug_state32>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_debug_state32>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_debug_state32>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_debug_state32>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_debug_state32>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_debug_state32>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_debug_state32_name = "__darwin_x86_debug_state32";

const std::string& Class<__darwin_x86_debug_state32>::GetName() const
{
	return __darwin_x86_debug_state32_name;
}



namespace
{
	// Object to auto-register __darwin_x86_debug_state32.
	struct __darwin_x86_debug_state32_registrar
	{
		__darwin_x86_debug_state32_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_debug_state32>>());
		}
	} __darwin_x86_debug_state32_instance;
}


const int Class<__darwin_x86_thread_state64>::FieldCount;
const int Class<__darwin_x86_thread_state64>::StaticFieldCount;
const int Class<__darwin_x86_thread_state64>::MethodCount;
const int Class<__darwin_x86_thread_state64>::StaticMethodCount;

int Class<__darwin_x86_thread_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_thread_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_thread_state64>())
	{
		__darwin_x86_thread_state64& o = r.GetT<__darwin_x86_thread_state64>();
		if (name == "__rax")
		{
			return Reference(o.__rax);
		}
		if (name == "__rbx")
		{
			return Reference(o.__rbx);
		}
		if (name == "__rcx")
		{
			return Reference(o.__rcx);
		}
		if (name == "__rdx")
		{
			return Reference(o.__rdx);
		}
		if (name == "__rdi")
		{
			return Reference(o.__rdi);
		}
		if (name == "__rsi")
		{
			return Reference(o.__rsi);
		}
		if (name == "__rbp")
		{
			return Reference(o.__rbp);
		}
		if (name == "__rsp")
		{
			return Reference(o.__rsp);
		}
		if (name == "__r8")
		{
			return Reference(o.__r8);
		}
		if (name == "__r9")
		{
			return Reference(o.__r9);
		}
		if (name == "__r10")
		{
			return Reference(o.__r10);
		}
		if (name == "__r11")
		{
			return Reference(o.__r11);
		}
		if (name == "__r12")
		{
			return Reference(o.__r12);
		}
		if (name == "__r13")
		{
			return Reference(o.__r13);
		}
		if (name == "__r14")
		{
			return Reference(o.__r14);
		}
		if (name == "__r15")
		{
			return Reference(o.__r15);
		}
		if (name == "__rip")
		{
			return Reference(o.__rip);
		}
		if (name == "__rflags")
		{
			return Reference(o.__rflags);
		}
		if (name == "__cs")
		{
			return Reference(o.__cs);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
		if (name == "__gs")
		{
			return Reference(o.__gs);
		}
	}
	else if (r.IsT<const __darwin_x86_thread_state64>())
	{
		const __darwin_x86_thread_state64& o = r.GetT<const __darwin_x86_thread_state64>();
		if (name == "__rax")
		{
			return Reference(o.__rax);
		}
		if (name == "__rbx")
		{
			return Reference(o.__rbx);
		}
		if (name == "__rcx")
		{
			return Reference(o.__rcx);
		}
		if (name == "__rdx")
		{
			return Reference(o.__rdx);
		}
		if (name == "__rdi")
		{
			return Reference(o.__rdi);
		}
		if (name == "__rsi")
		{
			return Reference(o.__rsi);
		}
		if (name == "__rbp")
		{
			return Reference(o.__rbp);
		}
		if (name == "__rsp")
		{
			return Reference(o.__rsp);
		}
		if (name == "__r8")
		{
			return Reference(o.__r8);
		}
		if (name == "__r9")
		{
			return Reference(o.__r9);
		}
		if (name == "__r10")
		{
			return Reference(o.__r10);
		}
		if (name == "__r11")
		{
			return Reference(o.__r11);
		}
		if (name == "__r12")
		{
			return Reference(o.__r12);
		}
		if (name == "__r13")
		{
			return Reference(o.__r13);
		}
		if (name == "__r14")
		{
			return Reference(o.__r14);
		}
		if (name == "__r15")
		{
			return Reference(o.__r15);
		}
		if (name == "__rip")
		{
			return Reference(o.__rip);
		}
		if (name == "__rflags")
		{
			return Reference(o.__rflags);
		}
		if (name == "__cs")
		{
			return Reference(o.__cs);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
		if (name == "__gs")
		{
			return Reference(o.__gs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_thread_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_thread_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_thread_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_thread_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_thread_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_thread_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_thread_state64_name = "__darwin_x86_thread_state64";

const std::string& Class<__darwin_x86_thread_state64>::GetName() const
{
	return __darwin_x86_thread_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_thread_state64.
	struct __darwin_x86_thread_state64_registrar
	{
		__darwin_x86_thread_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_thread_state64>>());
		}
	} __darwin_x86_thread_state64_instance;
}


const int Class<__darwin_x86_thread_full_state64>::FieldCount;
const int Class<__darwin_x86_thread_full_state64>::StaticFieldCount;
const int Class<__darwin_x86_thread_full_state64>::MethodCount;
const int Class<__darwin_x86_thread_full_state64>::StaticMethodCount;

int Class<__darwin_x86_thread_full_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_thread_full_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_thread_full_state64>())
	{
		__darwin_x86_thread_full_state64& o = r.GetT<__darwin_x86_thread_full_state64>();
		if (name == "ss64")
		{
			return Reference(o.ss64);
		}
		if (name == "__ds")
		{
			return Reference(o.__ds);
		}
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
	}
	else if (r.IsT<const __darwin_x86_thread_full_state64>())
	{
		const __darwin_x86_thread_full_state64& o = r.GetT<const __darwin_x86_thread_full_state64>();
		if (name == "ss64")
		{
			return Reference(o.ss64);
		}
		if (name == "__ds")
		{
			return Reference(o.__ds);
		}
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_thread_full_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_thread_full_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_thread_full_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_thread_full_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_thread_full_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_thread_full_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_thread_full_state64_name = "__darwin_x86_thread_full_state64";

const std::string& Class<__darwin_x86_thread_full_state64>::GetName() const
{
	return __darwin_x86_thread_full_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_thread_full_state64.
	struct __darwin_x86_thread_full_state64_registrar
	{
		__darwin_x86_thread_full_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_thread_full_state64>>());
		}
	} __darwin_x86_thread_full_state64_instance;
}


const int Class<__darwin_x86_float_state64>::FieldCount;
const int Class<__darwin_x86_float_state64>::StaticFieldCount;
const int Class<__darwin_x86_float_state64>::MethodCount;
const int Class<__darwin_x86_float_state64>::StaticMethodCount;

int Class<__darwin_x86_float_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_float_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_float_state64>())
	{
		__darwin_x86_float_state64& o = r.GetT<__darwin_x86_float_state64>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_xmm8")
		{
			return Reference(o.__fpu_xmm8);
		}
		if (name == "__fpu_xmm9")
		{
			return Reference(o.__fpu_xmm9);
		}
		if (name == "__fpu_xmm10")
		{
			return Reference(o.__fpu_xmm10);
		}
		if (name == "__fpu_xmm11")
		{
			return Reference(o.__fpu_xmm11);
		}
		if (name == "__fpu_xmm12")
		{
			return Reference(o.__fpu_xmm12);
		}
		if (name == "__fpu_xmm13")
		{
			return Reference(o.__fpu_xmm13);
		}
		if (name == "__fpu_xmm14")
		{
			return Reference(o.__fpu_xmm14);
		}
		if (name == "__fpu_xmm15")
		{
			return Reference(o.__fpu_xmm15);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
	}
	else if (r.IsT<const __darwin_x86_float_state64>())
	{
		const __darwin_x86_float_state64& o = r.GetT<const __darwin_x86_float_state64>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_xmm8")
		{
			return Reference(o.__fpu_xmm8);
		}
		if (name == "__fpu_xmm9")
		{
			return Reference(o.__fpu_xmm9);
		}
		if (name == "__fpu_xmm10")
		{
			return Reference(o.__fpu_xmm10);
		}
		if (name == "__fpu_xmm11")
		{
			return Reference(o.__fpu_xmm11);
		}
		if (name == "__fpu_xmm12")
		{
			return Reference(o.__fpu_xmm12);
		}
		if (name == "__fpu_xmm13")
		{
			return Reference(o.__fpu_xmm13);
		}
		if (name == "__fpu_xmm14")
		{
			return Reference(o.__fpu_xmm14);
		}
		if (name == "__fpu_xmm15")
		{
			return Reference(o.__fpu_xmm15);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_float_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_float_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_float_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_float_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_float_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_float_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_float_state64_name = "__darwin_x86_float_state64";

const std::string& Class<__darwin_x86_float_state64>::GetName() const
{
	return __darwin_x86_float_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_float_state64.
	struct __darwin_x86_float_state64_registrar
	{
		__darwin_x86_float_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_float_state64>>());
		}
	} __darwin_x86_float_state64_instance;
}


const int Class<__darwin_x86_avx_state64>::FieldCount;
const int Class<__darwin_x86_avx_state64>::StaticFieldCount;
const int Class<__darwin_x86_avx_state64>::MethodCount;
const int Class<__darwin_x86_avx_state64>::StaticMethodCount;

int Class<__darwin_x86_avx_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_avx_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_avx_state64>())
	{
		__darwin_x86_avx_state64& o = r.GetT<__darwin_x86_avx_state64>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_xmm8")
		{
			return Reference(o.__fpu_xmm8);
		}
		if (name == "__fpu_xmm9")
		{
			return Reference(o.__fpu_xmm9);
		}
		if (name == "__fpu_xmm10")
		{
			return Reference(o.__fpu_xmm10);
		}
		if (name == "__fpu_xmm11")
		{
			return Reference(o.__fpu_xmm11);
		}
		if (name == "__fpu_xmm12")
		{
			return Reference(o.__fpu_xmm12);
		}
		if (name == "__fpu_xmm13")
		{
			return Reference(o.__fpu_xmm13);
		}
		if (name == "__fpu_xmm14")
		{
			return Reference(o.__fpu_xmm14);
		}
		if (name == "__fpu_xmm15")
		{
			return Reference(o.__fpu_xmm15);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
		if (name == "__fpu_ymmh8")
		{
			return Reference(o.__fpu_ymmh8);
		}
		if (name == "__fpu_ymmh9")
		{
			return Reference(o.__fpu_ymmh9);
		}
		if (name == "__fpu_ymmh10")
		{
			return Reference(o.__fpu_ymmh10);
		}
		if (name == "__fpu_ymmh11")
		{
			return Reference(o.__fpu_ymmh11);
		}
		if (name == "__fpu_ymmh12")
		{
			return Reference(o.__fpu_ymmh12);
		}
		if (name == "__fpu_ymmh13")
		{
			return Reference(o.__fpu_ymmh13);
		}
		if (name == "__fpu_ymmh14")
		{
			return Reference(o.__fpu_ymmh14);
		}
		if (name == "__fpu_ymmh15")
		{
			return Reference(o.__fpu_ymmh15);
		}
	}
	else if (r.IsT<const __darwin_x86_avx_state64>())
	{
		const __darwin_x86_avx_state64& o = r.GetT<const __darwin_x86_avx_state64>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_xmm8")
		{
			return Reference(o.__fpu_xmm8);
		}
		if (name == "__fpu_xmm9")
		{
			return Reference(o.__fpu_xmm9);
		}
		if (name == "__fpu_xmm10")
		{
			return Reference(o.__fpu_xmm10);
		}
		if (name == "__fpu_xmm11")
		{
			return Reference(o.__fpu_xmm11);
		}
		if (name == "__fpu_xmm12")
		{
			return Reference(o.__fpu_xmm12);
		}
		if (name == "__fpu_xmm13")
		{
			return Reference(o.__fpu_xmm13);
		}
		if (name == "__fpu_xmm14")
		{
			return Reference(o.__fpu_xmm14);
		}
		if (name == "__fpu_xmm15")
		{
			return Reference(o.__fpu_xmm15);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
		if (name == "__fpu_ymmh8")
		{
			return Reference(o.__fpu_ymmh8);
		}
		if (name == "__fpu_ymmh9")
		{
			return Reference(o.__fpu_ymmh9);
		}
		if (name == "__fpu_ymmh10")
		{
			return Reference(o.__fpu_ymmh10);
		}
		if (name == "__fpu_ymmh11")
		{
			return Reference(o.__fpu_ymmh11);
		}
		if (name == "__fpu_ymmh12")
		{
			return Reference(o.__fpu_ymmh12);
		}
		if (name == "__fpu_ymmh13")
		{
			return Reference(o.__fpu_ymmh13);
		}
		if (name == "__fpu_ymmh14")
		{
			return Reference(o.__fpu_ymmh14);
		}
		if (name == "__fpu_ymmh15")
		{
			return Reference(o.__fpu_ymmh15);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_avx_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_avx_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_avx_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_avx_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_avx_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_avx_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_avx_state64_name = "__darwin_x86_avx_state64";

const std::string& Class<__darwin_x86_avx_state64>::GetName() const
{
	return __darwin_x86_avx_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_avx_state64.
	struct __darwin_x86_avx_state64_registrar
	{
		__darwin_x86_avx_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_avx_state64>>());
		}
	} __darwin_x86_avx_state64_instance;
}


const int Class<__darwin_x86_avx512_state64>::FieldCount;
const int Class<__darwin_x86_avx512_state64>::StaticFieldCount;
const int Class<__darwin_x86_avx512_state64>::MethodCount;
const int Class<__darwin_x86_avx512_state64>::StaticMethodCount;

int Class<__darwin_x86_avx512_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_avx512_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_avx512_state64>())
	{
		__darwin_x86_avx512_state64& o = r.GetT<__darwin_x86_avx512_state64>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_xmm8")
		{
			return Reference(o.__fpu_xmm8);
		}
		if (name == "__fpu_xmm9")
		{
			return Reference(o.__fpu_xmm9);
		}
		if (name == "__fpu_xmm10")
		{
			return Reference(o.__fpu_xmm10);
		}
		if (name == "__fpu_xmm11")
		{
			return Reference(o.__fpu_xmm11);
		}
		if (name == "__fpu_xmm12")
		{
			return Reference(o.__fpu_xmm12);
		}
		if (name == "__fpu_xmm13")
		{
			return Reference(o.__fpu_xmm13);
		}
		if (name == "__fpu_xmm14")
		{
			return Reference(o.__fpu_xmm14);
		}
		if (name == "__fpu_xmm15")
		{
			return Reference(o.__fpu_xmm15);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
		if (name == "__fpu_ymmh8")
		{
			return Reference(o.__fpu_ymmh8);
		}
		if (name == "__fpu_ymmh9")
		{
			return Reference(o.__fpu_ymmh9);
		}
		if (name == "__fpu_ymmh10")
		{
			return Reference(o.__fpu_ymmh10);
		}
		if (name == "__fpu_ymmh11")
		{
			return Reference(o.__fpu_ymmh11);
		}
		if (name == "__fpu_ymmh12")
		{
			return Reference(o.__fpu_ymmh12);
		}
		if (name == "__fpu_ymmh13")
		{
			return Reference(o.__fpu_ymmh13);
		}
		if (name == "__fpu_ymmh14")
		{
			return Reference(o.__fpu_ymmh14);
		}
		if (name == "__fpu_ymmh15")
		{
			return Reference(o.__fpu_ymmh15);
		}
		if (name == "__fpu_k0")
		{
			return Reference(o.__fpu_k0);
		}
		if (name == "__fpu_k1")
		{
			return Reference(o.__fpu_k1);
		}
		if (name == "__fpu_k2")
		{
			return Reference(o.__fpu_k2);
		}
		if (name == "__fpu_k3")
		{
			return Reference(o.__fpu_k3);
		}
		if (name == "__fpu_k4")
		{
			return Reference(o.__fpu_k4);
		}
		if (name == "__fpu_k5")
		{
			return Reference(o.__fpu_k5);
		}
		if (name == "__fpu_k6")
		{
			return Reference(o.__fpu_k6);
		}
		if (name == "__fpu_k7")
		{
			return Reference(o.__fpu_k7);
		}
		if (name == "__fpu_zmmh0")
		{
			return Reference(o.__fpu_zmmh0);
		}
		if (name == "__fpu_zmmh1")
		{
			return Reference(o.__fpu_zmmh1);
		}
		if (name == "__fpu_zmmh2")
		{
			return Reference(o.__fpu_zmmh2);
		}
		if (name == "__fpu_zmmh3")
		{
			return Reference(o.__fpu_zmmh3);
		}
		if (name == "__fpu_zmmh4")
		{
			return Reference(o.__fpu_zmmh4);
		}
		if (name == "__fpu_zmmh5")
		{
			return Reference(o.__fpu_zmmh5);
		}
		if (name == "__fpu_zmmh6")
		{
			return Reference(o.__fpu_zmmh6);
		}
		if (name == "__fpu_zmmh7")
		{
			return Reference(o.__fpu_zmmh7);
		}
		if (name == "__fpu_zmmh8")
		{
			return Reference(o.__fpu_zmmh8);
		}
		if (name == "__fpu_zmmh9")
		{
			return Reference(o.__fpu_zmmh9);
		}
		if (name == "__fpu_zmmh10")
		{
			return Reference(o.__fpu_zmmh10);
		}
		if (name == "__fpu_zmmh11")
		{
			return Reference(o.__fpu_zmmh11);
		}
		if (name == "__fpu_zmmh12")
		{
			return Reference(o.__fpu_zmmh12);
		}
		if (name == "__fpu_zmmh13")
		{
			return Reference(o.__fpu_zmmh13);
		}
		if (name == "__fpu_zmmh14")
		{
			return Reference(o.__fpu_zmmh14);
		}
		if (name == "__fpu_zmmh15")
		{
			return Reference(o.__fpu_zmmh15);
		}
		if (name == "__fpu_zmm16")
		{
			return Reference(o.__fpu_zmm16);
		}
		if (name == "__fpu_zmm17")
		{
			return Reference(o.__fpu_zmm17);
		}
		if (name == "__fpu_zmm18")
		{
			return Reference(o.__fpu_zmm18);
		}
		if (name == "__fpu_zmm19")
		{
			return Reference(o.__fpu_zmm19);
		}
		if (name == "__fpu_zmm20")
		{
			return Reference(o.__fpu_zmm20);
		}
		if (name == "__fpu_zmm21")
		{
			return Reference(o.__fpu_zmm21);
		}
		if (name == "__fpu_zmm22")
		{
			return Reference(o.__fpu_zmm22);
		}
		if (name == "__fpu_zmm23")
		{
			return Reference(o.__fpu_zmm23);
		}
		if (name == "__fpu_zmm24")
		{
			return Reference(o.__fpu_zmm24);
		}
		if (name == "__fpu_zmm25")
		{
			return Reference(o.__fpu_zmm25);
		}
		if (name == "__fpu_zmm26")
		{
			return Reference(o.__fpu_zmm26);
		}
		if (name == "__fpu_zmm27")
		{
			return Reference(o.__fpu_zmm27);
		}
		if (name == "__fpu_zmm28")
		{
			return Reference(o.__fpu_zmm28);
		}
		if (name == "__fpu_zmm29")
		{
			return Reference(o.__fpu_zmm29);
		}
		if (name == "__fpu_zmm30")
		{
			return Reference(o.__fpu_zmm30);
		}
		if (name == "__fpu_zmm31")
		{
			return Reference(o.__fpu_zmm31);
		}
	}
	else if (r.IsT<const __darwin_x86_avx512_state64>())
	{
		const __darwin_x86_avx512_state64& o = r.GetT<const __darwin_x86_avx512_state64>();
		if (name == "__fpu_reserved")
		{
			return Reference(o.__fpu_reserved);
		}
		if (name == "__fpu_fcw")
		{
			return Reference(o.__fpu_fcw);
		}
		if (name == "__fpu_fsw")
		{
			return Reference(o.__fpu_fsw);
		}
		if (name == "__fpu_ftw")
		{
			return Reference(o.__fpu_ftw);
		}
		if (name == "__fpu_rsrv1")
		{
			return Reference(o.__fpu_rsrv1);
		}
		if (name == "__fpu_fop")
		{
			return Reference(o.__fpu_fop);
		}
		if (name == "__fpu_ip")
		{
			return Reference(o.__fpu_ip);
		}
		if (name == "__fpu_cs")
		{
			return Reference(o.__fpu_cs);
		}
		if (name == "__fpu_rsrv2")
		{
			return Reference(o.__fpu_rsrv2);
		}
		if (name == "__fpu_dp")
		{
			return Reference(o.__fpu_dp);
		}
		if (name == "__fpu_ds")
		{
			return Reference(o.__fpu_ds);
		}
		if (name == "__fpu_rsrv3")
		{
			return Reference(o.__fpu_rsrv3);
		}
		if (name == "__fpu_mxcsr")
		{
			return Reference(o.__fpu_mxcsr);
		}
		if (name == "__fpu_mxcsrmask")
		{
			return Reference(o.__fpu_mxcsrmask);
		}
		if (name == "__fpu_stmm0")
		{
			return Reference(o.__fpu_stmm0);
		}
		if (name == "__fpu_stmm1")
		{
			return Reference(o.__fpu_stmm1);
		}
		if (name == "__fpu_stmm2")
		{
			return Reference(o.__fpu_stmm2);
		}
		if (name == "__fpu_stmm3")
		{
			return Reference(o.__fpu_stmm3);
		}
		if (name == "__fpu_stmm4")
		{
			return Reference(o.__fpu_stmm4);
		}
		if (name == "__fpu_stmm5")
		{
			return Reference(o.__fpu_stmm5);
		}
		if (name == "__fpu_stmm6")
		{
			return Reference(o.__fpu_stmm6);
		}
		if (name == "__fpu_stmm7")
		{
			return Reference(o.__fpu_stmm7);
		}
		if (name == "__fpu_xmm0")
		{
			return Reference(o.__fpu_xmm0);
		}
		if (name == "__fpu_xmm1")
		{
			return Reference(o.__fpu_xmm1);
		}
		if (name == "__fpu_xmm2")
		{
			return Reference(o.__fpu_xmm2);
		}
		if (name == "__fpu_xmm3")
		{
			return Reference(o.__fpu_xmm3);
		}
		if (name == "__fpu_xmm4")
		{
			return Reference(o.__fpu_xmm4);
		}
		if (name == "__fpu_xmm5")
		{
			return Reference(o.__fpu_xmm5);
		}
		if (name == "__fpu_xmm6")
		{
			return Reference(o.__fpu_xmm6);
		}
		if (name == "__fpu_xmm7")
		{
			return Reference(o.__fpu_xmm7);
		}
		if (name == "__fpu_xmm8")
		{
			return Reference(o.__fpu_xmm8);
		}
		if (name == "__fpu_xmm9")
		{
			return Reference(o.__fpu_xmm9);
		}
		if (name == "__fpu_xmm10")
		{
			return Reference(o.__fpu_xmm10);
		}
		if (name == "__fpu_xmm11")
		{
			return Reference(o.__fpu_xmm11);
		}
		if (name == "__fpu_xmm12")
		{
			return Reference(o.__fpu_xmm12);
		}
		if (name == "__fpu_xmm13")
		{
			return Reference(o.__fpu_xmm13);
		}
		if (name == "__fpu_xmm14")
		{
			return Reference(o.__fpu_xmm14);
		}
		if (name == "__fpu_xmm15")
		{
			return Reference(o.__fpu_xmm15);
		}
		if (name == "__fpu_rsrv4")
		{
			return Reference(o.__fpu_rsrv4);
		}
		if (name == "__fpu_reserved1")
		{
			return Reference(o.__fpu_reserved1);
		}
		if (name == "__avx_reserved1")
		{
			return Reference(o.__avx_reserved1);
		}
		if (name == "__fpu_ymmh0")
		{
			return Reference(o.__fpu_ymmh0);
		}
		if (name == "__fpu_ymmh1")
		{
			return Reference(o.__fpu_ymmh1);
		}
		if (name == "__fpu_ymmh2")
		{
			return Reference(o.__fpu_ymmh2);
		}
		if (name == "__fpu_ymmh3")
		{
			return Reference(o.__fpu_ymmh3);
		}
		if (name == "__fpu_ymmh4")
		{
			return Reference(o.__fpu_ymmh4);
		}
		if (name == "__fpu_ymmh5")
		{
			return Reference(o.__fpu_ymmh5);
		}
		if (name == "__fpu_ymmh6")
		{
			return Reference(o.__fpu_ymmh6);
		}
		if (name == "__fpu_ymmh7")
		{
			return Reference(o.__fpu_ymmh7);
		}
		if (name == "__fpu_ymmh8")
		{
			return Reference(o.__fpu_ymmh8);
		}
		if (name == "__fpu_ymmh9")
		{
			return Reference(o.__fpu_ymmh9);
		}
		if (name == "__fpu_ymmh10")
		{
			return Reference(o.__fpu_ymmh10);
		}
		if (name == "__fpu_ymmh11")
		{
			return Reference(o.__fpu_ymmh11);
		}
		if (name == "__fpu_ymmh12")
		{
			return Reference(o.__fpu_ymmh12);
		}
		if (name == "__fpu_ymmh13")
		{
			return Reference(o.__fpu_ymmh13);
		}
		if (name == "__fpu_ymmh14")
		{
			return Reference(o.__fpu_ymmh14);
		}
		if (name == "__fpu_ymmh15")
		{
			return Reference(o.__fpu_ymmh15);
		}
		if (name == "__fpu_k0")
		{
			return Reference(o.__fpu_k0);
		}
		if (name == "__fpu_k1")
		{
			return Reference(o.__fpu_k1);
		}
		if (name == "__fpu_k2")
		{
			return Reference(o.__fpu_k2);
		}
		if (name == "__fpu_k3")
		{
			return Reference(o.__fpu_k3);
		}
		if (name == "__fpu_k4")
		{
			return Reference(o.__fpu_k4);
		}
		if (name == "__fpu_k5")
		{
			return Reference(o.__fpu_k5);
		}
		if (name == "__fpu_k6")
		{
			return Reference(o.__fpu_k6);
		}
		if (name == "__fpu_k7")
		{
			return Reference(o.__fpu_k7);
		}
		if (name == "__fpu_zmmh0")
		{
			return Reference(o.__fpu_zmmh0);
		}
		if (name == "__fpu_zmmh1")
		{
			return Reference(o.__fpu_zmmh1);
		}
		if (name == "__fpu_zmmh2")
		{
			return Reference(o.__fpu_zmmh2);
		}
		if (name == "__fpu_zmmh3")
		{
			return Reference(o.__fpu_zmmh3);
		}
		if (name == "__fpu_zmmh4")
		{
			return Reference(o.__fpu_zmmh4);
		}
		if (name == "__fpu_zmmh5")
		{
			return Reference(o.__fpu_zmmh5);
		}
		if (name == "__fpu_zmmh6")
		{
			return Reference(o.__fpu_zmmh6);
		}
		if (name == "__fpu_zmmh7")
		{
			return Reference(o.__fpu_zmmh7);
		}
		if (name == "__fpu_zmmh8")
		{
			return Reference(o.__fpu_zmmh8);
		}
		if (name == "__fpu_zmmh9")
		{
			return Reference(o.__fpu_zmmh9);
		}
		if (name == "__fpu_zmmh10")
		{
			return Reference(o.__fpu_zmmh10);
		}
		if (name == "__fpu_zmmh11")
		{
			return Reference(o.__fpu_zmmh11);
		}
		if (name == "__fpu_zmmh12")
		{
			return Reference(o.__fpu_zmmh12);
		}
		if (name == "__fpu_zmmh13")
		{
			return Reference(o.__fpu_zmmh13);
		}
		if (name == "__fpu_zmmh14")
		{
			return Reference(o.__fpu_zmmh14);
		}
		if (name == "__fpu_zmmh15")
		{
			return Reference(o.__fpu_zmmh15);
		}
		if (name == "__fpu_zmm16")
		{
			return Reference(o.__fpu_zmm16);
		}
		if (name == "__fpu_zmm17")
		{
			return Reference(o.__fpu_zmm17);
		}
		if (name == "__fpu_zmm18")
		{
			return Reference(o.__fpu_zmm18);
		}
		if (name == "__fpu_zmm19")
		{
			return Reference(o.__fpu_zmm19);
		}
		if (name == "__fpu_zmm20")
		{
			return Reference(o.__fpu_zmm20);
		}
		if (name == "__fpu_zmm21")
		{
			return Reference(o.__fpu_zmm21);
		}
		if (name == "__fpu_zmm22")
		{
			return Reference(o.__fpu_zmm22);
		}
		if (name == "__fpu_zmm23")
		{
			return Reference(o.__fpu_zmm23);
		}
		if (name == "__fpu_zmm24")
		{
			return Reference(o.__fpu_zmm24);
		}
		if (name == "__fpu_zmm25")
		{
			return Reference(o.__fpu_zmm25);
		}
		if (name == "__fpu_zmm26")
		{
			return Reference(o.__fpu_zmm26);
		}
		if (name == "__fpu_zmm27")
		{
			return Reference(o.__fpu_zmm27);
		}
		if (name == "__fpu_zmm28")
		{
			return Reference(o.__fpu_zmm28);
		}
		if (name == "__fpu_zmm29")
		{
			return Reference(o.__fpu_zmm29);
		}
		if (name == "__fpu_zmm30")
		{
			return Reference(o.__fpu_zmm30);
		}
		if (name == "__fpu_zmm31")
		{
			return Reference(o.__fpu_zmm31);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_avx512_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_avx512_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_avx512_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_avx512_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_avx512_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_avx512_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_avx512_state64_name = "__darwin_x86_avx512_state64";

const std::string& Class<__darwin_x86_avx512_state64>::GetName() const
{
	return __darwin_x86_avx512_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_avx512_state64.
	struct __darwin_x86_avx512_state64_registrar
	{
		__darwin_x86_avx512_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_avx512_state64>>());
		}
	} __darwin_x86_avx512_state64_instance;
}


const int Class<__darwin_x86_exception_state64>::FieldCount;
const int Class<__darwin_x86_exception_state64>::StaticFieldCount;
const int Class<__darwin_x86_exception_state64>::MethodCount;
const int Class<__darwin_x86_exception_state64>::StaticMethodCount;

int Class<__darwin_x86_exception_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_exception_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_exception_state64>())
	{
		__darwin_x86_exception_state64& o = r.GetT<__darwin_x86_exception_state64>();
		if (name == "__trapno")
		{
			return Reference(o.__trapno);
		}
		if (name == "__cpu")
		{
			return Reference(o.__cpu);
		}
		if (name == "__err")
		{
			return Reference(o.__err);
		}
		if (name == "__faultvaddr")
		{
			return Reference(o.__faultvaddr);
		}
	}
	else if (r.IsT<const __darwin_x86_exception_state64>())
	{
		const __darwin_x86_exception_state64& o = r.GetT<const __darwin_x86_exception_state64>();
		if (name == "__trapno")
		{
			return Reference(o.__trapno);
		}
		if (name == "__cpu")
		{
			return Reference(o.__cpu);
		}
		if (name == "__err")
		{
			return Reference(o.__err);
		}
		if (name == "__faultvaddr")
		{
			return Reference(o.__faultvaddr);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_exception_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_exception_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_exception_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_exception_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_exception_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_exception_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_exception_state64_name = "__darwin_x86_exception_state64";

const std::string& Class<__darwin_x86_exception_state64>::GetName() const
{
	return __darwin_x86_exception_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_exception_state64.
	struct __darwin_x86_exception_state64_registrar
	{
		__darwin_x86_exception_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_exception_state64>>());
		}
	} __darwin_x86_exception_state64_instance;
}


const int Class<__darwin_x86_debug_state64>::FieldCount;
const int Class<__darwin_x86_debug_state64>::StaticFieldCount;
const int Class<__darwin_x86_debug_state64>::MethodCount;
const int Class<__darwin_x86_debug_state64>::StaticMethodCount;

int Class<__darwin_x86_debug_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_debug_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_debug_state64>())
	{
		__darwin_x86_debug_state64& o = r.GetT<__darwin_x86_debug_state64>();
		if (name == "__dr0")
		{
			return Reference(o.__dr0);
		}
		if (name == "__dr1")
		{
			return Reference(o.__dr1);
		}
		if (name == "__dr2")
		{
			return Reference(o.__dr2);
		}
		if (name == "__dr3")
		{
			return Reference(o.__dr3);
		}
		if (name == "__dr4")
		{
			return Reference(o.__dr4);
		}
		if (name == "__dr5")
		{
			return Reference(o.__dr5);
		}
		if (name == "__dr6")
		{
			return Reference(o.__dr6);
		}
		if (name == "__dr7")
		{
			return Reference(o.__dr7);
		}
	}
	else if (r.IsT<const __darwin_x86_debug_state64>())
	{
		const __darwin_x86_debug_state64& o = r.GetT<const __darwin_x86_debug_state64>();
		if (name == "__dr0")
		{
			return Reference(o.__dr0);
		}
		if (name == "__dr1")
		{
			return Reference(o.__dr1);
		}
		if (name == "__dr2")
		{
			return Reference(o.__dr2);
		}
		if (name == "__dr3")
		{
			return Reference(o.__dr3);
		}
		if (name == "__dr4")
		{
			return Reference(o.__dr4);
		}
		if (name == "__dr5")
		{
			return Reference(o.__dr5);
		}
		if (name == "__dr6")
		{
			return Reference(o.__dr6);
		}
		if (name == "__dr7")
		{
			return Reference(o.__dr7);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_debug_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_debug_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_debug_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_debug_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_debug_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_debug_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_debug_state64_name = "__darwin_x86_debug_state64";

const std::string& Class<__darwin_x86_debug_state64>::GetName() const
{
	return __darwin_x86_debug_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_debug_state64.
	struct __darwin_x86_debug_state64_registrar
	{
		__darwin_x86_debug_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_debug_state64>>());
		}
	} __darwin_x86_debug_state64_instance;
}


const int Class<__darwin_x86_cpmu_state64>::FieldCount;
const int Class<__darwin_x86_cpmu_state64>::StaticFieldCount;
const int Class<__darwin_x86_cpmu_state64>::MethodCount;
const int Class<__darwin_x86_cpmu_state64>::StaticMethodCount;

int Class<__darwin_x86_cpmu_state64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_x86_cpmu_state64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_x86_cpmu_state64>())
	{
		__darwin_x86_cpmu_state64& o = r.GetT<__darwin_x86_cpmu_state64>();
		if (name == "__ctrs")
		{
			return Reference(o.__ctrs);
		}
	}
	else if (r.IsT<const __darwin_x86_cpmu_state64>())
	{
		const __darwin_x86_cpmu_state64& o = r.GetT<const __darwin_x86_cpmu_state64>();
		if (name == "__ctrs")
		{
			return Reference(o.__ctrs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_x86_cpmu_state64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_x86_cpmu_state64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_x86_cpmu_state64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_x86_cpmu_state64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_x86_cpmu_state64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_x86_cpmu_state64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_x86_cpmu_state64_name = "__darwin_x86_cpmu_state64";

const std::string& Class<__darwin_x86_cpmu_state64>::GetName() const
{
	return __darwin_x86_cpmu_state64_name;
}



namespace
{
	// Object to auto-register __darwin_x86_cpmu_state64.
	struct __darwin_x86_cpmu_state64_registrar
	{
		__darwin_x86_cpmu_state64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_x86_cpmu_state64>>());
		}
	} __darwin_x86_cpmu_state64_instance;
}


const int Class<__darwin_mcontext32>::FieldCount;
const int Class<__darwin_mcontext32>::StaticFieldCount;
const int Class<__darwin_mcontext32>::MethodCount;
const int Class<__darwin_mcontext32>::StaticMethodCount;

int Class<__darwin_mcontext32>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mcontext32>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mcontext32>())
	{
		__darwin_mcontext32& o = r.GetT<__darwin_mcontext32>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else if (r.IsT<const __darwin_mcontext32>())
	{
		const __darwin_mcontext32& o = r.GetT<const __darwin_mcontext32>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mcontext32>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mcontext32>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mcontext32>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mcontext32>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mcontext32>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mcontext32>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mcontext32_name = "__darwin_mcontext32";

const std::string& Class<__darwin_mcontext32>::GetName() const
{
	return __darwin_mcontext32_name;
}



namespace
{
	// Object to auto-register __darwin_mcontext32.
	struct __darwin_mcontext32_registrar
	{
		__darwin_mcontext32_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mcontext32>>());
		}
	} __darwin_mcontext32_instance;
}


const int Class<__darwin_mcontext_avx32>::FieldCount;
const int Class<__darwin_mcontext_avx32>::StaticFieldCount;
const int Class<__darwin_mcontext_avx32>::MethodCount;
const int Class<__darwin_mcontext_avx32>::StaticMethodCount;

int Class<__darwin_mcontext_avx32>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mcontext_avx32>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mcontext_avx32>())
	{
		__darwin_mcontext_avx32& o = r.GetT<__darwin_mcontext_avx32>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else if (r.IsT<const __darwin_mcontext_avx32>())
	{
		const __darwin_mcontext_avx32& o = r.GetT<const __darwin_mcontext_avx32>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mcontext_avx32>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mcontext_avx32>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mcontext_avx32>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mcontext_avx32>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mcontext_avx32>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mcontext_avx32>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mcontext_avx32_name = "__darwin_mcontext_avx32";

const std::string& Class<__darwin_mcontext_avx32>::GetName() const
{
	return __darwin_mcontext_avx32_name;
}



namespace
{
	// Object to auto-register __darwin_mcontext_avx32.
	struct __darwin_mcontext_avx32_registrar
	{
		__darwin_mcontext_avx32_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mcontext_avx32>>());
		}
	} __darwin_mcontext_avx32_instance;
}


const int Class<__darwin_mcontext_avx512_32>::FieldCount;
const int Class<__darwin_mcontext_avx512_32>::StaticFieldCount;
const int Class<__darwin_mcontext_avx512_32>::MethodCount;
const int Class<__darwin_mcontext_avx512_32>::StaticMethodCount;

int Class<__darwin_mcontext_avx512_32>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mcontext_avx512_32>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mcontext_avx512_32>())
	{
		__darwin_mcontext_avx512_32& o = r.GetT<__darwin_mcontext_avx512_32>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else if (r.IsT<const __darwin_mcontext_avx512_32>())
	{
		const __darwin_mcontext_avx512_32& o = r.GetT<const __darwin_mcontext_avx512_32>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mcontext_avx512_32>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mcontext_avx512_32>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mcontext_avx512_32>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mcontext_avx512_32>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mcontext_avx512_32>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mcontext_avx512_32>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mcontext_avx512_32_name = "__darwin_mcontext_avx512_32";

const std::string& Class<__darwin_mcontext_avx512_32>::GetName() const
{
	return __darwin_mcontext_avx512_32_name;
}



namespace
{
	// Object to auto-register __darwin_mcontext_avx512_32.
	struct __darwin_mcontext_avx512_32_registrar
	{
		__darwin_mcontext_avx512_32_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mcontext_avx512_32>>());
		}
	} __darwin_mcontext_avx512_32_instance;
}


const int Class<__darwin_mcontext64>::FieldCount;
const int Class<__darwin_mcontext64>::StaticFieldCount;
const int Class<__darwin_mcontext64>::MethodCount;
const int Class<__darwin_mcontext64>::StaticMethodCount;

int Class<__darwin_mcontext64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mcontext64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mcontext64>())
	{
		__darwin_mcontext64& o = r.GetT<__darwin_mcontext64>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else if (r.IsT<const __darwin_mcontext64>())
	{
		const __darwin_mcontext64& o = r.GetT<const __darwin_mcontext64>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mcontext64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mcontext64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mcontext64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mcontext64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mcontext64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mcontext64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mcontext64_name = "__darwin_mcontext64";

const std::string& Class<__darwin_mcontext64>::GetName() const
{
	return __darwin_mcontext64_name;
}



namespace
{
	// Object to auto-register __darwin_mcontext64.
	struct __darwin_mcontext64_registrar
	{
		__darwin_mcontext64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mcontext64>>());
		}
	} __darwin_mcontext64_instance;
}


const int Class<__darwin_mcontext_avx64>::FieldCount;
const int Class<__darwin_mcontext_avx64>::StaticFieldCount;
const int Class<__darwin_mcontext_avx64>::MethodCount;
const int Class<__darwin_mcontext_avx64>::StaticMethodCount;

int Class<__darwin_mcontext_avx64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mcontext_avx64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mcontext_avx64>())
	{
		__darwin_mcontext_avx64& o = r.GetT<__darwin_mcontext_avx64>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else if (r.IsT<const __darwin_mcontext_avx64>())
	{
		const __darwin_mcontext_avx64& o = r.GetT<const __darwin_mcontext_avx64>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mcontext_avx64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mcontext_avx64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mcontext_avx64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mcontext_avx64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mcontext_avx64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mcontext_avx64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mcontext_avx64_name = "__darwin_mcontext_avx64";

const std::string& Class<__darwin_mcontext_avx64>::GetName() const
{
	return __darwin_mcontext_avx64_name;
}



namespace
{
	// Object to auto-register __darwin_mcontext_avx64.
	struct __darwin_mcontext_avx64_registrar
	{
		__darwin_mcontext_avx64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mcontext_avx64>>());
		}
	} __darwin_mcontext_avx64_instance;
}


const int Class<__darwin_mcontext_avx512_64>::FieldCount;
const int Class<__darwin_mcontext_avx512_64>::StaticFieldCount;
const int Class<__darwin_mcontext_avx512_64>::MethodCount;
const int Class<__darwin_mcontext_avx512_64>::StaticMethodCount;

int Class<__darwin_mcontext_avx512_64>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_mcontext_avx512_64>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_mcontext_avx512_64>())
	{
		__darwin_mcontext_avx512_64& o = r.GetT<__darwin_mcontext_avx512_64>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else if (r.IsT<const __darwin_mcontext_avx512_64>())
	{
		const __darwin_mcontext_avx512_64& o = r.GetT<const __darwin_mcontext_avx512_64>();
		if (name == "__es")
		{
			return Reference(o.__es);
		}
		if (name == "__ss")
		{
			return Reference(o.__ss);
		}
		if (name == "__fs")
		{
			return Reference(o.__fs);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_mcontext_avx512_64>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_mcontext_avx512_64>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_mcontext_avx512_64>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_mcontext_avx512_64>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_mcontext_avx512_64>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_mcontext_avx512_64>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_mcontext_avx512_64_name = "__darwin_mcontext_avx512_64";

const std::string& Class<__darwin_mcontext_avx512_64>::GetName() const
{
	return __darwin_mcontext_avx512_64_name;
}



namespace
{
	// Object to auto-register __darwin_mcontext_avx512_64.
	struct __darwin_mcontext_avx512_64_registrar
	{
		__darwin_mcontext_avx512_64_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_mcontext_avx512_64>>());
		}
	} __darwin_mcontext_avx512_64_instance;
}


const int Class<__darwin_sigaltstack>::FieldCount;
const int Class<__darwin_sigaltstack>::StaticFieldCount;
const int Class<__darwin_sigaltstack>::MethodCount;
const int Class<__darwin_sigaltstack>::StaticMethodCount;

int Class<__darwin_sigaltstack>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_sigaltstack>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_sigaltstack>())
	{
		__darwin_sigaltstack& o = r.GetT<__darwin_sigaltstack>();
		if (name == "ss_sp")
		{
			return Reference(o.ss_sp);
		}
		if (name == "ss_size")
		{
			return Reference(o.ss_size);
		}
		if (name == "ss_flags")
		{
			return Reference(o.ss_flags);
		}
	}
	else if (r.IsT<const __darwin_sigaltstack>())
	{
		const __darwin_sigaltstack& o = r.GetT<const __darwin_sigaltstack>();
		if (name == "ss_sp")
		{
			return Reference(o.ss_sp);
		}
		if (name == "ss_size")
		{
			return Reference(o.ss_size);
		}
		if (name == "ss_flags")
		{
			return Reference(o.ss_flags);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_sigaltstack>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_sigaltstack>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_sigaltstack>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_sigaltstack>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_sigaltstack>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_sigaltstack>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_sigaltstack_name = "__darwin_sigaltstack";

const std::string& Class<__darwin_sigaltstack>::GetName() const
{
	return __darwin_sigaltstack_name;
}



namespace
{
	// Object to auto-register __darwin_sigaltstack.
	struct __darwin_sigaltstack_registrar
	{
		__darwin_sigaltstack_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_sigaltstack>>());
		}
	} __darwin_sigaltstack_instance;
}


const int Class<__darwin_ucontext>::FieldCount;
const int Class<__darwin_ucontext>::StaticFieldCount;
const int Class<__darwin_ucontext>::MethodCount;
const int Class<__darwin_ucontext>::StaticMethodCount;

int Class<__darwin_ucontext>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__darwin_ucontext>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__darwin_ucontext>())
	{
		__darwin_ucontext& o = r.GetT<__darwin_ucontext>();
		if (name == "uc_onstack")
		{
			return Reference(o.uc_onstack);
		}
		if (name == "uc_sigmask")
		{
			return Reference(o.uc_sigmask);
		}
		if (name == "uc_stack")
		{
			return Reference(o.uc_stack);
		}
		if (name == "uc_link")
		{
			return Reference(o.uc_link);
		}
		if (name == "uc_mcsize")
		{
			return Reference(o.uc_mcsize);
		}
		if (name == "uc_mcontext")
		{
			return Reference(o.uc_mcontext);
		}
	}
	else if (r.IsT<const __darwin_ucontext>())
	{
		const __darwin_ucontext& o = r.GetT<const __darwin_ucontext>();
		if (name == "uc_onstack")
		{
			return Reference(o.uc_onstack);
		}
		if (name == "uc_sigmask")
		{
			return Reference(o.uc_sigmask);
		}
		if (name == "uc_stack")
		{
			return Reference(o.uc_stack);
		}
		if (name == "uc_link")
		{
			return Reference(o.uc_link);
		}
		if (name == "uc_mcsize")
		{
			return Reference(o.uc_mcsize);
		}
		if (name == "uc_mcontext")
		{
			return Reference(o.uc_mcontext);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__darwin_ucontext>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__darwin_ucontext>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__darwin_ucontext>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__darwin_ucontext>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__darwin_ucontext>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__darwin_ucontext>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __darwin_ucontext_name = "__darwin_ucontext";

const std::string& Class<__darwin_ucontext>::GetName() const
{
	return __darwin_ucontext_name;
}



namespace
{
	// Object to auto-register __darwin_ucontext.
	struct __darwin_ucontext_registrar
	{
		__darwin_ucontext_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__darwin_ucontext>>());
		}
	} __darwin_ucontext_instance;
}


const int Class<sigevent>::FieldCount;
const int Class<sigevent>::StaticFieldCount;
const int Class<sigevent>::MethodCount;
const int Class<sigevent>::StaticMethodCount;

int Class<sigevent>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<sigevent>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<sigevent>())
	{
		sigevent& o = r.GetT<sigevent>();
		if (name == "sigev_notify")
		{
			return Reference(o.sigev_notify);
		}
		if (name == "sigev_signo")
		{
			return Reference(o.sigev_signo);
		}
		if (name == "sigev_value")
		{
			return Reference(o.sigev_value);
		}
		if (name == "sigev_notify_function")
		{
			return Reference(o.sigev_notify_function);
		}
		if (name == "sigev_notify_attributes")
		{
			return Reference(o.sigev_notify_attributes);
		}
	}
	else if (r.IsT<const sigevent>())
	{
		const sigevent& o = r.GetT<const sigevent>();
		if (name == "sigev_notify")
		{
			return Reference(o.sigev_notify);
		}
		if (name == "sigev_signo")
		{
			return Reference(o.sigev_signo);
		}
		if (name == "sigev_value")
		{
			return Reference(o.sigev_value);
		}
		if (name == "sigev_notify_function")
		{
			return Reference(o.sigev_notify_function);
		}
		if (name == "sigev_notify_attributes")
		{
			return Reference(o.sigev_notify_attributes);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<sigevent>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<sigevent>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<sigevent>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<sigevent>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<sigevent>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<sigevent>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string sigevent_name = "sigevent";

const std::string& Class<sigevent>::GetName() const
{
	return sigevent_name;
}



namespace
{
	// Object to auto-register sigevent.
	struct sigevent_registrar
	{
		sigevent_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<sigevent>>());
		}
	} sigevent_instance;
}


const int Class<__siginfo>::FieldCount;
const int Class<__siginfo>::StaticFieldCount;
const int Class<__siginfo>::MethodCount;
const int Class<__siginfo>::StaticMethodCount;

int Class<__siginfo>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__siginfo>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__siginfo>())
	{
		__siginfo& o = r.GetT<__siginfo>();
		if (name == "si_signo")
		{
			return Reference(o.si_signo);
		}
		if (name == "si_errno")
		{
			return Reference(o.si_errno);
		}
		if (name == "si_code")
		{
			return Reference(o.si_code);
		}
		if (name == "si_pid")
		{
			return Reference(o.si_pid);
		}
		if (name == "si_uid")
		{
			return Reference(o.si_uid);
		}
		if (name == "si_status")
		{
			return Reference(o.si_status);
		}
		if (name == "si_addr")
		{
			return Reference(o.si_addr);
		}
		if (name == "si_value")
		{
			return Reference(o.si_value);
		}
		if (name == "si_band")
		{
			return Reference(o.si_band);
		}
		if (name == "__pad")
		{
			return Reference(o.__pad);
		}
	}
	else if (r.IsT<const __siginfo>())
	{
		const __siginfo& o = r.GetT<const __siginfo>();
		if (name == "si_signo")
		{
			return Reference(o.si_signo);
		}
		if (name == "si_errno")
		{
			return Reference(o.si_errno);
		}
		if (name == "si_code")
		{
			return Reference(o.si_code);
		}
		if (name == "si_pid")
		{
			return Reference(o.si_pid);
		}
		if (name == "si_uid")
		{
			return Reference(o.si_uid);
		}
		if (name == "si_status")
		{
			return Reference(o.si_status);
		}
		if (name == "si_addr")
		{
			return Reference(o.si_addr);
		}
		if (name == "si_value")
		{
			return Reference(o.si_value);
		}
		if (name == "si_band")
		{
			return Reference(o.si_band);
		}
		if (name == "__pad")
		{
			return Reference(o.__pad);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__siginfo>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__siginfo>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__siginfo>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__siginfo>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__siginfo>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__siginfo>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __siginfo_name = "__siginfo";

const std::string& Class<__siginfo>::GetName() const
{
	return __siginfo_name;
}



namespace
{
	// Object to auto-register __siginfo.
	struct __siginfo_registrar
	{
		__siginfo_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__siginfo>>());
		}
	} __siginfo_instance;
}


const int Class<__siginfo>::FieldCount;
const int Class<__siginfo>::StaticFieldCount;
const int Class<__siginfo>::MethodCount;
const int Class<__siginfo>::StaticMethodCount;

int Class<__siginfo>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__siginfo>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__siginfo>())
	{
		__siginfo& o = r.GetT<__siginfo>();
		if (name == "si_signo")
		{
			return Reference(o.si_signo);
		}
		if (name == "si_errno")
		{
			return Reference(o.si_errno);
		}
		if (name == "si_code")
		{
			return Reference(o.si_code);
		}
		if (name == "si_pid")
		{
			return Reference(o.si_pid);
		}
		if (name == "si_uid")
		{
			return Reference(o.si_uid);
		}
		if (name == "si_status")
		{
			return Reference(o.si_status);
		}
		if (name == "si_addr")
		{
			return Reference(o.si_addr);
		}
		if (name == "si_value")
		{
			return Reference(o.si_value);
		}
		if (name == "si_band")
		{
			return Reference(o.si_band);
		}
		if (name == "__pad")
		{
			return Reference(o.__pad);
		}
	}
	else if (r.IsT<const __siginfo>())
	{
		const __siginfo& o = r.GetT<const __siginfo>();
		if (name == "si_signo")
		{
			return Reference(o.si_signo);
		}
		if (name == "si_errno")
		{
			return Reference(o.si_errno);
		}
		if (name == "si_code")
		{
			return Reference(o.si_code);
		}
		if (name == "si_pid")
		{
			return Reference(o.si_pid);
		}
		if (name == "si_uid")
		{
			return Reference(o.si_uid);
		}
		if (name == "si_status")
		{
			return Reference(o.si_status);
		}
		if (name == "si_addr")
		{
			return Reference(o.si_addr);
		}
		if (name == "si_value")
		{
			return Reference(o.si_value);
		}
		if (name == "si_band")
		{
			return Reference(o.si_band);
		}
		if (name == "__pad")
		{
			return Reference(o.__pad);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__siginfo>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__siginfo>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__siginfo>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__siginfo>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__siginfo>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__siginfo>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __siginfo_name = "__siginfo";

const std::string& Class<__siginfo>::GetName() const
{
	return __siginfo_name;
}



namespace
{
	// Object to auto-register __siginfo.
	struct __siginfo_registrar
	{
		__siginfo_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__siginfo>>());
		}
	} __siginfo_instance;
}


const int Class<__sigaction>::FieldCount;
const int Class<__sigaction>::StaticFieldCount;
const int Class<__sigaction>::MethodCount;
const int Class<__sigaction>::StaticMethodCount;

int Class<__sigaction>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__sigaction>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__sigaction>())
	{
		__sigaction& o = r.GetT<__sigaction>();
		if (name == "__sigaction_u")
		{
			return Reference(o.__sigaction_u);
		}
		if (name == "sa_tramp")
		{
			return Reference(o.sa_tramp);
		}
		if (name == "sa_mask")
		{
			return Reference(o.sa_mask);
		}
		if (name == "sa_flags")
		{
			return Reference(o.sa_flags);
		}
	}
	else if (r.IsT<const __sigaction>())
	{
		const __sigaction& o = r.GetT<const __sigaction>();
		if (name == "__sigaction_u")
		{
			return Reference(o.__sigaction_u);
		}
		if (name == "sa_tramp")
		{
			return Reference(o.sa_tramp);
		}
		if (name == "sa_mask")
		{
			return Reference(o.sa_mask);
		}
		if (name == "sa_flags")
		{
			return Reference(o.sa_flags);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__sigaction>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__sigaction>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__sigaction>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__sigaction>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__sigaction>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__sigaction>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __sigaction_name = "__sigaction";

const std::string& Class<__sigaction>::GetName() const
{
	return __sigaction_name;
}



namespace
{
	// Object to auto-register __sigaction.
	struct __sigaction_registrar
	{
		__sigaction_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__sigaction>>());
		}
	} __sigaction_instance;
}


const int Class<sigaction>::FieldCount;
const int Class<sigaction>::StaticFieldCount;
const int Class<sigaction>::MethodCount;
const int Class<sigaction>::StaticMethodCount;

int Class<sigaction>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<sigaction>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<sigaction>())
	{
		sigaction& o = r.GetT<sigaction>();
		if (name == "__sigaction_u")
		{
			return Reference(o.__sigaction_u);
		}
		if (name == "sa_mask")
		{
			return Reference(o.sa_mask);
		}
		if (name == "sa_flags")
		{
			return Reference(o.sa_flags);
		}
	}
	else if (r.IsT<const sigaction>())
	{
		const sigaction& o = r.GetT<const sigaction>();
		if (name == "__sigaction_u")
		{
			return Reference(o.__sigaction_u);
		}
		if (name == "sa_mask")
		{
			return Reference(o.sa_mask);
		}
		if (name == "sa_flags")
		{
			return Reference(o.sa_flags);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<sigaction>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<sigaction>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<sigaction>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<sigaction>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<sigaction>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<sigaction>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string sigaction_name = "sigaction";

const std::string& Class<sigaction>::GetName() const
{
	return sigaction_name;
}



namespace
{
	// Object to auto-register sigaction.
	struct sigaction_registrar
	{
		sigaction_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<sigaction>>());
		}
	} sigaction_instance;
}


const int Class<sigvec>::FieldCount;
const int Class<sigvec>::StaticFieldCount;
const int Class<sigvec>::MethodCount;
const int Class<sigvec>::StaticMethodCount;

int Class<sigvec>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<sigvec>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<sigvec>())
	{
		sigvec& o = r.GetT<sigvec>();
		if (name == "sv_handler")
		{
			return Reference(o.sv_handler);
		}
		if (name == "sv_mask")
		{
			return Reference(o.sv_mask);
		}
		if (name == "sv_flags")
		{
			return Reference(o.sv_flags);
		}
	}
	else if (r.IsT<const sigvec>())
	{
		const sigvec& o = r.GetT<const sigvec>();
		if (name == "sv_handler")
		{
			return Reference(o.sv_handler);
		}
		if (name == "sv_mask")
		{
			return Reference(o.sv_mask);
		}
		if (name == "sv_flags")
		{
			return Reference(o.sv_flags);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<sigvec>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<sigvec>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<sigvec>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<sigvec>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<sigvec>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<sigvec>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string sigvec_name = "sigvec";

const std::string& Class<sigvec>::GetName() const
{
	return sigvec_name;
}



namespace
{
	// Object to auto-register sigvec.
	struct sigvec_registrar
	{
		sigvec_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<sigvec>>());
		}
	} sigvec_instance;
}


const int Class<sigstack>::FieldCount;
const int Class<sigstack>::StaticFieldCount;
const int Class<sigstack>::MethodCount;
const int Class<sigstack>::StaticMethodCount;

int Class<sigstack>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<sigstack>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<sigstack>())
	{
		sigstack& o = r.GetT<sigstack>();
		if (name == "ss_sp")
		{
			return Reference(o.ss_sp);
		}
		if (name == "ss_onstack")
		{
			return Reference(o.ss_onstack);
		}
	}
	else if (r.IsT<const sigstack>())
	{
		const sigstack& o = r.GetT<const sigstack>();
		if (name == "ss_sp")
		{
			return Reference(o.ss_sp);
		}
		if (name == "ss_onstack")
		{
			return Reference(o.ss_onstack);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<sigstack>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<sigstack>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<sigstack>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<sigstack>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<sigstack>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<sigstack>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string sigstack_name = "sigstack";

const std::string& Class<sigstack>::GetName() const
{
	return sigstack_name;
}



namespace
{
	// Object to auto-register sigstack.
	struct sigstack_registrar
	{
		sigstack_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<sigstack>>());
		}
	} sigstack_instance;
}


int Function<void (*)(int)(*)(int, void (*)(int)), ::signal>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void (*)(int)(*)(int, void (*)(int)), ::signal>::GetReturnType() const
{
	Parameter result;
	result.type = "void (*)(int)";
	return result;
}

Parameter Function<void (*)(int)(*)(int, void (*)(int)), ::signal>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "void (*)(int)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __signal_name = "::signal";

const std::string& Function<void (*)(int)(*)(int, void (*)(int)), ::signal>::GetName() const
{
	return __signal_name;
}

Object Function<void (*)(int)(*)(int, void (*)(int)), ::signal>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::signal(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<void (*)(int)>>()));
}

namespace
{
	// Object to auto-register ::signal.
	struct __signal_registrar
	{
		__signal_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void (*)(int)(*)(int, void (*)(int)), ::signal>>());
		}
	} __signal_instance;
}



const int Class<timeval>::FieldCount;
const int Class<timeval>::StaticFieldCount;
const int Class<timeval>::MethodCount;
const int Class<timeval>::StaticMethodCount;

int Class<timeval>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<timeval>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<timeval>())
	{
		timeval& o = r.GetT<timeval>();
		if (name == "tv_sec")
		{
			return Reference(o.tv_sec);
		}
		if (name == "tv_usec")
		{
			return Reference(o.tv_usec);
		}
	}
	else if (r.IsT<const timeval>())
	{
		const timeval& o = r.GetT<const timeval>();
		if (name == "tv_sec")
		{
			return Reference(o.tv_sec);
		}
		if (name == "tv_usec")
		{
			return Reference(o.tv_usec);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<timeval>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<timeval>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<timeval>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<timeval>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<timeval>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<timeval>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string timeval_name = "timeval";

const std::string& Class<timeval>::GetName() const
{
	return timeval_name;
}



namespace
{
	// Object to auto-register timeval.
	struct timeval_registrar
	{
		timeval_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<timeval>>());
		}
	} timeval_instance;
}


const int Class<rusage>::FieldCount;
const int Class<rusage>::StaticFieldCount;
const int Class<rusage>::MethodCount;
const int Class<rusage>::StaticMethodCount;

int Class<rusage>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rusage>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rusage>())
	{
		rusage& o = r.GetT<rusage>();
		if (name == "ru_utime")
		{
			return Reference(o.ru_utime);
		}
		if (name == "ru_stime")
		{
			return Reference(o.ru_stime);
		}
		if (name == "ru_maxrss")
		{
			return Reference(o.ru_maxrss);
		}
		if (name == "ru_ixrss")
		{
			return Reference(o.ru_ixrss);
		}
		if (name == "ru_idrss")
		{
			return Reference(o.ru_idrss);
		}
		if (name == "ru_isrss")
		{
			return Reference(o.ru_isrss);
		}
		if (name == "ru_minflt")
		{
			return Reference(o.ru_minflt);
		}
		if (name == "ru_majflt")
		{
			return Reference(o.ru_majflt);
		}
		if (name == "ru_nswap")
		{
			return Reference(o.ru_nswap);
		}
		if (name == "ru_inblock")
		{
			return Reference(o.ru_inblock);
		}
		if (name == "ru_oublock")
		{
			return Reference(o.ru_oublock);
		}
		if (name == "ru_msgsnd")
		{
			return Reference(o.ru_msgsnd);
		}
		if (name == "ru_msgrcv")
		{
			return Reference(o.ru_msgrcv);
		}
		if (name == "ru_nsignals")
		{
			return Reference(o.ru_nsignals);
		}
		if (name == "ru_nvcsw")
		{
			return Reference(o.ru_nvcsw);
		}
		if (name == "ru_nivcsw")
		{
			return Reference(o.ru_nivcsw);
		}
	}
	else if (r.IsT<const rusage>())
	{
		const rusage& o = r.GetT<const rusage>();
		if (name == "ru_utime")
		{
			return Reference(o.ru_utime);
		}
		if (name == "ru_stime")
		{
			return Reference(o.ru_stime);
		}
		if (name == "ru_maxrss")
		{
			return Reference(o.ru_maxrss);
		}
		if (name == "ru_ixrss")
		{
			return Reference(o.ru_ixrss);
		}
		if (name == "ru_idrss")
		{
			return Reference(o.ru_idrss);
		}
		if (name == "ru_isrss")
		{
			return Reference(o.ru_isrss);
		}
		if (name == "ru_minflt")
		{
			return Reference(o.ru_minflt);
		}
		if (name == "ru_majflt")
		{
			return Reference(o.ru_majflt);
		}
		if (name == "ru_nswap")
		{
			return Reference(o.ru_nswap);
		}
		if (name == "ru_inblock")
		{
			return Reference(o.ru_inblock);
		}
		if (name == "ru_oublock")
		{
			return Reference(o.ru_oublock);
		}
		if (name == "ru_msgsnd")
		{
			return Reference(o.ru_msgsnd);
		}
		if (name == "ru_msgrcv")
		{
			return Reference(o.ru_msgrcv);
		}
		if (name == "ru_nsignals")
		{
			return Reference(o.ru_nsignals);
		}
		if (name == "ru_nvcsw")
		{
			return Reference(o.ru_nvcsw);
		}
		if (name == "ru_nivcsw")
		{
			return Reference(o.ru_nivcsw);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rusage>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rusage>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rusage>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rusage>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rusage>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rusage>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rusage_name = "rusage";

const std::string& Class<rusage>::GetName() const
{
	return rusage_name;
}



namespace
{
	// Object to auto-register rusage.
	struct rusage_registrar
	{
		rusage_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rusage>>());
		}
	} rusage_instance;
}


const int Class<rusage_info_v0>::FieldCount;
const int Class<rusage_info_v0>::StaticFieldCount;
const int Class<rusage_info_v0>::MethodCount;
const int Class<rusage_info_v0>::StaticMethodCount;

int Class<rusage_info_v0>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rusage_info_v0>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rusage_info_v0>())
	{
		rusage_info_v0& o = r.GetT<rusage_info_v0>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
	}
	else if (r.IsT<const rusage_info_v0>())
	{
		const rusage_info_v0& o = r.GetT<const rusage_info_v0>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rusage_info_v0>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rusage_info_v0>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rusage_info_v0>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rusage_info_v0>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rusage_info_v0>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rusage_info_v0>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rusage_info_v0_name = "rusage_info_v0";

const std::string& Class<rusage_info_v0>::GetName() const
{
	return rusage_info_v0_name;
}



namespace
{
	// Object to auto-register rusage_info_v0.
	struct rusage_info_v0_registrar
	{
		rusage_info_v0_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rusage_info_v0>>());
		}
	} rusage_info_v0_instance;
}


const int Class<rusage_info_v1>::FieldCount;
const int Class<rusage_info_v1>::StaticFieldCount;
const int Class<rusage_info_v1>::MethodCount;
const int Class<rusage_info_v1>::StaticMethodCount;

int Class<rusage_info_v1>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rusage_info_v1>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rusage_info_v1>())
	{
		rusage_info_v1& o = r.GetT<rusage_info_v1>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
	}
	else if (r.IsT<const rusage_info_v1>())
	{
		const rusage_info_v1& o = r.GetT<const rusage_info_v1>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rusage_info_v1>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rusage_info_v1>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rusage_info_v1>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rusage_info_v1>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rusage_info_v1>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rusage_info_v1>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rusage_info_v1_name = "rusage_info_v1";

const std::string& Class<rusage_info_v1>::GetName() const
{
	return rusage_info_v1_name;
}



namespace
{
	// Object to auto-register rusage_info_v1.
	struct rusage_info_v1_registrar
	{
		rusage_info_v1_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rusage_info_v1>>());
		}
	} rusage_info_v1_instance;
}


const int Class<rusage_info_v2>::FieldCount;
const int Class<rusage_info_v2>::StaticFieldCount;
const int Class<rusage_info_v2>::MethodCount;
const int Class<rusage_info_v2>::StaticMethodCount;

int Class<rusage_info_v2>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rusage_info_v2>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rusage_info_v2>())
	{
		rusage_info_v2& o = r.GetT<rusage_info_v2>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
		if (name == "ri_diskio_bytesread")
		{
			return Reference(o.ri_diskio_bytesread);
		}
		if (name == "ri_diskio_byteswritten")
		{
			return Reference(o.ri_diskio_byteswritten);
		}
	}
	else if (r.IsT<const rusage_info_v2>())
	{
		const rusage_info_v2& o = r.GetT<const rusage_info_v2>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
		if (name == "ri_diskio_bytesread")
		{
			return Reference(o.ri_diskio_bytesread);
		}
		if (name == "ri_diskio_byteswritten")
		{
			return Reference(o.ri_diskio_byteswritten);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rusage_info_v2>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rusage_info_v2>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rusage_info_v2>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rusage_info_v2>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rusage_info_v2>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rusage_info_v2>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rusage_info_v2_name = "rusage_info_v2";

const std::string& Class<rusage_info_v2>::GetName() const
{
	return rusage_info_v2_name;
}



namespace
{
	// Object to auto-register rusage_info_v2.
	struct rusage_info_v2_registrar
	{
		rusage_info_v2_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rusage_info_v2>>());
		}
	} rusage_info_v2_instance;
}


const int Class<rusage_info_v3>::FieldCount;
const int Class<rusage_info_v3>::StaticFieldCount;
const int Class<rusage_info_v3>::MethodCount;
const int Class<rusage_info_v3>::StaticMethodCount;

int Class<rusage_info_v3>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rusage_info_v3>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rusage_info_v3>())
	{
		rusage_info_v3& o = r.GetT<rusage_info_v3>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
		if (name == "ri_diskio_bytesread")
		{
			return Reference(o.ri_diskio_bytesread);
		}
		if (name == "ri_diskio_byteswritten")
		{
			return Reference(o.ri_diskio_byteswritten);
		}
		if (name == "ri_cpu_time_qos_default")
		{
			return Reference(o.ri_cpu_time_qos_default);
		}
		if (name == "ri_cpu_time_qos_maintenance")
		{
			return Reference(o.ri_cpu_time_qos_maintenance);
		}
		if (name == "ri_cpu_time_qos_background")
		{
			return Reference(o.ri_cpu_time_qos_background);
		}
		if (name == "ri_cpu_time_qos_utility")
		{
			return Reference(o.ri_cpu_time_qos_utility);
		}
		if (name == "ri_cpu_time_qos_legacy")
		{
			return Reference(o.ri_cpu_time_qos_legacy);
		}
		if (name == "ri_cpu_time_qos_user_initiated")
		{
			return Reference(o.ri_cpu_time_qos_user_initiated);
		}
		if (name == "ri_cpu_time_qos_user_interactive")
		{
			return Reference(o.ri_cpu_time_qos_user_interactive);
		}
		if (name == "ri_billed_system_time")
		{
			return Reference(o.ri_billed_system_time);
		}
		if (name == "ri_serviced_system_time")
		{
			return Reference(o.ri_serviced_system_time);
		}
	}
	else if (r.IsT<const rusage_info_v3>())
	{
		const rusage_info_v3& o = r.GetT<const rusage_info_v3>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
		if (name == "ri_diskio_bytesread")
		{
			return Reference(o.ri_diskio_bytesread);
		}
		if (name == "ri_diskio_byteswritten")
		{
			return Reference(o.ri_diskio_byteswritten);
		}
		if (name == "ri_cpu_time_qos_default")
		{
			return Reference(o.ri_cpu_time_qos_default);
		}
		if (name == "ri_cpu_time_qos_maintenance")
		{
			return Reference(o.ri_cpu_time_qos_maintenance);
		}
		if (name == "ri_cpu_time_qos_background")
		{
			return Reference(o.ri_cpu_time_qos_background);
		}
		if (name == "ri_cpu_time_qos_utility")
		{
			return Reference(o.ri_cpu_time_qos_utility);
		}
		if (name == "ri_cpu_time_qos_legacy")
		{
			return Reference(o.ri_cpu_time_qos_legacy);
		}
		if (name == "ri_cpu_time_qos_user_initiated")
		{
			return Reference(o.ri_cpu_time_qos_user_initiated);
		}
		if (name == "ri_cpu_time_qos_user_interactive")
		{
			return Reference(o.ri_cpu_time_qos_user_interactive);
		}
		if (name == "ri_billed_system_time")
		{
			return Reference(o.ri_billed_system_time);
		}
		if (name == "ri_serviced_system_time")
		{
			return Reference(o.ri_serviced_system_time);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rusage_info_v3>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rusage_info_v3>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rusage_info_v3>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rusage_info_v3>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rusage_info_v3>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rusage_info_v3>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rusage_info_v3_name = "rusage_info_v3";

const std::string& Class<rusage_info_v3>::GetName() const
{
	return rusage_info_v3_name;
}



namespace
{
	// Object to auto-register rusage_info_v3.
	struct rusage_info_v3_registrar
	{
		rusage_info_v3_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rusage_info_v3>>());
		}
	} rusage_info_v3_instance;
}


const int Class<rusage_info_v4>::FieldCount;
const int Class<rusage_info_v4>::StaticFieldCount;
const int Class<rusage_info_v4>::MethodCount;
const int Class<rusage_info_v4>::StaticMethodCount;

int Class<rusage_info_v4>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rusage_info_v4>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rusage_info_v4>())
	{
		rusage_info_v4& o = r.GetT<rusage_info_v4>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
		if (name == "ri_diskio_bytesread")
		{
			return Reference(o.ri_diskio_bytesread);
		}
		if (name == "ri_diskio_byteswritten")
		{
			return Reference(o.ri_diskio_byteswritten);
		}
		if (name == "ri_cpu_time_qos_default")
		{
			return Reference(o.ri_cpu_time_qos_default);
		}
		if (name == "ri_cpu_time_qos_maintenance")
		{
			return Reference(o.ri_cpu_time_qos_maintenance);
		}
		if (name == "ri_cpu_time_qos_background")
		{
			return Reference(o.ri_cpu_time_qos_background);
		}
		if (name == "ri_cpu_time_qos_utility")
		{
			return Reference(o.ri_cpu_time_qos_utility);
		}
		if (name == "ri_cpu_time_qos_legacy")
		{
			return Reference(o.ri_cpu_time_qos_legacy);
		}
		if (name == "ri_cpu_time_qos_user_initiated")
		{
			return Reference(o.ri_cpu_time_qos_user_initiated);
		}
		if (name == "ri_cpu_time_qos_user_interactive")
		{
			return Reference(o.ri_cpu_time_qos_user_interactive);
		}
		if (name == "ri_billed_system_time")
		{
			return Reference(o.ri_billed_system_time);
		}
		if (name == "ri_serviced_system_time")
		{
			return Reference(o.ri_serviced_system_time);
		}
		if (name == "ri_logical_writes")
		{
			return Reference(o.ri_logical_writes);
		}
		if (name == "ri_lifetime_max_phys_footprint")
		{
			return Reference(o.ri_lifetime_max_phys_footprint);
		}
		if (name == "ri_instructions")
		{
			return Reference(o.ri_instructions);
		}
		if (name == "ri_cycles")
		{
			return Reference(o.ri_cycles);
		}
		if (name == "ri_billed_energy")
		{
			return Reference(o.ri_billed_energy);
		}
		if (name == "ri_serviced_energy")
		{
			return Reference(o.ri_serviced_energy);
		}
		if (name == "ri_interval_max_phys_footprint")
		{
			return Reference(o.ri_interval_max_phys_footprint);
		}
		if (name == "ri_unused")
		{
			return Reference(o.ri_unused);
		}
	}
	else if (r.IsT<const rusage_info_v4>())
	{
		const rusage_info_v4& o = r.GetT<const rusage_info_v4>();
		if (name == "ri_uuid")
		{
			return Reference(o.ri_uuid);
		}
		if (name == "ri_user_time")
		{
			return Reference(o.ri_user_time);
		}
		if (name == "ri_system_time")
		{
			return Reference(o.ri_system_time);
		}
		if (name == "ri_pkg_idle_wkups")
		{
			return Reference(o.ri_pkg_idle_wkups);
		}
		if (name == "ri_interrupt_wkups")
		{
			return Reference(o.ri_interrupt_wkups);
		}
		if (name == "ri_pageins")
		{
			return Reference(o.ri_pageins);
		}
		if (name == "ri_wired_size")
		{
			return Reference(o.ri_wired_size);
		}
		if (name == "ri_resident_size")
		{
			return Reference(o.ri_resident_size);
		}
		if (name == "ri_phys_footprint")
		{
			return Reference(o.ri_phys_footprint);
		}
		if (name == "ri_proc_start_abstime")
		{
			return Reference(o.ri_proc_start_abstime);
		}
		if (name == "ri_proc_exit_abstime")
		{
			return Reference(o.ri_proc_exit_abstime);
		}
		if (name == "ri_child_user_time")
		{
			return Reference(o.ri_child_user_time);
		}
		if (name == "ri_child_system_time")
		{
			return Reference(o.ri_child_system_time);
		}
		if (name == "ri_child_pkg_idle_wkups")
		{
			return Reference(o.ri_child_pkg_idle_wkups);
		}
		if (name == "ri_child_interrupt_wkups")
		{
			return Reference(o.ri_child_interrupt_wkups);
		}
		if (name == "ri_child_pageins")
		{
			return Reference(o.ri_child_pageins);
		}
		if (name == "ri_child_elapsed_abstime")
		{
			return Reference(o.ri_child_elapsed_abstime);
		}
		if (name == "ri_diskio_bytesread")
		{
			return Reference(o.ri_diskio_bytesread);
		}
		if (name == "ri_diskio_byteswritten")
		{
			return Reference(o.ri_diskio_byteswritten);
		}
		if (name == "ri_cpu_time_qos_default")
		{
			return Reference(o.ri_cpu_time_qos_default);
		}
		if (name == "ri_cpu_time_qos_maintenance")
		{
			return Reference(o.ri_cpu_time_qos_maintenance);
		}
		if (name == "ri_cpu_time_qos_background")
		{
			return Reference(o.ri_cpu_time_qos_background);
		}
		if (name == "ri_cpu_time_qos_utility")
		{
			return Reference(o.ri_cpu_time_qos_utility);
		}
		if (name == "ri_cpu_time_qos_legacy")
		{
			return Reference(o.ri_cpu_time_qos_legacy);
		}
		if (name == "ri_cpu_time_qos_user_initiated")
		{
			return Reference(o.ri_cpu_time_qos_user_initiated);
		}
		if (name == "ri_cpu_time_qos_user_interactive")
		{
			return Reference(o.ri_cpu_time_qos_user_interactive);
		}
		if (name == "ri_billed_system_time")
		{
			return Reference(o.ri_billed_system_time);
		}
		if (name == "ri_serviced_system_time")
		{
			return Reference(o.ri_serviced_system_time);
		}
		if (name == "ri_logical_writes")
		{
			return Reference(o.ri_logical_writes);
		}
		if (name == "ri_lifetime_max_phys_footprint")
		{
			return Reference(o.ri_lifetime_max_phys_footprint);
		}
		if (name == "ri_instructions")
		{
			return Reference(o.ri_instructions);
		}
		if (name == "ri_cycles")
		{
			return Reference(o.ri_cycles);
		}
		if (name == "ri_billed_energy")
		{
			return Reference(o.ri_billed_energy);
		}
		if (name == "ri_serviced_energy")
		{
			return Reference(o.ri_serviced_energy);
		}
		if (name == "ri_interval_max_phys_footprint")
		{
			return Reference(o.ri_interval_max_phys_footprint);
		}
		if (name == "ri_unused")
		{
			return Reference(o.ri_unused);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rusage_info_v4>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rusage_info_v4>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rusage_info_v4>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rusage_info_v4>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rusage_info_v4>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rusage_info_v4>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rusage_info_v4_name = "rusage_info_v4";

const std::string& Class<rusage_info_v4>::GetName() const
{
	return rusage_info_v4_name;
}



namespace
{
	// Object to auto-register rusage_info_v4.
	struct rusage_info_v4_registrar
	{
		rusage_info_v4_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rusage_info_v4>>());
		}
	} rusage_info_v4_instance;
}


const int Class<rlimit>::FieldCount;
const int Class<rlimit>::StaticFieldCount;
const int Class<rlimit>::MethodCount;
const int Class<rlimit>::StaticMethodCount;

int Class<rlimit>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<rlimit>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<rlimit>())
	{
		rlimit& o = r.GetT<rlimit>();
		if (name == "rlim_cur")
		{
			return Reference(o.rlim_cur);
		}
		if (name == "rlim_max")
		{
			return Reference(o.rlim_max);
		}
	}
	else if (r.IsT<const rlimit>())
	{
		const rlimit& o = r.GetT<const rlimit>();
		if (name == "rlim_cur")
		{
			return Reference(o.rlim_cur);
		}
		if (name == "rlim_max")
		{
			return Reference(o.rlim_max);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<rlimit>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<rlimit>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<rlimit>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<rlimit>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<rlimit>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<rlimit>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string rlimit_name = "rlimit";

const std::string& Class<rlimit>::GetName() const
{
	return rlimit_name;
}



namespace
{
	// Object to auto-register rlimit.
	struct rlimit_registrar
	{
		rlimit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<rlimit>>());
		}
	} rlimit_instance;
}


const int Class<proc_rlimit_control_wakeupmon>::FieldCount;
const int Class<proc_rlimit_control_wakeupmon>::StaticFieldCount;
const int Class<proc_rlimit_control_wakeupmon>::MethodCount;
const int Class<proc_rlimit_control_wakeupmon>::StaticMethodCount;

int Class<proc_rlimit_control_wakeupmon>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<proc_rlimit_control_wakeupmon>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<proc_rlimit_control_wakeupmon>())
	{
		proc_rlimit_control_wakeupmon& o = r.GetT<proc_rlimit_control_wakeupmon>();
		if (name == "wm_flags")
		{
			return Reference(o.wm_flags);
		}
		if (name == "wm_rate")
		{
			return Reference(o.wm_rate);
		}
	}
	else if (r.IsT<const proc_rlimit_control_wakeupmon>())
	{
		const proc_rlimit_control_wakeupmon& o = r.GetT<const proc_rlimit_control_wakeupmon>();
		if (name == "wm_flags")
		{
			return Reference(o.wm_flags);
		}
		if (name == "wm_rate")
		{
			return Reference(o.wm_rate);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<proc_rlimit_control_wakeupmon>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<proc_rlimit_control_wakeupmon>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<proc_rlimit_control_wakeupmon>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<proc_rlimit_control_wakeupmon>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<proc_rlimit_control_wakeupmon>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<proc_rlimit_control_wakeupmon>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string proc_rlimit_control_wakeupmon_name = "proc_rlimit_control_wakeupmon";

const std::string& Class<proc_rlimit_control_wakeupmon>::GetName() const
{
	return proc_rlimit_control_wakeupmon_name;
}



namespace
{
	// Object to auto-register proc_rlimit_control_wakeupmon.
	struct proc_rlimit_control_wakeupmon_registrar
	{
		proc_rlimit_control_wakeupmon_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<proc_rlimit_control_wakeupmon>>());
		}
	} proc_rlimit_control_wakeupmon_instance;
}


int Function<int(*)(int, id_t), ::getpriority>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, id_t), ::getpriority>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, id_t), ::getpriority>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "id_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getpriority_name = "::getpriority";

const std::string& Function<int(*)(int, id_t), ::getpriority>::GetName() const
{
	return __getpriority_name;
}

Object Function<int(*)(int, id_t), ::getpriority>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getpriority(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<id_t>>()));
}

namespace
{
	// Object to auto-register ::getpriority.
	struct __getpriority_registrar
	{
		__getpriority_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, id_t), ::getpriority>>());
		}
	} __getpriority_instance;
}



int Function<int(*)(int, int), ::getiopolicy_np>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, int), ::getiopolicy_np>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, int), ::getiopolicy_np>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getiopolicy_np_name = "::getiopolicy_np";

const std::string& Function<int(*)(int, int), ::getiopolicy_np>::GetName() const
{
	return __getiopolicy_np_name;
}

Object Function<int(*)(int, int), ::getiopolicy_np>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getiopolicy_np(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::getiopolicy_np.
	struct __getiopolicy_np_registrar
	{
		__getiopolicy_np_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, int), ::getiopolicy_np>>());
		}
	} __getiopolicy_np_instance;
}



int Function<int(*)(int, struct rlimit *), ::getrlimit>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, struct rlimit *), ::getrlimit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, struct rlimit *), ::getrlimit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "struct rlimit *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getrlimit_name = "::getrlimit";

const std::string& Function<int(*)(int, struct rlimit *), ::getrlimit>::GetName() const
{
	return __getrlimit_name;
}

Object Function<int(*)(int, struct rlimit *), ::getrlimit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getrlimit(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<struct rlimit *>>()));
}

namespace
{
	// Object to auto-register ::getrlimit.
	struct __getrlimit_registrar
	{
		__getrlimit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, struct rlimit *), ::getrlimit>>());
		}
	} __getrlimit_instance;
}



int Function<int(*)(int, struct rusage *), ::getrusage>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, struct rusage *), ::getrusage>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, struct rusage *), ::getrusage>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "struct rusage *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getrusage_name = "::getrusage";

const std::string& Function<int(*)(int, struct rusage *), ::getrusage>::GetName() const
{
	return __getrusage_name;
}

Object Function<int(*)(int, struct rusage *), ::getrusage>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getrusage(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<struct rusage *>>()));
}

namespace
{
	// Object to auto-register ::getrusage.
	struct __getrusage_registrar
	{
		__getrusage_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, struct rusage *), ::getrusage>>());
		}
	} __getrusage_instance;
}



int Function<int(*)(int, id_t, int), ::setpriority>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(int, id_t, int), ::setpriority>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, id_t, int), ::setpriority>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "id_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setpriority_name = "::setpriority";

const std::string& Function<int(*)(int, id_t, int), ::setpriority>::GetName() const
{
	return __setpriority_name;
}

Object Function<int(*)(int, id_t, int), ::setpriority>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setpriority(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<id_t>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::setpriority.
	struct __setpriority_registrar
	{
		__setpriority_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, id_t, int), ::setpriority>>());
		}
	} __setpriority_instance;
}



int Function<int(*)(int, int, int), ::setiopolicy_np>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(int, int, int), ::setiopolicy_np>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, int, int), ::setiopolicy_np>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setiopolicy_np_name = "::setiopolicy_np";

const std::string& Function<int(*)(int, int, int), ::setiopolicy_np>::GetName() const
{
	return __setiopolicy_np_name;
}

Object Function<int(*)(int, int, int), ::setiopolicy_np>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setiopolicy_np(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::setiopolicy_np.
	struct __setiopolicy_np_registrar
	{
		__setiopolicy_np_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, int, int), ::setiopolicy_np>>());
		}
	} __setiopolicy_np_instance;
}



int Function<int(*)(int, const struct rlimit *), ::setrlimit>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, const struct rlimit *), ::setrlimit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, const struct rlimit *), ::setrlimit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const struct rlimit *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setrlimit_name = "::setrlimit";

const std::string& Function<int(*)(int, const struct rlimit *), ::setrlimit>::GetName() const
{
	return __setrlimit_name;
}

Object Function<int(*)(int, const struct rlimit *), ::setrlimit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setrlimit(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<const struct rlimit *>>()));
}

namespace
{
	// Object to auto-register ::setrlimit.
	struct __setrlimit_registrar
	{
		__setrlimit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, const struct rlimit *), ::setrlimit>>());
		}
	} __setrlimit_instance;
}



const int Class<wait>::FieldCount;
const int Class<wait>::StaticFieldCount;
const int Class<wait>::MethodCount;
const int Class<wait>::StaticMethodCount;

int Class<wait>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<wait>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<wait>())
	{
		wait& o = r.GetT<wait>();
		if (name == "w_Termsig")
		{
			return Reference(o.w_Termsig);
		}
		if (name == "w_Coredump")
		{
			return Reference(o.w_Coredump);
		}
		if (name == "w_Retcode")
		{
			return Reference(o.w_Retcode);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else if (r.IsT<const wait>())
	{
		const wait& o = r.GetT<const wait>();
		if (name == "w_Termsig")
		{
			return Reference(o.w_Termsig);
		}
		if (name == "w_Coredump")
		{
			return Reference(o.w_Coredump);
		}
		if (name == "w_Retcode")
		{
			return Reference(o.w_Retcode);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<wait>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<wait>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<wait>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<wait>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<wait>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<wait>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string wait_name = "wait";

const std::string& Class<wait>::GetName() const
{
	return wait_name;
}



namespace
{
	// Object to auto-register wait.
	struct wait_registrar
	{
		wait_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<wait>>());
		}
	} wait_instance;
}


const int Class<wait>::FieldCount;
const int Class<wait>::StaticFieldCount;
const int Class<wait>::MethodCount;
const int Class<wait>::StaticMethodCount;

int Class<wait>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<wait>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<wait>())
	{
		wait& o = r.GetT<wait>();
		if (name == "w_Termsig")
		{
			return Reference(o.w_Termsig);
		}
		if (name == "w_Coredump")
		{
			return Reference(o.w_Coredump);
		}
		if (name == "w_Retcode")
		{
			return Reference(o.w_Retcode);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else if (r.IsT<const wait>())
	{
		const wait& o = r.GetT<const wait>();
		if (name == "w_Termsig")
		{
			return Reference(o.w_Termsig);
		}
		if (name == "w_Coredump")
		{
			return Reference(o.w_Coredump);
		}
		if (name == "w_Retcode")
		{
			return Reference(o.w_Retcode);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<wait>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<wait>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<wait>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<wait>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<wait>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<wait>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string wait_name = "wait";

const std::string& Class<wait>::GetName() const
{
	return wait_name;
}



namespace
{
	// Object to auto-register wait.
	struct wait_registrar
	{
		wait_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<wait>>());
		}
	} wait_instance;
}


const int Class<wait>::FieldCount;
const int Class<wait>::StaticFieldCount;
const int Class<wait>::MethodCount;
const int Class<wait>::StaticMethodCount;

int Class<wait>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<wait>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<wait>())
	{
		wait& o = r.GetT<wait>();
		if (name == "w_Stopval")
		{
			return Reference(o.w_Stopval);
		}
		if (name == "w_Stopsig")
		{
			return Reference(o.w_Stopsig);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else if (r.IsT<const wait>())
	{
		const wait& o = r.GetT<const wait>();
		if (name == "w_Stopval")
		{
			return Reference(o.w_Stopval);
		}
		if (name == "w_Stopsig")
		{
			return Reference(o.w_Stopsig);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<wait>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<wait>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<wait>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<wait>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<wait>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<wait>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string wait_name = "wait";

const std::string& Class<wait>::GetName() const
{
	return wait_name;
}



namespace
{
	// Object to auto-register wait.
	struct wait_registrar
	{
		wait_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<wait>>());
		}
	} wait_instance;
}


const int Class<wait>::FieldCount;
const int Class<wait>::StaticFieldCount;
const int Class<wait>::MethodCount;
const int Class<wait>::StaticMethodCount;

int Class<wait>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<wait>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<wait>())
	{
		wait& o = r.GetT<wait>();
		if (name == "w_Stopval")
		{
			return Reference(o.w_Stopval);
		}
		if (name == "w_Stopsig")
		{
			return Reference(o.w_Stopsig);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else if (r.IsT<const wait>())
	{
		const wait& o = r.GetT<const wait>();
		if (name == "w_Stopval")
		{
			return Reference(o.w_Stopval);
		}
		if (name == "w_Stopsig")
		{
			return Reference(o.w_Stopsig);
		}
		if (name == "w_Filler")
		{
			return Reference(o.w_Filler);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<wait>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<wait>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<wait>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<wait>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<wait>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<wait>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string wait_name = "wait";

const std::string& Class<wait>::GetName() const
{
	return wait_name;
}



namespace
{
	// Object to auto-register wait.
	struct wait_registrar
	{
		wait_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<wait>>());
		}
	} wait_instance;
}


int Function<pid_t(*)(int *), ::wait>::GetParameterCount() const
{
	return 1;
}

Parameter Function<pid_t(*)(int *), ::wait>::GetReturnType() const
{
	Parameter result;
	result.type = "pid_t";
	return result;
}

Parameter Function<pid_t(*)(int *), ::wait>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wait_name = "::wait";

const std::string& Function<pid_t(*)(int *), ::wait>::GetName() const
{
	return __wait_name;
}

Object Function<pid_t(*)(int *), ::wait>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wait(args[0].GetT<std::decay_t<int *>>()));
}

namespace
{
	// Object to auto-register ::wait.
	struct __wait_registrar
	{
		__wait_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<pid_t(*)(int *), ::wait>>());
		}
	} __wait_instance;
}



int Function<pid_t(*)(pid_t, int *, int), ::waitpid>::GetParameterCount() const
{
	return 3;
}

Parameter Function<pid_t(*)(pid_t, int *, int), ::waitpid>::GetReturnType() const
{
	Parameter result;
	result.type = "pid_t";
	return result;
}

Parameter Function<pid_t(*)(pid_t, int *, int), ::waitpid>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "pid_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __waitpid_name = "::waitpid";

const std::string& Function<pid_t(*)(pid_t, int *, int), ::waitpid>::GetName() const
{
	return __waitpid_name;
}

Object Function<pid_t(*)(pid_t, int *, int), ::waitpid>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::waitpid(args[0].GetT<std::decay_t<pid_t>>(), args[1].GetT<std::decay_t<int *>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::waitpid.
	struct __waitpid_registrar
	{
		__waitpid_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<pid_t(*)(pid_t, int *, int), ::waitpid>>());
		}
	} __waitpid_instance;
}



int Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "idtype_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "id_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "siginfo_t *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __waitid_name = "::waitid";

const std::string& Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid>::GetName() const
{
	return __waitid_name;
}

Object Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::waitid(args[0].GetT<std::decay_t<idtype_t>>(), args[1].GetT<std::decay_t<id_t>>(), args[2].GetT<std::decay_t<siginfo_t *>>(), args[3].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::waitid.
	struct __waitid_registrar
	{
		__waitid_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(idtype_t, id_t, siginfo_t *, int), ::waitid>>());
		}
	} __waitid_instance;
}



int Function<pid_t(*)(int *, int, struct rusage *), ::wait3>::GetParameterCount() const
{
	return 3;
}

Parameter Function<pid_t(*)(int *, int, struct rusage *), ::wait3>::GetReturnType() const
{
	Parameter result;
	result.type = "pid_t";
	return result;
}

Parameter Function<pid_t(*)(int *, int, struct rusage *), ::wait3>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "struct rusage *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wait3_name = "::wait3";

const std::string& Function<pid_t(*)(int *, int, struct rusage *), ::wait3>::GetName() const
{
	return __wait3_name;
}

Object Function<pid_t(*)(int *, int, struct rusage *), ::wait3>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wait3(args[0].GetT<std::decay_t<int *>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<struct rusage *>>()));
}

namespace
{
	// Object to auto-register ::wait3.
	struct __wait3_registrar
	{
		__wait3_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<pid_t(*)(int *, int, struct rusage *), ::wait3>>());
		}
	} __wait3_instance;
}



int Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4>::GetParameterCount() const
{
	return 4;
}

Parameter Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4>::GetReturnType() const
{
	Parameter result;
	result.type = "pid_t";
	return result;
}

Parameter Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "pid_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	case 3:
		result.name = "nameless";
		result.type = "struct rusage *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wait4_name = "::wait4";

const std::string& Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4>::GetName() const
{
	return __wait4_name;
}

Object Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wait4(args[0].GetT<std::decay_t<pid_t>>(), args[1].GetT<std::decay_t<int *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<struct rusage *>>()));
}

namespace
{
	// Object to auto-register ::wait4.
	struct __wait4_registrar
	{
		__wait4_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<pid_t(*)(pid_t, int *, int, struct rusage *), ::wait4>>());
		}
	} __wait4_instance;
}



int Function<void *(*)(size_t), ::alloca>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void *(*)(size_t), ::alloca>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(size_t), ::alloca>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __alloca_name = "::alloca";

const std::string& Function<void *(*)(size_t), ::alloca>::GetName() const
{
	return __alloca_name;
}

Object Function<void *(*)(size_t), ::alloca>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::alloca(args[0].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::alloca.
	struct __alloca_registrar
	{
		__alloca_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(size_t), ::alloca>>());
		}
	} __alloca_instance;
}



int Function<void *(*)(size_t), ::malloc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void *(*)(size_t), ::malloc>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(size_t), ::malloc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __malloc_name = "::malloc";

const std::string& Function<void *(*)(size_t), ::malloc>::GetName() const
{
	return __malloc_name;
}

Object Function<void *(*)(size_t), ::malloc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::malloc(args[0].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::malloc.
	struct __malloc_registrar
	{
		__malloc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(size_t), ::malloc>>());
		}
	} __malloc_instance;
}



int Function<void *(*)(size_t, size_t), ::calloc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void *(*)(size_t, size_t), ::calloc>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(size_t, size_t), ::calloc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__count";
		result.type = "size_t";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __calloc_name = "::calloc";

const std::string& Function<void *(*)(size_t, size_t), ::calloc>::GetName() const
{
	return __calloc_name;
}

Object Function<void *(*)(size_t, size_t), ::calloc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::calloc(args[0].GetT<std::decay_t<size_t>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::calloc.
	struct __calloc_registrar
	{
		__calloc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(size_t, size_t), ::calloc>>());
		}
	} __calloc_instance;
}



int Function<void(*)(void *), ::free>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(void *), ::free>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *), ::free>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "void *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __free_name = "::free";

const std::string& Function<void(*)(void *), ::free>::GetName() const
{
	return __free_name;
}

Object Function<void(*)(void *), ::free>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::free(args[0].GetT<std::decay_t<void *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::free.
	struct __free_registrar
	{
		__free_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *), ::free>>());
		}
	} __free_instance;
}



int Function<void *(*)(void *, size_t), ::realloc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void *(*)(void *, size_t), ::realloc>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(void *, size_t), ::realloc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__ptr";
		result.type = "void *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __realloc_name = "::realloc";

const std::string& Function<void *(*)(void *, size_t), ::realloc>::GetName() const
{
	return __realloc_name;
}

Object Function<void *(*)(void *, size_t), ::realloc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::realloc(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::realloc.
	struct __realloc_registrar
	{
		__realloc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(void *, size_t), ::realloc>>());
		}
	} __realloc_instance;
}



int Function<void *(*)(size_t), ::valloc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void *(*)(size_t), ::valloc>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(size_t), ::valloc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __valloc_name = "::valloc";

const std::string& Function<void *(*)(size_t), ::valloc>::GetName() const
{
	return __valloc_name;
}

Object Function<void *(*)(size_t), ::valloc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::valloc(args[0].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::valloc.
	struct __valloc_registrar
	{
		__valloc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(size_t), ::valloc>>());
		}
	} __valloc_instance;
}



int Function<int(*)(void **, size_t, size_t), ::posix_memalign>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(void **, size_t, size_t), ::posix_memalign>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void **, size_t, size_t), ::posix_memalign>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__memptr";
		result.type = "void **";
		break;
	case 1:
		result.name = "__alignment";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __posix_memalign_name = "::posix_memalign";

const std::string& Function<int(*)(void **, size_t, size_t), ::posix_memalign>::GetName() const
{
	return __posix_memalign_name;
}

Object Function<int(*)(void **, size_t, size_t), ::posix_memalign>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::posix_memalign(args[0].GetT<std::decay_t<void **>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::posix_memalign.
	struct __posix_memalign_registrar
	{
		__posix_memalign_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void **, size_t, size_t), ::posix_memalign>>());
		}
	} __posix_memalign_instance;
}



int Function<void(*)(), ::abort>::GetParameterCount() const
{
	return 0;
}

Parameter Function<void(*)(), ::abort>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(), ::abort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __abort_name = "::abort";

const std::string& Function<void(*)(), ::abort>::GetName() const
{
	return __abort_name;
}

Object Function<void(*)(), ::abort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::abort();
	return Object();
}

namespace
{
	// Object to auto-register ::abort.
	struct __abort_registrar
	{
		__abort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(), ::abort>>());
		}
	} __abort_instance;
}



int Function<int(*)(int), ::abs>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::abs>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::abs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __abs_name = "::abs";

const std::string& Function<int(*)(int), ::abs>::GetName() const
{
	return __abs_name;
}

Object Function<int(*)(int), ::abs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::abs(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::abs.
	struct __abs_registrar
	{
		__abs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::abs>>());
		}
	} __abs_instance;
}



int Function<int(*)(void (*)()), ::atexit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(void (*)()), ::atexit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void (*)()), ::atexit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "void (*)()";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __atexit_name = "::atexit";

const std::string& Function<int(*)(void (*)()), ::atexit>::GetName() const
{
	return __atexit_name;
}

Object Function<int(*)(void (*)()), ::atexit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::atexit(args[0].GetT<std::decay_t<void (*)()>>()));
}

namespace
{
	// Object to auto-register ::atexit.
	struct __atexit_registrar
	{
		__atexit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void (*)()), ::atexit>>());
		}
	} __atexit_instance;
}



int Function<double(*)(const char *), ::atof>::GetParameterCount() const
{
	return 1;
}

Parameter Function<double(*)(const char *), ::atof>::GetReturnType() const
{
	Parameter result;
	result.type = "double";
	return result;
}

Parameter Function<double(*)(const char *), ::atof>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __atof_name = "::atof";

const std::string& Function<double(*)(const char *), ::atof>::GetName() const
{
	return __atof_name;
}

Object Function<double(*)(const char *), ::atof>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::atof(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::atof.
	struct __atof_registrar
	{
		__atof_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<double(*)(const char *), ::atof>>());
		}
	} __atof_instance;
}



int Function<int(*)(const char *), ::atoi>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::atoi>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::atoi>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __atoi_name = "::atoi";

const std::string& Function<int(*)(const char *), ::atoi>::GetName() const
{
	return __atoi_name;
}

Object Function<int(*)(const char *), ::atoi>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::atoi(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::atoi.
	struct __atoi_registrar
	{
		__atoi_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::atoi>>());
		}
	} __atoi_instance;
}



int Function<long(*)(const char *), ::atol>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long(*)(const char *), ::atol>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(const char *), ::atol>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __atol_name = "::atol";

const std::string& Function<long(*)(const char *), ::atol>::GetName() const
{
	return __atol_name;
}

Object Function<long(*)(const char *), ::atol>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::atol(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::atol.
	struct __atol_registrar
	{
		__atol_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(const char *), ::atol>>());
		}
	} __atol_instance;
}



int Function<long long(*)(const char *), ::atoll>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long long(*)(const char *), ::atoll>::GetReturnType() const
{
	Parameter result;
	result.type = "long long";
	return result;
}

Parameter Function<long long(*)(const char *), ::atoll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __atoll_name = "::atoll";

const std::string& Function<long long(*)(const char *), ::atoll>::GetName() const
{
	return __atoll_name;
}

Object Function<long long(*)(const char *), ::atoll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::atoll(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::atoll.
	struct __atoll_registrar
	{
		__atoll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long long(*)(const char *), ::atoll>>());
		}
	} __atoll_instance;
}



int Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch>::GetParameterCount() const
{
	return 5;
}

Parameter Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__key";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__base";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 4:
		result.name = "__compar";
		result.type = "int (*)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __bsearch_name = "::bsearch";

const std::string& Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch>::GetName() const
{
	return __bsearch_name;
}

Object Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::bsearch(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<size_t>>(), args[4].GetT<std::decay_t<int (*)(const void *, const void *)>>()));
}

namespace
{
	// Object to auto-register ::bsearch.
	struct __bsearch_registrar
	{
		__bsearch_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)), ::bsearch>>());
		}
	} __bsearch_instance;
}



int Function<div_t(*)(int, int), ::div>::GetParameterCount() const
{
	return 2;
}

Parameter Function<div_t(*)(int, int), ::div>::GetReturnType() const
{
	Parameter result;
	result.type = "div_t";
	return result;
}

Parameter Function<div_t(*)(int, int), ::div>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __div_name = "::div";

const std::string& Function<div_t(*)(int, int), ::div>::GetName() const
{
	return __div_name;
}

Object Function<div_t(*)(int, int), ::div>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::div(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::div.
	struct __div_registrar
	{
		__div_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<div_t(*)(int, int), ::div>>());
		}
	} __div_instance;
}



int Function<void(*)(int), ::exit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(int), ::exit>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(int), ::exit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __exit_name = "::exit";

const std::string& Function<void(*)(int), ::exit>::GetName() const
{
	return __exit_name;
}

Object Function<void(*)(int), ::exit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::exit(args[0].GetT<std::decay_t<int>>());
	return Object();
}

namespace
{
	// Object to auto-register ::exit.
	struct __exit_registrar
	{
		__exit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(int), ::exit>>());
		}
	} __exit_instance;
}



int Function<char *(*)(const char *), ::getenv>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(const char *), ::getenv>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *), ::getenv>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getenv_name = "::getenv";

const std::string& Function<char *(*)(const char *), ::getenv>::GetName() const
{
	return __getenv_name;
}

Object Function<char *(*)(const char *), ::getenv>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getenv(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::getenv.
	struct __getenv_registrar
	{
		__getenv_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *), ::getenv>>());
		}
	} __getenv_instance;
}



int Function<long(*)(long), ::labs>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long(*)(long), ::labs>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(long), ::labs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __labs_name = "::labs";

const std::string& Function<long(*)(long), ::labs>::GetName() const
{
	return __labs_name;
}

Object Function<long(*)(long), ::labs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::labs(args[0].GetT<std::decay_t<long>>()));
}

namespace
{
	// Object to auto-register ::labs.
	struct __labs_registrar
	{
		__labs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(long), ::labs>>());
		}
	} __labs_instance;
}



int Function<ldiv_t(*)(long, long), ::ldiv>::GetParameterCount() const
{
	return 2;
}

Parameter Function<ldiv_t(*)(long, long), ::ldiv>::GetReturnType() const
{
	Parameter result;
	result.type = "ldiv_t";
	return result;
}

Parameter Function<ldiv_t(*)(long, long), ::ldiv>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long";
		break;
	case 1:
		result.name = "nameless";
		result.type = "long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ldiv_name = "::ldiv";

const std::string& Function<ldiv_t(*)(long, long), ::ldiv>::GetName() const
{
	return __ldiv_name;
}

Object Function<ldiv_t(*)(long, long), ::ldiv>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ldiv(args[0].GetT<std::decay_t<long>>(), args[1].GetT<std::decay_t<long>>()));
}

namespace
{
	// Object to auto-register ::ldiv.
	struct __ldiv_registrar
	{
		__ldiv_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<ldiv_t(*)(long, long), ::ldiv>>());
		}
	} __ldiv_instance;
}



int Function<long long(*)(long long), ::llabs>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long long(*)(long long), ::llabs>::GetReturnType() const
{
	Parameter result;
	result.type = "long long";
	return result;
}

Parameter Function<long long(*)(long long), ::llabs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __llabs_name = "::llabs";

const std::string& Function<long long(*)(long long), ::llabs>::GetName() const
{
	return __llabs_name;
}

Object Function<long long(*)(long long), ::llabs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::llabs(args[0].GetT<std::decay_t<long long>>()));
}

namespace
{
	// Object to auto-register ::llabs.
	struct __llabs_registrar
	{
		__llabs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long long(*)(long long), ::llabs>>());
		}
	} __llabs_instance;
}



int Function<lldiv_t(*)(long long, long long), ::lldiv>::GetParameterCount() const
{
	return 2;
}

Parameter Function<lldiv_t(*)(long long, long long), ::lldiv>::GetReturnType() const
{
	Parameter result;
	result.type = "lldiv_t";
	return result;
}

Parameter Function<lldiv_t(*)(long long, long long), ::lldiv>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long long";
		break;
	case 1:
		result.name = "nameless";
		result.type = "long long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __lldiv_name = "::lldiv";

const std::string& Function<lldiv_t(*)(long long, long long), ::lldiv>::GetName() const
{
	return __lldiv_name;
}

Object Function<lldiv_t(*)(long long, long long), ::lldiv>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::lldiv(args[0].GetT<std::decay_t<long long>>(), args[1].GetT<std::decay_t<long long>>()));
}

namespace
{
	// Object to auto-register ::lldiv.
	struct __lldiv_registrar
	{
		__lldiv_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<lldiv_t(*)(long long, long long), ::lldiv>>());
		}
	} __lldiv_instance;
}



int Function<int(*)(const char *, size_t), ::mblen>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, size_t), ::mblen>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, size_t), ::mblen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__s";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mblen_name = "::mblen";

const std::string& Function<int(*)(const char *, size_t), ::mblen>::GetName() const
{
	return __mblen_name;
}

Object Function<int(*)(const char *, size_t), ::mblen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mblen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::mblen.
	struct __mblen_registrar
	{
		__mblen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, size_t), ::mblen>>());
		}
	} __mblen_instance;
}



int Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbstowcs_name = "::mbstowcs";

const std::string& Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs>::GetName() const
{
	return __mbstowcs_name;
}

Object Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbstowcs(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::mbstowcs.
	struct __mbstowcs_registrar
	{
		__mbstowcs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const char *, size_t), ::mbstowcs>>());
		}
	} __mbstowcs_instance;
}



int Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbtowc_name = "::mbtowc";

const std::string& Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc>::GetName() const
{
	return __mbtowc_name;
}

Object Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbtowc(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::mbtowc.
	struct __mbtowc_registrar
	{
		__mbtowc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wchar_t *, const char *, size_t), ::mbtowc>>());
		}
	} __mbtowc_instance;
}



int Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (*)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __qsort_name = "::qsort";

const std::string& Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort>::GetName() const
{
	return __qsort_name;
}

Object Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::qsort(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (*)(const void *, const void *)>>());
	return Object();
}

namespace
{
	// Object to auto-register ::qsort.
	struct __qsort_registrar
	{
		__qsort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::qsort>>());
		}
	} __qsort_instance;
}



int Function<int(*)(), ::rand>::GetParameterCount() const
{
	return 0;
}

Parameter Function<int(*)(), ::rand>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(), ::rand>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __rand_name = "::rand";

const std::string& Function<int(*)(), ::rand>::GetName() const
{
	return __rand_name;
}

Object Function<int(*)(), ::rand>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::rand());
}

namespace
{
	// Object to auto-register ::rand.
	struct __rand_registrar
	{
		__rand_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(), ::rand>>());
		}
	} __rand_instance;
}



int Function<void(*)(unsigned int), ::srand>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(unsigned int), ::srand>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(unsigned int), ::srand>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __srand_name = "::srand";

const std::string& Function<void(*)(unsigned int), ::srand>::GetName() const
{
	return __srand_name;
}

Object Function<void(*)(unsigned int), ::srand>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::srand(args[0].GetT<std::decay_t<unsigned int>>());
	return Object();
}

namespace
{
	// Object to auto-register ::srand.
	struct __srand_registrar
	{
		__srand_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(unsigned int), ::srand>>());
		}
	} __srand_instance;
}



int Function<double(*)(const char *, char **), ::strtod>::GetParameterCount() const
{
	return 2;
}

Parameter Function<double(*)(const char *, char **), ::strtod>::GetReturnType() const
{
	Parameter result;
	result.type = "double";
	return result;
}

Parameter Function<double(*)(const char *, char **), ::strtod>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtod_name = "::strtod";

const std::string& Function<double(*)(const char *, char **), ::strtod>::GetName() const
{
	return __strtod_name;
}

Object Function<double(*)(const char *, char **), ::strtod>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtod(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::strtod.
	struct __strtod_registrar
	{
		__strtod_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<double(*)(const char *, char **), ::strtod>>());
		}
	} __strtod_instance;
}



int Function<float(*)(const char *, char **), ::strtof>::GetParameterCount() const
{
	return 2;
}

Parameter Function<float(*)(const char *, char **), ::strtof>::GetReturnType() const
{
	Parameter result;
	result.type = "float";
	return result;
}

Parameter Function<float(*)(const char *, char **), ::strtof>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtof_name = "::strtof";

const std::string& Function<float(*)(const char *, char **), ::strtof>::GetName() const
{
	return __strtof_name;
}

Object Function<float(*)(const char *, char **), ::strtof>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtof(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::strtof.
	struct __strtof_registrar
	{
		__strtof_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<float(*)(const char *, char **), ::strtof>>());
		}
	} __strtof_instance;
}



int Function<long(*)(const char *, char **, int), ::strtol>::GetParameterCount() const
{
	return 3;
}

Parameter Function<long(*)(const char *, char **, int), ::strtol>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(const char *, char **, int), ::strtol>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__endptr";
		result.type = "char **";
		break;
	case 2:
		result.name = "__base";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtol_name = "::strtol";

const std::string& Function<long(*)(const char *, char **, int), ::strtol>::GetName() const
{
	return __strtol_name;
}

Object Function<long(*)(const char *, char **, int), ::strtol>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtol(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strtol.
	struct __strtol_registrar
	{
		__strtol_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(const char *, char **, int), ::strtol>>());
		}
	} __strtol_instance;
}



int Function<long double(*)(const char *, char **), ::strtold>::GetParameterCount() const
{
	return 2;
}

Parameter Function<long double(*)(const char *, char **), ::strtold>::GetReturnType() const
{
	Parameter result;
	result.type = "long double";
	return result;
}

Parameter Function<long double(*)(const char *, char **), ::strtold>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtold_name = "::strtold";

const std::string& Function<long double(*)(const char *, char **), ::strtold>::GetName() const
{
	return __strtold_name;
}

Object Function<long double(*)(const char *, char **), ::strtold>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtold(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::strtold.
	struct __strtold_registrar
	{
		__strtold_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long double(*)(const char *, char **), ::strtold>>());
		}
	} __strtold_instance;
}



int Function<long long(*)(const char *, char **, int), ::strtoll>::GetParameterCount() const
{
	return 3;
}

Parameter Function<long long(*)(const char *, char **, int), ::strtoll>::GetReturnType() const
{
	Parameter result;
	result.type = "long long";
	return result;
}

Parameter Function<long long(*)(const char *, char **, int), ::strtoll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__endptr";
		result.type = "char **";
		break;
	case 2:
		result.name = "__base";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtoll_name = "::strtoll";

const std::string& Function<long long(*)(const char *, char **, int), ::strtoll>::GetName() const
{
	return __strtoll_name;
}

Object Function<long long(*)(const char *, char **, int), ::strtoll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtoll(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strtoll.
	struct __strtoll_registrar
	{
		__strtoll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long long(*)(const char *, char **, int), ::strtoll>>());
		}
	} __strtoll_instance;
}



int Function<unsigned long(*)(const char *, char **, int), ::strtoul>::GetParameterCount() const
{
	return 3;
}

Parameter Function<unsigned long(*)(const char *, char **, int), ::strtoul>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned long";
	return result;
}

Parameter Function<unsigned long(*)(const char *, char **, int), ::strtoul>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__endptr";
		result.type = "char **";
		break;
	case 2:
		result.name = "__base";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtoul_name = "::strtoul";

const std::string& Function<unsigned long(*)(const char *, char **, int), ::strtoul>::GetName() const
{
	return __strtoul_name;
}

Object Function<unsigned long(*)(const char *, char **, int), ::strtoul>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtoul(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strtoul.
	struct __strtoul_registrar
	{
		__strtoul_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned long(*)(const char *, char **, int), ::strtoul>>());
		}
	} __strtoul_instance;
}



int Function<unsigned long long(*)(const char *, char **, int), ::strtoull>::GetParameterCount() const
{
	return 3;
}

Parameter Function<unsigned long long(*)(const char *, char **, int), ::strtoull>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned long long";
	return result;
}

Parameter Function<unsigned long long(*)(const char *, char **, int), ::strtoull>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__endptr";
		result.type = "char **";
		break;
	case 2:
		result.name = "__base";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtoull_name = "::strtoull";

const std::string& Function<unsigned long long(*)(const char *, char **, int), ::strtoull>::GetName() const
{
	return __strtoull_name;
}

Object Function<unsigned long long(*)(const char *, char **, int), ::strtoull>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtoull(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strtoull.
	struct __strtoull_registrar
	{
		__strtoull_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned long long(*)(const char *, char **, int), ::strtoull>>());
		}
	} __strtoull_instance;
}



int Function<int(*)(const char *), ::system>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::system>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::system>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __system_name = "::system";

const std::string& Function<int(*)(const char *), ::system>::GetName() const
{
	return __system_name;
}

Object Function<int(*)(const char *), ::system>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::system(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::system.
	struct __system_registrar
	{
		__system_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::system>>());
		}
	} __system_instance;
}



int Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstombs_name = "::wcstombs";

const std::string& Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs>::GetName() const
{
	return __wcstombs_name;
}

Object Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstombs(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcstombs.
	struct __wcstombs_registrar
	{
		__wcstombs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, const wchar_t *, size_t), ::wcstombs>>());
		}
	} __wcstombs_instance;
}



int Function<int(*)(char *, wchar_t), ::wctomb>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(char *, wchar_t), ::wctomb>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, wchar_t), ::wctomb>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wctomb_name = "::wctomb";

const std::string& Function<int(*)(char *, wchar_t), ::wctomb>::GetName() const
{
	return __wctomb_name;
}

Object Function<int(*)(char *, wchar_t), ::wctomb>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wctomb(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<wchar_t>>()));
}

namespace
{
	// Object to auto-register ::wctomb.
	struct __wctomb_registrar
	{
		__wctomb_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, wchar_t), ::wctomb>>());
		}
	} __wctomb_instance;
}



int Function<void(*)(int), ::_Exit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(int), ::_Exit>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(int), ::_Exit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ___Exit_name = "::_Exit";

const std::string& Function<void(*)(int), ::_Exit>::GetName() const
{
	return ___Exit_name;
}

Object Function<void(*)(int), ::_Exit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::_Exit(args[0].GetT<std::decay_t<int>>());
	return Object();
}

namespace
{
	// Object to auto-register ::_Exit.
	struct ___Exit_registrar
	{
		___Exit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(int), ::_Exit>>());
		}
	} ___Exit_instance;
}



int Function<long(*)(const char *), ::a64l>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long(*)(const char *), ::a64l>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(const char *), ::a64l>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __a64l_name = "::a64l";

const std::string& Function<long(*)(const char *), ::a64l>::GetName() const
{
	return __a64l_name;
}

Object Function<long(*)(const char *), ::a64l>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::a64l(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::a64l.
	struct __a64l_registrar
	{
		__a64l_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(const char *), ::a64l>>());
		}
	} __a64l_instance;
}



int Function<double(*)(), ::drand48>::GetParameterCount() const
{
	return 0;
}

Parameter Function<double(*)(), ::drand48>::GetReturnType() const
{
	Parameter result;
	result.type = "double";
	return result;
}

Parameter Function<double(*)(), ::drand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __drand48_name = "::drand48";

const std::string& Function<double(*)(), ::drand48>::GetName() const
{
	return __drand48_name;
}

Object Function<double(*)(), ::drand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::drand48());
}

namespace
{
	// Object to auto-register ::drand48.
	struct __drand48_registrar
	{
		__drand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<double(*)(), ::drand48>>());
		}
	} __drand48_instance;
}



int Function<char *(*)(double, int, int *, int *), ::ecvt>::GetParameterCount() const
{
	return 4;
}

Parameter Function<char *(*)(double, int, int *, int *), ::ecvt>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(double, int, int *, int *), ::ecvt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "double";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "int *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ecvt_name = "::ecvt";

const std::string& Function<char *(*)(double, int, int *, int *), ::ecvt>::GetName() const
{
	return __ecvt_name;
}

Object Function<char *(*)(double, int, int *, int *), ::ecvt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ecvt(args[0].GetT<std::decay_t<double>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<int *>>(), args[3].GetT<std::decay_t<int *>>()));
}

namespace
{
	// Object to auto-register ::ecvt.
	struct __ecvt_registrar
	{
		__ecvt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(double, int, int *, int *), ::ecvt>>());
		}
	} __ecvt_instance;
}



int Function<double(*)(unsigned short [3]), ::erand48>::GetParameterCount() const
{
	return 1;
}

Parameter Function<double(*)(unsigned short [3]), ::erand48>::GetReturnType() const
{
	Parameter result;
	result.type = "double";
	return result;
}

Parameter Function<double(*)(unsigned short [3]), ::erand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned short [3]";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __erand48_name = "::erand48";

const std::string& Function<double(*)(unsigned short [3]), ::erand48>::GetName() const
{
	return __erand48_name;
}

Object Function<double(*)(unsigned short [3]), ::erand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::erand48(args[0].GetT<std::decay_t<unsigned short [3]>>()));
}

namespace
{
	// Object to auto-register ::erand48.
	struct __erand48_registrar
	{
		__erand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<double(*)(unsigned short [3]), ::erand48>>());
		}
	} __erand48_instance;
}



int Function<char *(*)(double, int, int *, int *), ::fcvt>::GetParameterCount() const
{
	return 4;
}

Parameter Function<char *(*)(double, int, int *, int *), ::fcvt>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(double, int, int *, int *), ::fcvt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "double";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "int *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fcvt_name = "::fcvt";

const std::string& Function<char *(*)(double, int, int *, int *), ::fcvt>::GetName() const
{
	return __fcvt_name;
}

Object Function<char *(*)(double, int, int *, int *), ::fcvt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fcvt(args[0].GetT<std::decay_t<double>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<int *>>(), args[3].GetT<std::decay_t<int *>>()));
}

namespace
{
	// Object to auto-register ::fcvt.
	struct __fcvt_registrar
	{
		__fcvt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(double, int, int *, int *), ::fcvt>>());
		}
	} __fcvt_instance;
}



int Function<char *(*)(double, int, char *), ::gcvt>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(double, int, char *), ::gcvt>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(double, int, char *), ::gcvt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "double";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __gcvt_name = "::gcvt";

const std::string& Function<char *(*)(double, int, char *), ::gcvt>::GetName() const
{
	return __gcvt_name;
}

Object Function<char *(*)(double, int, char *), ::gcvt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::gcvt(args[0].GetT<std::decay_t<double>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::gcvt.
	struct __gcvt_registrar
	{
		__gcvt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(double, int, char *), ::gcvt>>());
		}
	} __gcvt_instance;
}



int Function<int(*)(char **, char *const *, char **), ::getsubopt>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char **, char *const *, char **), ::getsubopt>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char **, char *const *, char **), ::getsubopt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *const *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getsubopt_name = "::getsubopt";

const std::string& Function<int(*)(char **, char *const *, char **), ::getsubopt>::GetName() const
{
	return __getsubopt_name;
}

Object Function<int(*)(char **, char *const *, char **), ::getsubopt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getsubopt(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<char *const *>>(), args[2].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::getsubopt.
	struct __getsubopt_registrar
	{
		__getsubopt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char **, char *const *, char **), ::getsubopt>>());
		}
	} __getsubopt_instance;
}



int Function<int(*)(int), ::grantpt>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::grantpt>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::grantpt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __grantpt_name = "::grantpt";

const std::string& Function<int(*)(int), ::grantpt>::GetName() const
{
	return __grantpt_name;
}

Object Function<int(*)(int), ::grantpt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::grantpt(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::grantpt.
	struct __grantpt_registrar
	{
		__grantpt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::grantpt>>());
		}
	} __grantpt_instance;
}



int Function<char *(*)(unsigned int, char *, size_t), ::initstate>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(unsigned int, char *, size_t), ::initstate>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(unsigned int, char *, size_t), ::initstate>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __initstate_name = "::initstate";

const std::string& Function<char *(*)(unsigned int, char *, size_t), ::initstate>::GetName() const
{
	return __initstate_name;
}

Object Function<char *(*)(unsigned int, char *, size_t), ::initstate>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::initstate(args[0].GetT<std::decay_t<unsigned int>>(), args[1].GetT<std::decay_t<char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::initstate.
	struct __initstate_registrar
	{
		__initstate_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(unsigned int, char *, size_t), ::initstate>>());
		}
	} __initstate_instance;
}



int Function<long(*)(unsigned short [3]), ::jrand48>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long(*)(unsigned short [3]), ::jrand48>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(unsigned short [3]), ::jrand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned short [3]";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __jrand48_name = "::jrand48";

const std::string& Function<long(*)(unsigned short [3]), ::jrand48>::GetName() const
{
	return __jrand48_name;
}

Object Function<long(*)(unsigned short [3]), ::jrand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::jrand48(args[0].GetT<std::decay_t<unsigned short [3]>>()));
}

namespace
{
	// Object to auto-register ::jrand48.
	struct __jrand48_registrar
	{
		__jrand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(unsigned short [3]), ::jrand48>>());
		}
	} __jrand48_instance;
}



int Function<char *(*)(long), ::l64a>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(long), ::l64a>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(long), ::l64a>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __l64a_name = "::l64a";

const std::string& Function<char *(*)(long), ::l64a>::GetName() const
{
	return __l64a_name;
}

Object Function<char *(*)(long), ::l64a>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::l64a(args[0].GetT<std::decay_t<long>>()));
}

namespace
{
	// Object to auto-register ::l64a.
	struct __l64a_registrar
	{
		__l64a_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(long), ::l64a>>());
		}
	} __l64a_instance;
}



int Function<void(*)(unsigned short [7]), ::lcong48>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(unsigned short [7]), ::lcong48>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(unsigned short [7]), ::lcong48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned short [7]";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __lcong48_name = "::lcong48";

const std::string& Function<void(*)(unsigned short [7]), ::lcong48>::GetName() const
{
	return __lcong48_name;
}

Object Function<void(*)(unsigned short [7]), ::lcong48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::lcong48(args[0].GetT<std::decay_t<unsigned short [7]>>());
	return Object();
}

namespace
{
	// Object to auto-register ::lcong48.
	struct __lcong48_registrar
	{
		__lcong48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(unsigned short [7]), ::lcong48>>());
		}
	} __lcong48_instance;
}



int Function<long(*)(), ::lrand48>::GetParameterCount() const
{
	return 0;
}

Parameter Function<long(*)(), ::lrand48>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(), ::lrand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __lrand48_name = "::lrand48";

const std::string& Function<long(*)(), ::lrand48>::GetName() const
{
	return __lrand48_name;
}

Object Function<long(*)(), ::lrand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::lrand48());
}

namespace
{
	// Object to auto-register ::lrand48.
	struct __lrand48_registrar
	{
		__lrand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(), ::lrand48>>());
		}
	} __lrand48_instance;
}



int Function<char *(*)(char *), ::mktemp>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(char *), ::mktemp>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *), ::mktemp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mktemp_name = "::mktemp";

const std::string& Function<char *(*)(char *), ::mktemp>::GetName() const
{
	return __mktemp_name;
}

Object Function<char *(*)(char *), ::mktemp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mktemp(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::mktemp.
	struct __mktemp_registrar
	{
		__mktemp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *), ::mktemp>>());
		}
	} __mktemp_instance;
}



int Function<int(*)(char *), ::mkstemp>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(char *), ::mkstemp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *), ::mkstemp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mkstemp_name = "::mkstemp";

const std::string& Function<int(*)(char *), ::mkstemp>::GetName() const
{
	return __mkstemp_name;
}

Object Function<int(*)(char *), ::mkstemp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mkstemp(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::mkstemp.
	struct __mkstemp_registrar
	{
		__mkstemp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *), ::mkstemp>>());
		}
	} __mkstemp_instance;
}



int Function<long(*)(), ::mrand48>::GetParameterCount() const
{
	return 0;
}

Parameter Function<long(*)(), ::mrand48>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(), ::mrand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __mrand48_name = "::mrand48";

const std::string& Function<long(*)(), ::mrand48>::GetName() const
{
	return __mrand48_name;
}

Object Function<long(*)(), ::mrand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mrand48());
}

namespace
{
	// Object to auto-register ::mrand48.
	struct __mrand48_registrar
	{
		__mrand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(), ::mrand48>>());
		}
	} __mrand48_instance;
}



int Function<long(*)(unsigned short [3]), ::nrand48>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long(*)(unsigned short [3]), ::nrand48>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(unsigned short [3]), ::nrand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned short [3]";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __nrand48_name = "::nrand48";

const std::string& Function<long(*)(unsigned short [3]), ::nrand48>::GetName() const
{
	return __nrand48_name;
}

Object Function<long(*)(unsigned short [3]), ::nrand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::nrand48(args[0].GetT<std::decay_t<unsigned short [3]>>()));
}

namespace
{
	// Object to auto-register ::nrand48.
	struct __nrand48_registrar
	{
		__nrand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(unsigned short [3]), ::nrand48>>());
		}
	} __nrand48_instance;
}



int Function<int(*)(int), ::posix_openpt>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::posix_openpt>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::posix_openpt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __posix_openpt_name = "::posix_openpt";

const std::string& Function<int(*)(int), ::posix_openpt>::GetName() const
{
	return __posix_openpt_name;
}

Object Function<int(*)(int), ::posix_openpt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::posix_openpt(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::posix_openpt.
	struct __posix_openpt_registrar
	{
		__posix_openpt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::posix_openpt>>());
		}
	} __posix_openpt_instance;
}



int Function<char *(*)(int), ::ptsname>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(int), ::ptsname>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(int), ::ptsname>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ptsname_name = "::ptsname";

const std::string& Function<char *(*)(int), ::ptsname>::GetName() const
{
	return __ptsname_name;
}

Object Function<char *(*)(int), ::ptsname>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ptsname(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::ptsname.
	struct __ptsname_registrar
	{
		__ptsname_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(int), ::ptsname>>());
		}
	} __ptsname_instance;
}



int Function<int(*)(int, char *, size_t), ::ptsname_r>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(int, char *, size_t), ::ptsname_r>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, char *, size_t), ::ptsname_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "fildes";
		result.type = "int";
		break;
	case 1:
		result.name = "buffer";
		result.type = "char *";
		break;
	case 2:
		result.name = "buflen";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ptsname_r_name = "::ptsname_r";

const std::string& Function<int(*)(int, char *, size_t), ::ptsname_r>::GetName() const
{
	return __ptsname_r_name;
}

Object Function<int(*)(int, char *, size_t), ::ptsname_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ptsname_r(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<char *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::ptsname_r.
	struct __ptsname_r_registrar
	{
		__ptsname_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, char *, size_t), ::ptsname_r>>());
		}
	} __ptsname_r_instance;
}



int Function<int(*)(char *), ::putenv>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(char *), ::putenv>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *), ::putenv>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putenv_name = "::putenv";

const std::string& Function<int(*)(char *), ::putenv>::GetName() const
{
	return __putenv_name;
}

Object Function<int(*)(char *), ::putenv>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putenv(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::putenv.
	struct __putenv_registrar
	{
		__putenv_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *), ::putenv>>());
		}
	} __putenv_instance;
}



int Function<long(*)(), ::random>::GetParameterCount() const
{
	return 0;
}

Parameter Function<long(*)(), ::random>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(), ::random>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __random_name = "::random";

const std::string& Function<long(*)(), ::random>::GetName() const
{
	return __random_name;
}

Object Function<long(*)(), ::random>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::random());
}

namespace
{
	// Object to auto-register ::random.
	struct __random_registrar
	{
		__random_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(), ::random>>());
		}
	} __random_instance;
}



int Function<int(*)(unsigned int *), ::rand_r>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(unsigned int *), ::rand_r>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(unsigned int *), ::rand_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned int *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __rand_r_name = "::rand_r";

const std::string& Function<int(*)(unsigned int *), ::rand_r>::GetName() const
{
	return __rand_r_name;
}

Object Function<int(*)(unsigned int *), ::rand_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::rand_r(args[0].GetT<std::decay_t<unsigned int *>>()));
}

namespace
{
	// Object to auto-register ::rand_r.
	struct __rand_r_registrar
	{
		__rand_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(unsigned int *), ::rand_r>>());
		}
	} __rand_r_instance;
}



int Function<char *(*)(const char *, char *), ::realpath>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, char *), ::realpath>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, char *), ::realpath>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __realpath_name = "::realpath";

const std::string& Function<char *(*)(const char *, char *), ::realpath>::GetName() const
{
	return __realpath_name;
}

Object Function<char *(*)(const char *, char *), ::realpath>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::realpath(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::realpath.
	struct __realpath_registrar
	{
		__realpath_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, char *), ::realpath>>());
		}
	} __realpath_instance;
}



int Function<unsigned short *(*)(unsigned short [3]), ::seed48>::GetParameterCount() const
{
	return 1;
}

Parameter Function<unsigned short *(*)(unsigned short [3]), ::seed48>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned short *";
	return result;
}

Parameter Function<unsigned short *(*)(unsigned short [3]), ::seed48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned short [3]";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __seed48_name = "::seed48";

const std::string& Function<unsigned short *(*)(unsigned short [3]), ::seed48>::GetName() const
{
	return __seed48_name;
}

Object Function<unsigned short *(*)(unsigned short [3]), ::seed48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::seed48(args[0].GetT<std::decay_t<unsigned short [3]>>()));
}

namespace
{
	// Object to auto-register ::seed48.
	struct __seed48_registrar
	{
		__seed48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned short *(*)(unsigned short [3]), ::seed48>>());
		}
	} __seed48_instance;
}



int Function<int(*)(const char *, const char *, int), ::setenv>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const char *, const char *, int), ::setenv>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *, int), ::setenv>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__name";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__value";
		result.type = "const char *";
		break;
	case 2:
		result.name = "__overwrite";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setenv_name = "::setenv";

const std::string& Function<int(*)(const char *, const char *, int), ::setenv>::GetName() const
{
	return __setenv_name;
}

Object Function<int(*)(const char *, const char *, int), ::setenv>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setenv(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::setenv.
	struct __setenv_registrar
	{
		__setenv_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *, int), ::setenv>>());
		}
	} __setenv_instance;
}



int Function<void(*)(const char *), ::setkey>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(const char *), ::setkey>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(const char *), ::setkey>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setkey_name = "::setkey";

const std::string& Function<void(*)(const char *), ::setkey>::GetName() const
{
	return __setkey_name;
}

Object Function<void(*)(const char *), ::setkey>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::setkey(args[0].GetT<std::decay_t<const char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::setkey.
	struct __setkey_registrar
	{
		__setkey_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(const char *), ::setkey>>());
		}
	} __setkey_instance;
}



int Function<char *(*)(const char *), ::setstate>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(const char *), ::setstate>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *), ::setstate>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setstate_name = "::setstate";

const std::string& Function<char *(*)(const char *), ::setstate>::GetName() const
{
	return __setstate_name;
}

Object Function<char *(*)(const char *), ::setstate>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setstate(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::setstate.
	struct __setstate_registrar
	{
		__setstate_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *), ::setstate>>());
		}
	} __setstate_instance;
}



int Function<void(*)(long), ::srand48>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(long), ::srand48>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(long), ::srand48>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __srand48_name = "::srand48";

const std::string& Function<void(*)(long), ::srand48>::GetName() const
{
	return __srand48_name;
}

Object Function<void(*)(long), ::srand48>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::srand48(args[0].GetT<std::decay_t<long>>());
	return Object();
}

namespace
{
	// Object to auto-register ::srand48.
	struct __srand48_registrar
	{
		__srand48_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(long), ::srand48>>());
		}
	} __srand48_instance;
}



int Function<void(*)(unsigned int), ::srandom>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(unsigned int), ::srandom>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(unsigned int), ::srandom>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __srandom_name = "::srandom";

const std::string& Function<void(*)(unsigned int), ::srandom>::GetName() const
{
	return __srandom_name;
}

Object Function<void(*)(unsigned int), ::srandom>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::srandom(args[0].GetT<std::decay_t<unsigned int>>());
	return Object();
}

namespace
{
	// Object to auto-register ::srandom.
	struct __srandom_registrar
	{
		__srandom_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(unsigned int), ::srandom>>());
		}
	} __srandom_instance;
}



int Function<int(*)(int), ::unlockpt>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::unlockpt>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::unlockpt>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __unlockpt_name = "::unlockpt";

const std::string& Function<int(*)(int), ::unlockpt>::GetName() const
{
	return __unlockpt_name;
}

Object Function<int(*)(int), ::unlockpt>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::unlockpt(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::unlockpt.
	struct __unlockpt_registrar
	{
		__unlockpt_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::unlockpt>>());
		}
	} __unlockpt_instance;
}



int Function<int(*)(const char *), ::unsetenv>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::unsetenv>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::unsetenv>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __unsetenv_name = "::unsetenv";

const std::string& Function<int(*)(const char *), ::unsetenv>::GetName() const
{
	return __unsetenv_name;
}

Object Function<int(*)(const char *), ::unsetenv>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::unsetenv(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::unsetenv.
	struct __unsetenv_registrar
	{
		__unsetenv_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::unsetenv>>());
		}
	} __unsetenv_instance;
}



int Function<uint32_t(*)(), ::arc4random>::GetParameterCount() const
{
	return 0;
}

Parameter Function<uint32_t(*)(), ::arc4random>::GetReturnType() const
{
	Parameter result;
	result.type = "uint32_t";
	return result;
}

Parameter Function<uint32_t(*)(), ::arc4random>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __arc4random_name = "::arc4random";

const std::string& Function<uint32_t(*)(), ::arc4random>::GetName() const
{
	return __arc4random_name;
}

Object Function<uint32_t(*)(), ::arc4random>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::arc4random());
}

namespace
{
	// Object to auto-register ::arc4random.
	struct __arc4random_registrar
	{
		__arc4random_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<uint32_t(*)(), ::arc4random>>());
		}
	} __arc4random_instance;
}



int Function<void(*)(unsigned char *, int), ::arc4random_addrandom>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(unsigned char *, int), ::arc4random_addrandom>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(unsigned char *, int), ::arc4random_addrandom>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "unsigned char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __arc4random_addrandom_name = "::arc4random_addrandom";

const std::string& Function<void(*)(unsigned char *, int), ::arc4random_addrandom>::GetName() const
{
	return __arc4random_addrandom_name;
}

Object Function<void(*)(unsigned char *, int), ::arc4random_addrandom>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::arc4random_addrandom(args[0].GetT<std::decay_t<unsigned char *>>(), args[1].GetT<std::decay_t<int>>());
	return Object();
}

namespace
{
	// Object to auto-register ::arc4random_addrandom.
	struct __arc4random_addrandom_registrar
	{
		__arc4random_addrandom_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(unsigned char *, int), ::arc4random_addrandom>>());
		}
	} __arc4random_addrandom_instance;
}



int Function<void(*)(void *, size_t), ::arc4random_buf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(void *, size_t), ::arc4random_buf>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t), ::arc4random_buf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__buf";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nbytes";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __arc4random_buf_name = "::arc4random_buf";

const std::string& Function<void(*)(void *, size_t), ::arc4random_buf>::GetName() const
{
	return __arc4random_buf_name;
}

Object Function<void(*)(void *, size_t), ::arc4random_buf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::arc4random_buf(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register ::arc4random_buf.
	struct __arc4random_buf_registrar
	{
		__arc4random_buf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t), ::arc4random_buf>>());
		}
	} __arc4random_buf_instance;
}



int Function<void(*)(), ::arc4random_stir>::GetParameterCount() const
{
	return 0;
}

Parameter Function<void(*)(), ::arc4random_stir>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(), ::arc4random_stir>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __arc4random_stir_name = "::arc4random_stir";

const std::string& Function<void(*)(), ::arc4random_stir>::GetName() const
{
	return __arc4random_stir_name;
}

Object Function<void(*)(), ::arc4random_stir>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::arc4random_stir();
	return Object();
}

namespace
{
	// Object to auto-register ::arc4random_stir.
	struct __arc4random_stir_registrar
	{
		__arc4random_stir_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(), ::arc4random_stir>>());
		}
	} __arc4random_stir_instance;
}



int Function<uint32_t(*)(uint32_t), ::arc4random_uniform>::GetParameterCount() const
{
	return 1;
}

Parameter Function<uint32_t(*)(uint32_t), ::arc4random_uniform>::GetReturnType() const
{
	Parameter result;
	result.type = "uint32_t";
	return result;
}

Parameter Function<uint32_t(*)(uint32_t), ::arc4random_uniform>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__upper_bound";
		result.type = "uint32_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __arc4random_uniform_name = "::arc4random_uniform";

const std::string& Function<uint32_t(*)(uint32_t), ::arc4random_uniform>::GetName() const
{
	return __arc4random_uniform_name;
}

Object Function<uint32_t(*)(uint32_t), ::arc4random_uniform>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::arc4random_uniform(args[0].GetT<std::decay_t<uint32_t>>()));
}

namespace
{
	// Object to auto-register ::arc4random_uniform.
	struct __arc4random_uniform_registrar
	{
		__arc4random_uniform_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<uint32_t(*)(uint32_t), ::arc4random_uniform>>());
		}
	} __arc4random_uniform_instance;
}



int Function<int(*)(void (^)()), ::atexit_b>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(void (^)()), ::atexit_b>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void (^)()), ::atexit_b>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "void (^)()";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __atexit_b_name = "::atexit_b";

const std::string& Function<int(*)(void (^)()), ::atexit_b>::GetName() const
{
	return __atexit_b_name;
}

Object Function<int(*)(void (^)()), ::atexit_b>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::atexit_b(args[0].GetT<std::decay_t<void (^)()>>()));
}

namespace
{
	// Object to auto-register ::atexit_b.
	struct __atexit_b_registrar
	{
		__atexit_b_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void (^)()), ::atexit_b>>());
		}
	} __atexit_b_instance;
}



int Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b>::GetParameterCount() const
{
	return 5;
}

Parameter Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__key";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__base";
		result.type = "const void *";
		break;
	case 2:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 4:
		result.name = "__compar";
		result.type = "int (^)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __bsearch_b_name = "::bsearch_b";

const std::string& Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b>::GetName() const
{
	return __bsearch_b_name;
}

Object Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::bsearch_b(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<const void *>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<size_t>>(), args[4].GetT<std::decay_t<int (^)(const void *, const void *)>>()));
}

namespace
{
	// Object to auto-register ::bsearch_b.
	struct __bsearch_b_registrar
	{
		__bsearch_b_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)), ::bsearch_b>>());
		}
	} __bsearch_b_instance;
}



int Function<char *(*)(char *, const char *, int), ::cgetcap>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(char *, const char *, int), ::cgetcap>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, const char *, int), ::cgetcap>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetcap_name = "::cgetcap";

const std::string& Function<char *(*)(char *, const char *, int), ::cgetcap>::GetName() const
{
	return __cgetcap_name;
}

Object Function<char *(*)(char *, const char *, int), ::cgetcap>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetcap(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::cgetcap.
	struct __cgetcap_registrar
	{
		__cgetcap_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, const char *, int), ::cgetcap>>());
		}
	} __cgetcap_instance;
}



int Function<int(*)(), ::cgetclose>::GetParameterCount() const
{
	return 0;
}

Parameter Function<int(*)(), ::cgetclose>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(), ::cgetclose>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __cgetclose_name = "::cgetclose";

const std::string& Function<int(*)(), ::cgetclose>::GetName() const
{
	return __cgetclose_name;
}

Object Function<int(*)(), ::cgetclose>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetclose());
}

namespace
{
	// Object to auto-register ::cgetclose.
	struct __cgetclose_registrar
	{
		__cgetclose_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(), ::cgetclose>>());
		}
	} __cgetclose_instance;
}



int Function<int(*)(char **, char **, const char *), ::cgetent>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char **, char **, const char *), ::cgetent>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char **, char **, const char *), ::cgetent>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetent_name = "::cgetent";

const std::string& Function<int(*)(char **, char **, const char *), ::cgetent>::GetName() const
{
	return __cgetent_name;
}

Object Function<int(*)(char **, char **, const char *), ::cgetent>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetent(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::cgetent.
	struct __cgetent_registrar
	{
		__cgetent_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char **, char **, const char *), ::cgetent>>());
		}
	} __cgetent_instance;
}



int Function<int(*)(char **, char **), ::cgetfirst>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(char **, char **), ::cgetfirst>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char **, char **), ::cgetfirst>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetfirst_name = "::cgetfirst";

const std::string& Function<int(*)(char **, char **), ::cgetfirst>::GetName() const
{
	return __cgetfirst_name;
}

Object Function<int(*)(char **, char **), ::cgetfirst>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetfirst(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::cgetfirst.
	struct __cgetfirst_registrar
	{
		__cgetfirst_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char **, char **), ::cgetfirst>>());
		}
	} __cgetfirst_instance;
}



int Function<int(*)(const char *, const char *), ::cgetmatch>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, const char *), ::cgetmatch>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *), ::cgetmatch>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetmatch_name = "::cgetmatch";

const std::string& Function<int(*)(const char *, const char *), ::cgetmatch>::GetName() const
{
	return __cgetmatch_name;
}

Object Function<int(*)(const char *, const char *), ::cgetmatch>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetmatch(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::cgetmatch.
	struct __cgetmatch_registrar
	{
		__cgetmatch_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *), ::cgetmatch>>());
		}
	} __cgetmatch_instance;
}



int Function<int(*)(char **, char **), ::cgetnext>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(char **, char **), ::cgetnext>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char **, char **), ::cgetnext>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetnext_name = "::cgetnext";

const std::string& Function<int(*)(char **, char **), ::cgetnext>::GetName() const
{
	return __cgetnext_name;
}

Object Function<int(*)(char **, char **), ::cgetnext>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetnext(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::cgetnext.
	struct __cgetnext_registrar
	{
		__cgetnext_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char **, char **), ::cgetnext>>());
		}
	} __cgetnext_instance;
}



int Function<int(*)(char *, const char *, long *), ::cgetnum>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char *, const char *, long *), ::cgetnum>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, const char *, long *), ::cgetnum>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "long *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetnum_name = "::cgetnum";

const std::string& Function<int(*)(char *, const char *, long *), ::cgetnum>::GetName() const
{
	return __cgetnum_name;
}

Object Function<int(*)(char *, const char *, long *), ::cgetnum>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetnum(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<long *>>()));
}

namespace
{
	// Object to auto-register ::cgetnum.
	struct __cgetnum_registrar
	{
		__cgetnum_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, const char *, long *), ::cgetnum>>());
		}
	} __cgetnum_instance;
}



int Function<int(*)(const char *), ::cgetset>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::cgetset>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::cgetset>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetset_name = "::cgetset";

const std::string& Function<int(*)(const char *), ::cgetset>::GetName() const
{
	return __cgetset_name;
}

Object Function<int(*)(const char *), ::cgetset>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetset(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::cgetset.
	struct __cgetset_registrar
	{
		__cgetset_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::cgetset>>());
		}
	} __cgetset_instance;
}



int Function<int(*)(char *, const char *, char **), ::cgetstr>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char *, const char *, char **), ::cgetstr>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, const char *, char **), ::cgetstr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetstr_name = "::cgetstr";

const std::string& Function<int(*)(char *, const char *, char **), ::cgetstr>::GetName() const
{
	return __cgetstr_name;
}

Object Function<int(*)(char *, const char *, char **), ::cgetstr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetstr(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::cgetstr.
	struct __cgetstr_registrar
	{
		__cgetstr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, const char *, char **), ::cgetstr>>());
		}
	} __cgetstr_instance;
}



int Function<int(*)(char *, const char *, char **), ::cgetustr>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char *, const char *, char **), ::cgetustr>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, const char *, char **), ::cgetustr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "char **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __cgetustr_name = "::cgetustr";

const std::string& Function<int(*)(char *, const char *, char **), ::cgetustr>::GetName() const
{
	return __cgetustr_name;
}

Object Function<int(*)(char *, const char *, char **), ::cgetustr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::cgetustr(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<char **>>()));
}

namespace
{
	// Object to auto-register ::cgetustr.
	struct __cgetustr_registrar
	{
		__cgetustr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, const char *, char **), ::cgetustr>>());
		}
	} __cgetustr_instance;
}



int Function<int(*)(int, int), ::daemon>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, int), ::daemon>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, int), ::daemon>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __daemon_name = "::daemon";

const std::string& Function<int(*)(int, int), ::daemon>::GetName() const
{
	return __daemon_name;
}

Object Function<int(*)(int, int), ::daemon>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::daemon(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::daemon.
	struct __daemon_registrar
	{
		__daemon_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, int), ::daemon>>());
		}
	} __daemon_instance;
}



int Function<char *(*)(dev_t, mode_t), ::devname>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(dev_t, mode_t), ::devname>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(dev_t, mode_t), ::devname>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "dev_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "mode_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __devname_name = "::devname";

const std::string& Function<char *(*)(dev_t, mode_t), ::devname>::GetName() const
{
	return __devname_name;
}

Object Function<char *(*)(dev_t, mode_t), ::devname>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::devname(args[0].GetT<std::decay_t<dev_t>>(), args[1].GetT<std::decay_t<mode_t>>()));
}

namespace
{
	// Object to auto-register ::devname.
	struct __devname_registrar
	{
		__devname_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(dev_t, mode_t), ::devname>>());
		}
	} __devname_instance;
}



int Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r>::GetParameterCount() const
{
	return 4;
}

Parameter Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "dev_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "mode_t";
		break;
	case 2:
		result.name = "buf";
		result.type = "char *";
		break;
	case 3:
		result.name = "len";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __devname_r_name = "::devname_r";

const std::string& Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r>::GetName() const
{
	return __devname_r_name;
}

Object Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::devname_r(args[0].GetT<std::decay_t<dev_t>>(), args[1].GetT<std::decay_t<mode_t>>(), args[2].GetT<std::decay_t<char *>>(), args[3].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::devname_r.
	struct __devname_r_registrar
	{
		__devname_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(dev_t, mode_t, char *, int), ::devname_r>>());
		}
	} __devname_r_instance;
}



int Function<char *(*)(int *, long *), ::getbsize>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(int *, long *), ::getbsize>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(int *, long *), ::getbsize>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "long *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getbsize_name = "::getbsize";

const std::string& Function<char *(*)(int *, long *), ::getbsize>::GetName() const
{
	return __getbsize_name;
}

Object Function<char *(*)(int *, long *), ::getbsize>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getbsize(args[0].GetT<std::decay_t<int *>>(), args[1].GetT<std::decay_t<long *>>()));
}

namespace
{
	// Object to auto-register ::getbsize.
	struct __getbsize_registrar
	{
		__getbsize_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(int *, long *), ::getbsize>>());
		}
	} __getbsize_instance;
}



int Function<int(*)(double [], int), ::getloadavg>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(double [], int), ::getloadavg>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(double [], int), ::getloadavg>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "double []";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getloadavg_name = "::getloadavg";

const std::string& Function<int(*)(double [], int), ::getloadavg>::GetName() const
{
	return __getloadavg_name;
}

Object Function<int(*)(double [], int), ::getloadavg>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getloadavg(args[0].GetT<std::decay_t<double []>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::getloadavg.
	struct __getloadavg_registrar
	{
		__getloadavg_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(double [], int), ::getloadavg>>());
		}
	} __getloadavg_instance;
}



int Function<const char *(*)(), ::getprogname>::GetParameterCount() const
{
	return 0;
}

Parameter Function<const char *(*)(), ::getprogname>::GetReturnType() const
{
	Parameter result;
	result.type = "const char *";
	return result;
}

Parameter Function<const char *(*)(), ::getprogname>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __getprogname_name = "::getprogname";

const std::string& Function<const char *(*)(), ::getprogname>::GetName() const
{
	return __getprogname_name;
}

Object Function<const char *(*)(), ::getprogname>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getprogname());
}

namespace
{
	// Object to auto-register ::getprogname.
	struct __getprogname_registrar
	{
		__getprogname_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<const char *(*)(), ::getprogname>>());
		}
	} __getprogname_instance;
}



int Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (*)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __heapsort_name = "::heapsort";

const std::string& Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort>::GetName() const
{
	return __heapsort_name;
}

Object Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::heapsort(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (*)(const void *, const void *)>>()));
}

namespace
{
	// Object to auto-register ::heapsort.
	struct __heapsort_registrar
	{
		__heapsort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::heapsort>>());
		}
	} __heapsort_instance;
}



int Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (^)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __heapsort_b_name = "::heapsort_b";

const std::string& Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b>::GetName() const
{
	return __heapsort_b_name;
}

Object Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::heapsort_b(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (^)(const void *, const void *)>>()));
}

namespace
{
	// Object to auto-register ::heapsort_b.
	struct __heapsort_b_registrar
	{
		__heapsort_b_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::heapsort_b>>());
		}
	} __heapsort_b_instance;
}



int Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (*)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mergesort_name = "::mergesort";

const std::string& Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort>::GetName() const
{
	return __mergesort_name;
}

Object Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mergesort(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (*)(const void *, const void *)>>()));
}

namespace
{
	// Object to auto-register ::mergesort.
	struct __mergesort_registrar
	{
		__mergesort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::mergesort>>());
		}
	} __mergesort_instance;
}



int Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (^)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mergesort_b_name = "::mergesort_b";

const std::string& Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b>::GetName() const
{
	return __mergesort_b_name;
}

Object Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mergesort_b(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (^)(const void *, const void *)>>()));
}

namespace
{
	// Object to auto-register ::mergesort_b.
	struct __mergesort_b_registrar
	{
		__mergesort_b_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::mergesort_b>>());
		}
	} __mergesort_b_instance;
}



int Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (*)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __psort_name = "::psort";

const std::string& Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort>::GetName() const
{
	return __psort_name;
}

Object Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::psort(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (*)(const void *, const void *)>>());
	return Object();
}

namespace
{
	// Object to auto-register ::psort.
	struct __psort_registrar
	{
		__psort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t, size_t, int (*)(const void *, const void *)), ::psort>>());
		}
	} __psort_instance;
}



int Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (^)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __psort_b_name = "::psort_b";

const std::string& Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b>::GetName() const
{
	return __psort_b_name;
}

Object Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::psort_b(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (^)(const void *, const void *)>>());
	return Object();
}

namespace
{
	// Object to auto-register ::psort_b.
	struct __psort_b_registrar
	{
		__psort_b_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::psort_b>>());
		}
	} __psort_b_instance;
}



int Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r>::GetParameterCount() const
{
	return 5;
}

Parameter Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "void *";
		break;
	case 4:
		result.name = "__compar";
		result.type = "int (*)(void *, const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __psort_r_name = "::psort_r";

const std::string& Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r>::GetName() const
{
	return __psort_r_name;
}

Object Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::psort_r(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<void *>>(), args[4].GetT<std::decay_t<int (*)(void *, const void *, const void *)>>());
	return Object();
}

namespace
{
	// Object to auto-register ::psort_r.
	struct __psort_r_registrar
	{
		__psort_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::psort_r>>());
		}
	} __psort_r_instance;
}



int Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__compar";
		result.type = "int (^)(const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __qsort_b_name = "::qsort_b";

const std::string& Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b>::GetName() const
{
	return __qsort_b_name;
}

Object Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::qsort_b(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<int (^)(const void *, const void *)>>());
	return Object();
}

namespace
{
	// Object to auto-register ::qsort_b.
	struct __qsort_b_registrar
	{
		__qsort_b_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t, size_t, int (^)(const void *, const void *)), ::qsort_b>>());
		}
	} __qsort_b_instance;
}



int Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r>::GetParameterCount() const
{
	return 5;
}

Parameter Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "void *";
		break;
	case 1:
		result.name = "__nel";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__width";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "void *";
		break;
	case 4:
		result.name = "__compar";
		result.type = "int (*)(void *, const void *, const void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __qsort_r_name = "::qsort_r";

const std::string& Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r>::GetName() const
{
	return __qsort_r_name;
}

Object Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::qsort_r(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<void *>>(), args[4].GetT<std::decay_t<int (*)(void *, const void *, const void *)>>());
	return Object();
}

namespace
{
	// Object to auto-register ::qsort_r.
	struct __qsort_r_registrar
	{
		__qsort_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)), ::qsort_r>>());
		}
	} __qsort_r_instance;
}



int Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "const unsigned char **";
		break;
	case 1:
		result.name = "__nel";
		result.type = "int";
		break;
	case 2:
		result.name = "__table";
		result.type = "const unsigned char *";
		break;
	case 3:
		result.name = "__endbyte";
		result.type = "unsigned int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __radixsort_name = "::radixsort";

const std::string& Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort>::GetName() const
{
	return __radixsort_name;
}

Object Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::radixsort(args[0].GetT<std::decay_t<const unsigned char **>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<const unsigned char *>>(), args[3].GetT<std::decay_t<unsigned int>>()));
}

namespace
{
	// Object to auto-register ::radixsort.
	struct __radixsort_registrar
	{
		__radixsort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::radixsort>>());
		}
	} __radixsort_instance;
}



int Function<void(*)(const char *), ::setprogname>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(const char *), ::setprogname>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(const char *), ::setprogname>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setprogname_name = "::setprogname";

const std::string& Function<void(*)(const char *), ::setprogname>::GetName() const
{
	return __setprogname_name;
}

Object Function<void(*)(const char *), ::setprogname>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::setprogname(args[0].GetT<std::decay_t<const char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::setprogname.
	struct __setprogname_registrar
	{
		__setprogname_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(const char *), ::setprogname>>());
		}
	} __setprogname_instance;
}



int Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__base";
		result.type = "const unsigned char **";
		break;
	case 1:
		result.name = "__nel";
		result.type = "int";
		break;
	case 2:
		result.name = "__table";
		result.type = "const unsigned char *";
		break;
	case 3:
		result.name = "__endbyte";
		result.type = "unsigned int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __sradixsort_name = "::sradixsort";

const std::string& Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort>::GetName() const
{
	return __sradixsort_name;
}

Object Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::sradixsort(args[0].GetT<std::decay_t<const unsigned char **>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<const unsigned char *>>(), args[3].GetT<std::decay_t<unsigned int>>()));
}

namespace
{
	// Object to auto-register ::sradixsort.
	struct __sradixsort_registrar
	{
		__sradixsort_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const unsigned char **, int, const unsigned char *, unsigned int), ::sradixsort>>());
		}
	} __sradixsort_instance;
}



int Function<void(*)(), ::sranddev>::GetParameterCount() const
{
	return 0;
}

Parameter Function<void(*)(), ::sranddev>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(), ::sranddev>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __sranddev_name = "::sranddev";

const std::string& Function<void(*)(), ::sranddev>::GetName() const
{
	return __sranddev_name;
}

Object Function<void(*)(), ::sranddev>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::sranddev();
	return Object();
}

namespace
{
	// Object to auto-register ::sranddev.
	struct __sranddev_registrar
	{
		__sranddev_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(), ::sranddev>>());
		}
	} __sranddev_instance;
}



int Function<void(*)(), ::srandomdev>::GetParameterCount() const
{
	return 0;
}

Parameter Function<void(*)(), ::srandomdev>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(), ::srandomdev>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __srandomdev_name = "::srandomdev";

const std::string& Function<void(*)(), ::srandomdev>::GetName() const
{
	return __srandomdev_name;
}

Object Function<void(*)(), ::srandomdev>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::srandomdev();
	return Object();
}

namespace
{
	// Object to auto-register ::srandomdev.
	struct __srandomdev_registrar
	{
		__srandomdev_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(), ::srandomdev>>());
		}
	} __srandomdev_instance;
}



int Function<void *(*)(void *, size_t), ::reallocf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void *(*)(void *, size_t), ::reallocf>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(void *, size_t), ::reallocf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__ptr";
		result.type = "void *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __reallocf_name = "::reallocf";

const std::string& Function<void *(*)(void *, size_t), ::reallocf>::GetName() const
{
	return __reallocf_name;
}

Object Function<void *(*)(void *, size_t), ::reallocf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::reallocf(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::reallocf.
	struct __reallocf_registrar
	{
		__reallocf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(void *, size_t), ::reallocf>>());
		}
	} __reallocf_instance;
}



int Function<long long(*)(const char *, char **, int), ::strtoq>::GetParameterCount() const
{
	return 3;
}

Parameter Function<long long(*)(const char *, char **, int), ::strtoq>::GetReturnType() const
{
	Parameter result;
	result.type = "long long";
	return result;
}

Parameter Function<long long(*)(const char *, char **, int), ::strtoq>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__endptr";
		result.type = "char **";
		break;
	case 2:
		result.name = "__base";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtoq_name = "::strtoq";

const std::string& Function<long long(*)(const char *, char **, int), ::strtoq>::GetName() const
{
	return __strtoq_name;
}

Object Function<long long(*)(const char *, char **, int), ::strtoq>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtoq(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strtoq.
	struct __strtoq_registrar
	{
		__strtoq_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long long(*)(const char *, char **, int), ::strtoq>>());
		}
	} __strtoq_instance;
}



int Function<unsigned long long(*)(const char *, char **, int), ::strtouq>::GetParameterCount() const
{
	return 3;
}

Parameter Function<unsigned long long(*)(const char *, char **, int), ::strtouq>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned long long";
	return result;
}

Parameter Function<unsigned long long(*)(const char *, char **, int), ::strtouq>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__endptr";
		result.type = "char **";
		break;
	case 2:
		result.name = "__base";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strtouq_name = "::strtouq";

const std::string& Function<unsigned long long(*)(const char *, char **, int), ::strtouq>::GetName() const
{
	return __strtouq_name;
}

Object Function<unsigned long long(*)(const char *, char **, int), ::strtouq>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strtouq(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<char **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::strtouq.
	struct __strtouq_registrar
	{
		__strtouq_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned long long(*)(const char *, char **, int), ::strtouq>>());
		}
	} __strtouq_instance;
}



int Function<void *(*)(std::size_t), operator new>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void *(*)(std::size_t), operator new>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(std::size_t), operator new>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__sz";
		result.type = "std::size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator new_name = "operator new";

const std::string& Function<void *(*)(std::size_t), operator new>::GetName() const
{
	return operator new_name;
}

Object Function<void *(*)(std::size_t), operator new>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(operator new(args[0].GetT<std::decay_t<std::size_t>>()));
}

namespace
{
	// Object to auto-register operator new.
	struct operator new_registrar
	{
		operator new_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(std::size_t), operator new>>());
		}
	} operator new_instance;
}



int Function<void *(*)(std::size_t, const std::nothrow_t &), operator new>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void *(*)(std::size_t, const std::nothrow_t &), operator new>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(std::size_t, const std::nothrow_t &), operator new>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__sz";
		result.type = "std::size_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const std::nothrow_t &";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator new_1_name = "operator new";

const std::string& Function<void *(*)(std::size_t, const std::nothrow_t &), operator new>::GetName() const
{
	return operator new_1_name;
}

Object Function<void *(*)(std::size_t, const std::nothrow_t &), operator new>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(operator new(args[0].GetT<std::decay_t<std::size_t>>(), args[1].GetT<std::decay_t<const std::nothrow_t &>>()));
}

namespace
{
	// Object to auto-register operator new.
	struct operator new_1_registrar
	{
		operator new_1_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(std::size_t, const std::nothrow_t &), operator new>>());
		}
	} operator new_1_instance;
}



int Function<void(*)(void *), operator delete>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(void *), operator delete>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *), operator delete>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__p";
		result.type = "void *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator delete_name = "operator delete";

const std::string& Function<void(*)(void *), operator delete>::GetName() const
{
	return operator delete_name;
}

Object Function<void(*)(void *), operator delete>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	operator delete(args[0].GetT<std::decay_t<void *>>());
	return Object();
}

namespace
{
	// Object to auto-register operator delete.
	struct operator delete_registrar
	{
		operator delete_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *), operator delete>>());
		}
	} operator delete_instance;
}



int Function<void(*)(void *, const std::nothrow_t &), operator delete>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(void *, const std::nothrow_t &), operator delete>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, const std::nothrow_t &), operator delete>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__p";
		result.type = "void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const std::nothrow_t &";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator delete_1_name = "operator delete";

const std::string& Function<void(*)(void *, const std::nothrow_t &), operator delete>::GetName() const
{
	return operator delete_1_name;
}

Object Function<void(*)(void *, const std::nothrow_t &), operator delete>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	operator delete(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const std::nothrow_t &>>());
	return Object();
}

namespace
{
	// Object to auto-register operator delete.
	struct operator delete_1_registrar
	{
		operator delete_1_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, const std::nothrow_t &), operator delete>>());
		}
	} operator delete_1_instance;
}



int Function<void(*)(void *, std::size_t), operator delete>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(void *, std::size_t), operator delete>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, std::size_t), operator delete>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__p";
		result.type = "void *";
		break;
	case 1:
		result.name = "__sz";
		result.type = "std::size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator delete_2_name = "operator delete";

const std::string& Function<void(*)(void *, std::size_t), operator delete>::GetName() const
{
	return operator delete_2_name;
}

Object Function<void(*)(void *, std::size_t), operator delete>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	operator delete(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<std::size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register operator delete.
	struct operator delete_2_registrar
	{
		operator delete_2_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, std::size_t), operator delete>>());
		}
	} operator delete_2_instance;
}



int Function<void *(*)(std::size_t), operator new[]>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void *(*)(std::size_t), operator new[]>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(std::size_t), operator new[]>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__sz";
		result.type = "std::size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator new[]_name = "operator new[]";

const std::string& Function<void *(*)(std::size_t), operator new[]>::GetName() const
{
	return operator new[]_name;
}

Object Function<void *(*)(std::size_t), operator new[]>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(operator new[](args[0].GetT<std::decay_t<std::size_t>>()));
}

namespace
{
	// Object to auto-register operator new[].
	struct operator new[]_registrar
	{
		operator new[]_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(std::size_t), operator new[]>>());
		}
	} operator new[]_instance;
}



int Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]>::GetReturnType() const
{
	Parameter result;
	result.type = "void *";
	return result;
}

Parameter Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__sz";
		result.type = "std::size_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const std::nothrow_t &";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator new[]_1_name = "operator new[]";

const std::string& Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]>::GetName() const
{
	return operator new[]_1_name;
}

Object Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(operator new[](args[0].GetT<std::decay_t<std::size_t>>(), args[1].GetT<std::decay_t<const std::nothrow_t &>>()));
}

namespace
{
	// Object to auto-register operator new[].
	struct operator new[]_1_registrar
	{
		operator new[]_1_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void *(*)(std::size_t, const std::nothrow_t &), operator new[]>>());
		}
	} operator new[]_1_instance;
}



int Function<void(*)(void *), operator delete[]>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(void *), operator delete[]>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *), operator delete[]>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__p";
		result.type = "void *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator delete[]_name = "operator delete[]";

const std::string& Function<void(*)(void *), operator delete[]>::GetName() const
{
	return operator delete[]_name;
}

Object Function<void(*)(void *), operator delete[]>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	operator delete[](args[0].GetT<std::decay_t<void *>>());
	return Object();
}

namespace
{
	// Object to auto-register operator delete[].
	struct operator delete[]_registrar
	{
		operator delete[]_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *), operator delete[]>>());
		}
	} operator delete[]_instance;
}



int Function<void(*)(void *, const std::nothrow_t &), operator delete[]>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(void *, const std::nothrow_t &), operator delete[]>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, const std::nothrow_t &), operator delete[]>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__p";
		result.type = "void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const std::nothrow_t &";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator delete[]_1_name = "operator delete[]";

const std::string& Function<void(*)(void *, const std::nothrow_t &), operator delete[]>::GetName() const
{
	return operator delete[]_1_name;
}

Object Function<void(*)(void *, const std::nothrow_t &), operator delete[]>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	operator delete[](args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<const std::nothrow_t &>>());
	return Object();
}

namespace
{
	// Object to auto-register operator delete[].
	struct operator delete[]_1_registrar
	{
		operator delete[]_1_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, const std::nothrow_t &), operator delete[]>>());
		}
	} operator delete[]_1_instance;
}



int Function<void(*)(void *, std::size_t), operator delete[]>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(void *, std::size_t), operator delete[]>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(void *, std::size_t), operator delete[]>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__p";
		result.type = "void *";
		break;
	case 1:
		result.name = "__sz";
		result.type = "std::size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string operator delete[]_2_name = "operator delete[]";

const std::string& Function<void(*)(void *, std::size_t), operator delete[]>::GetName() const
{
	return operator delete[]_2_name;
}

Object Function<void(*)(void *, std::size_t), operator delete[]>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	operator delete[](args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<std::size_t>>());
	return Object();
}

namespace
{
	// Object to auto-register operator delete[].
	struct operator delete[]_2_registrar
	{
		operator delete[]_2_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(void *, std::size_t), operator delete[]>>());
		}
	} operator delete[]_2_instance;
}



int Function<int(*)(int, const char *, int, const char *), ::renameat>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(int, const char *, int, const char *), ::renameat>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, const char *, int, const char *), ::renameat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	case 3:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __renameat_name = "::renameat";

const std::string& Function<int(*)(int, const char *, int, const char *), ::renameat>::GetName() const
{
	return __renameat_name;
}

Object Function<int(*)(int, const char *, int, const char *), ::renameat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::renameat(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::renameat.
	struct __renameat_registrar
	{
		__renameat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, const char *, int, const char *), ::renameat>>());
		}
	} __renameat_instance;
}



int Function<int(*)(const char *, const char *, unsigned int), ::renamex_np>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const char *, const char *, unsigned int), ::renamex_np>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *, unsigned int), ::renamex_np>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "unsigned int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __renamex_np_name = "::renamex_np";

const std::string& Function<int(*)(const char *, const char *, unsigned int), ::renamex_np>::GetName() const
{
	return __renamex_np_name;
}

Object Function<int(*)(const char *, const char *, unsigned int), ::renamex_np>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::renamex_np(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<unsigned int>>()));
}

namespace
{
	// Object to auto-register ::renamex_np.
	struct __renamex_np_registrar
	{
		__renamex_np_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *, unsigned int), ::renamex_np>>());
		}
	} __renamex_np_instance;
}



int Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np>::GetParameterCount() const
{
	return 5;
}

Parameter Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	case 3:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 4:
		result.name = "nameless";
		result.type = "unsigned int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __renameatx_np_name = "::renameatx_np";

const std::string& Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np>::GetName() const
{
	return __renameatx_np_name;
}

Object Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::renameatx_np(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<const char *>>(), args[4].GetT<std::decay_t<unsigned int>>()));
}

namespace
{
	// Object to auto-register ::renameatx_np.
	struct __renameatx_np_registrar
	{
		__renameatx_np_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, const char *, int, const char *, unsigned int), ::renameatx_np>>());
		}
	} __renameatx_np_instance;
}



const int Class<__sbuf>::FieldCount;
const int Class<__sbuf>::StaticFieldCount;
const int Class<__sbuf>::MethodCount;
const int Class<__sbuf>::StaticMethodCount;

int Class<__sbuf>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__sbuf>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__sbuf>())
	{
		__sbuf& o = r.GetT<__sbuf>();
		if (name == "_base")
		{
			return Reference(o._base);
		}
		if (name == "_size")
		{
			return Reference(o._size);
		}
	}
	else if (r.IsT<const __sbuf>())
	{
		const __sbuf& o = r.GetT<const __sbuf>();
		if (name == "_base")
		{
			return Reference(o._base);
		}
		if (name == "_size")
		{
			return Reference(o._size);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__sbuf>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__sbuf>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__sbuf>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__sbuf>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__sbuf>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__sbuf>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __sbuf_name = "__sbuf";

const std::string& Class<__sbuf>::GetName() const
{
	return __sbuf_name;
}



namespace
{
	// Object to auto-register __sbuf.
	struct __sbuf_registrar
	{
		__sbuf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__sbuf>>());
		}
	} __sbuf_instance;
}


const int Class<__sFILEX>::FieldCount;
const int Class<__sFILEX>::StaticFieldCount;
const int Class<__sFILEX>::MethodCount;
const int Class<__sFILEX>::StaticMethodCount;

int Class<__sFILEX>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__sFILEX>::GetField(const Reference& r, const std::string& name) const
{
	throw Exception("Invalid name passed to GetField().");
}

int Class<__sFILEX>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__sFILEX>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__sFILEX>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__sFILEX>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__sFILEX>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__sFILEX>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __sFILEX_name = "__sFILEX";

const std::string& Class<__sFILEX>::GetName() const
{
	return __sFILEX_name;
}



namespace
{
	// Object to auto-register __sFILEX.
	struct __sFILEX_registrar
	{
		__sFILEX_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__sFILEX>>());
		}
	} __sFILEX_instance;
}


const int Class<__sFILE>::FieldCount;
const int Class<__sFILE>::StaticFieldCount;
const int Class<__sFILE>::MethodCount;
const int Class<__sFILE>::StaticMethodCount;

int Class<__sFILE>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__sFILE>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__sFILE>())
	{
		__sFILE& o = r.GetT<__sFILE>();
		if (name == "_p")
		{
			return Reference(o._p);
		}
		if (name == "_r")
		{
			return Reference(o._r);
		}
		if (name == "_w")
		{
			return Reference(o._w);
		}
		if (name == "_flags")
		{
			return Reference(o._flags);
		}
		if (name == "_file")
		{
			return Reference(o._file);
		}
		if (name == "_bf")
		{
			return Reference(o._bf);
		}
		if (name == "_lbfsize")
		{
			return Reference(o._lbfsize);
		}
		if (name == "_cookie")
		{
			return Reference(o._cookie);
		}
		if (name == "_close")
		{
			return Reference(o._close);
		}
		if (name == "_read")
		{
			return Reference(o._read);
		}
		if (name == "_seek")
		{
			return Reference(o._seek);
		}
		if (name == "_write")
		{
			return Reference(o._write);
		}
		if (name == "_ub")
		{
			return Reference(o._ub);
		}
		if (name == "_extra")
		{
			return Reference(o._extra);
		}
		if (name == "_ur")
		{
			return Reference(o._ur);
		}
		if (name == "_ubuf")
		{
			return Reference(o._ubuf);
		}
		if (name == "_nbuf")
		{
			return Reference(o._nbuf);
		}
		if (name == "_lb")
		{
			return Reference(o._lb);
		}
		if (name == "_blksize")
		{
			return Reference(o._blksize);
		}
		if (name == "_offset")
		{
			return Reference(o._offset);
		}
	}
	else if (r.IsT<const __sFILE>())
	{
		const __sFILE& o = r.GetT<const __sFILE>();
		if (name == "_p")
		{
			return Reference(o._p);
		}
		if (name == "_r")
		{
			return Reference(o._r);
		}
		if (name == "_w")
		{
			return Reference(o._w);
		}
		if (name == "_flags")
		{
			return Reference(o._flags);
		}
		if (name == "_file")
		{
			return Reference(o._file);
		}
		if (name == "_bf")
		{
			return Reference(o._bf);
		}
		if (name == "_lbfsize")
		{
			return Reference(o._lbfsize);
		}
		if (name == "_cookie")
		{
			return Reference(o._cookie);
		}
		if (name == "_close")
		{
			return Reference(o._close);
		}
		if (name == "_read")
		{
			return Reference(o._read);
		}
		if (name == "_seek")
		{
			return Reference(o._seek);
		}
		if (name == "_write")
		{
			return Reference(o._write);
		}
		if (name == "_ub")
		{
			return Reference(o._ub);
		}
		if (name == "_extra")
		{
			return Reference(o._extra);
		}
		if (name == "_ur")
		{
			return Reference(o._ur);
		}
		if (name == "_ubuf")
		{
			return Reference(o._ubuf);
		}
		if (name == "_nbuf")
		{
			return Reference(o._nbuf);
		}
		if (name == "_lb")
		{
			return Reference(o._lb);
		}
		if (name == "_blksize")
		{
			return Reference(o._blksize);
		}
		if (name == "_offset")
		{
			return Reference(o._offset);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__sFILE>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__sFILE>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__sFILE>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__sFILE>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__sFILE>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__sFILE>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __sFILE_name = "__sFILE";

const std::string& Class<__sFILE>::GetName() const
{
	return __sFILE_name;
}



namespace
{
	// Object to auto-register __sFILE.
	struct __sFILE_registrar
	{
		__sFILE_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__sFILE>>());
		}
	} __sFILE_instance;
}


const int Class<__sFILE>::FieldCount;
const int Class<__sFILE>::StaticFieldCount;
const int Class<__sFILE>::MethodCount;
const int Class<__sFILE>::StaticMethodCount;

int Class<__sFILE>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<__sFILE>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<__sFILE>())
	{
		__sFILE& o = r.GetT<__sFILE>();
		if (name == "_p")
		{
			return Reference(o._p);
		}
		if (name == "_r")
		{
			return Reference(o._r);
		}
		if (name == "_w")
		{
			return Reference(o._w);
		}
		if (name == "_flags")
		{
			return Reference(o._flags);
		}
		if (name == "_file")
		{
			return Reference(o._file);
		}
		if (name == "_bf")
		{
			return Reference(o._bf);
		}
		if (name == "_lbfsize")
		{
			return Reference(o._lbfsize);
		}
		if (name == "_cookie")
		{
			return Reference(o._cookie);
		}
		if (name == "_close")
		{
			return Reference(o._close);
		}
		if (name == "_read")
		{
			return Reference(o._read);
		}
		if (name == "_seek")
		{
			return Reference(o._seek);
		}
		if (name == "_write")
		{
			return Reference(o._write);
		}
		if (name == "_ub")
		{
			return Reference(o._ub);
		}
		if (name == "_extra")
		{
			return Reference(o._extra);
		}
		if (name == "_ur")
		{
			return Reference(o._ur);
		}
		if (name == "_ubuf")
		{
			return Reference(o._ubuf);
		}
		if (name == "_nbuf")
		{
			return Reference(o._nbuf);
		}
		if (name == "_lb")
		{
			return Reference(o._lb);
		}
		if (name == "_blksize")
		{
			return Reference(o._blksize);
		}
		if (name == "_offset")
		{
			return Reference(o._offset);
		}
	}
	else if (r.IsT<const __sFILE>())
	{
		const __sFILE& o = r.GetT<const __sFILE>();
		if (name == "_p")
		{
			return Reference(o._p);
		}
		if (name == "_r")
		{
			return Reference(o._r);
		}
		if (name == "_w")
		{
			return Reference(o._w);
		}
		if (name == "_flags")
		{
			return Reference(o._flags);
		}
		if (name == "_file")
		{
			return Reference(o._file);
		}
		if (name == "_bf")
		{
			return Reference(o._bf);
		}
		if (name == "_lbfsize")
		{
			return Reference(o._lbfsize);
		}
		if (name == "_cookie")
		{
			return Reference(o._cookie);
		}
		if (name == "_close")
		{
			return Reference(o._close);
		}
		if (name == "_read")
		{
			return Reference(o._read);
		}
		if (name == "_seek")
		{
			return Reference(o._seek);
		}
		if (name == "_write")
		{
			return Reference(o._write);
		}
		if (name == "_ub")
		{
			return Reference(o._ub);
		}
		if (name == "_extra")
		{
			return Reference(o._extra);
		}
		if (name == "_ur")
		{
			return Reference(o._ur);
		}
		if (name == "_ubuf")
		{
			return Reference(o._ubuf);
		}
		if (name == "_nbuf")
		{
			return Reference(o._nbuf);
		}
		if (name == "_lb")
		{
			return Reference(o._lb);
		}
		if (name == "_blksize")
		{
			return Reference(o._blksize);
		}
		if (name == "_offset")
		{
			return Reference(o._offset);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<__sFILE>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<__sFILE>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<__sFILE>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<__sFILE>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<__sFILE>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<__sFILE>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string __sFILE_name = "__sFILE";

const std::string& Class<__sFILE>::GetName() const
{
	return __sFILE_name;
}



namespace
{
	// Object to auto-register __sFILE.
	struct __sFILE_registrar
	{
		__sFILE_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<__sFILE>>());
		}
	} __sFILE_instance;
}


int Function<void(*)(FILE *), ::clearerr>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(FILE *), ::clearerr>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(FILE *), ::clearerr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __clearerr_name = "::clearerr";

const std::string& Function<void(*)(FILE *), ::clearerr>::GetName() const
{
	return __clearerr_name;
}

Object Function<void(*)(FILE *), ::clearerr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::clearerr(args[0].GetT<std::decay_t<FILE *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::clearerr.
	struct __clearerr_registrar
	{
		__clearerr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(FILE *), ::clearerr>>());
		}
	} __clearerr_instance;
}



int Function<int(*)(FILE *), ::fclose>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::fclose>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::fclose>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fclose_name = "::fclose";

const std::string& Function<int(*)(FILE *), ::fclose>::GetName() const
{
	return __fclose_name;
}

Object Function<int(*)(FILE *), ::fclose>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fclose(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fclose.
	struct __fclose_registrar
	{
		__fclose_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::fclose>>());
		}
	} __fclose_instance;
}



int Function<int(*)(FILE *), ::feof>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::feof>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::feof>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __feof_name = "::feof";

const std::string& Function<int(*)(FILE *), ::feof>::GetName() const
{
	return __feof_name;
}

Object Function<int(*)(FILE *), ::feof>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::feof(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::feof.
	struct __feof_registrar
	{
		__feof_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::feof>>());
		}
	} __feof_instance;
}



int Function<int(*)(FILE *), ::ferror>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::ferror>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::ferror>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ferror_name = "::ferror";

const std::string& Function<int(*)(FILE *), ::ferror>::GetName() const
{
	return __ferror_name;
}

Object Function<int(*)(FILE *), ::ferror>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ferror(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::ferror.
	struct __ferror_registrar
	{
		__ferror_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::ferror>>());
		}
	} __ferror_instance;
}



int Function<int(*)(FILE *), ::fflush>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::fflush>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::fflush>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fflush_name = "::fflush";

const std::string& Function<int(*)(FILE *), ::fflush>::GetName() const
{
	return __fflush_name;
}

Object Function<int(*)(FILE *), ::fflush>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fflush(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fflush.
	struct __fflush_registrar
	{
		__fflush_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::fflush>>());
		}
	} __fflush_instance;
}



int Function<int(*)(FILE *), ::fgetc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::fgetc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::fgetc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgetc_name = "::fgetc";

const std::string& Function<int(*)(FILE *), ::fgetc>::GetName() const
{
	return __fgetc_name;
}

Object Function<int(*)(FILE *), ::fgetc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgetc(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fgetc.
	struct __fgetc_registrar
	{
		__fgetc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::fgetc>>());
		}
	} __fgetc_instance;
}



int Function<int(*)(FILE *, fpos_t *), ::fgetpos>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, fpos_t *), ::fgetpos>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, fpos_t *), ::fgetpos>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "fpos_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgetpos_name = "::fgetpos";

const std::string& Function<int(*)(FILE *, fpos_t *), ::fgetpos>::GetName() const
{
	return __fgetpos_name;
}

Object Function<int(*)(FILE *, fpos_t *), ::fgetpos>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgetpos(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<fpos_t *>>()));
}

namespace
{
	// Object to auto-register ::fgetpos.
	struct __fgetpos_registrar
	{
		__fgetpos_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, fpos_t *), ::fgetpos>>());
		}
	} __fgetpos_instance;
}



int Function<char *(*)(char *, int, FILE *), ::fgets>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(char *, int, FILE *), ::fgets>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *, int, FILE *), ::fgets>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgets_name = "::fgets";

const std::string& Function<char *(*)(char *, int, FILE *), ::fgets>::GetName() const
{
	return __fgets_name;
}

Object Function<char *(*)(char *, int, FILE *), ::fgets>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgets(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fgets.
	struct __fgets_registrar
	{
		__fgets_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *, int, FILE *), ::fgets>>());
		}
	} __fgets_instance;
}



int Function<FILE *(*)(const char *, const char *), ::fopen>::GetParameterCount() const
{
	return 2;
}

Parameter Function<FILE *(*)(const char *, const char *), ::fopen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(const char *, const char *), ::fopen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__filename";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__mode";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fopen_name = "::fopen";

const std::string& Function<FILE *(*)(const char *, const char *), ::fopen>::GetName() const
{
	return __fopen_name;
}

Object Function<FILE *(*)(const char *, const char *), ::fopen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fopen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::fopen.
	struct __fopen_registrar
	{
		__fopen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(const char *, const char *), ::fopen>>());
		}
	} __fopen_instance;
}



int Function<int(*)(FILE *, const char *), ::fprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, const char *), ::fprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const char *), ::fprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fprintf_name = "::fprintf";

const std::string& Function<int(*)(FILE *, const char *), ::fprintf>::GetName() const
{
	return __fprintf_name;
}

Object Function<int(*)(FILE *, const char *), ::fprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fprintf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::fprintf.
	struct __fprintf_registrar
	{
		__fprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const char *), ::fprintf>>());
		}
	} __fprintf_instance;
}



int Function<int(*)(int, FILE *), ::fputc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), ::fputc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), ::fputc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fputc_name = "::fputc";

const std::string& Function<int(*)(int, FILE *), ::fputc>::GetName() const
{
	return __fputc_name;
}

Object Function<int(*)(int, FILE *), ::fputc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fputc(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fputc.
	struct __fputc_registrar
	{
		__fputc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), ::fputc>>());
		}
	} __fputc_instance;
}



int Function<int(*)(const char *, FILE *), ::fputs>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, FILE *), ::fputs>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, FILE *), ::fputs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fputs_name = "::fputs";

const std::string& Function<int(*)(const char *, FILE *), ::fputs>::GetName() const
{
	return __fputs_name;
}

Object Function<int(*)(const char *, FILE *), ::fputs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fputs(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fputs.
	struct __fputs_registrar
	{
		__fputs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, FILE *), ::fputs>>());
		}
	} __fputs_instance;
}



int Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__ptr";
		result.type = "void *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__nitems";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fread_name = "::fread";

const std::string& Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread>::GetName() const
{
	return __fread_name;
}

Object Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fread(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fread.
	struct __fread_registrar
	{
		__fread_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(void *, size_t, size_t, FILE *), ::fread>>());
		}
	} __fread_instance;
}



int Function<FILE *(*)(const char *, const char *, FILE *), ::freopen>::GetParameterCount() const
{
	return 3;
}

Parameter Function<FILE *(*)(const char *, const char *, FILE *), ::freopen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(const char *, const char *, FILE *), ::freopen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __freopen_name = "::freopen";

const std::string& Function<FILE *(*)(const char *, const char *, FILE *), ::freopen>::GetName() const
{
	return __freopen_name;
}

Object Function<FILE *(*)(const char *, const char *, FILE *), ::freopen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::freopen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::freopen.
	struct __freopen_registrar
	{
		__freopen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(const char *, const char *, FILE *), ::freopen>>());
		}
	} __freopen_instance;
}



int Function<int(*)(FILE *, const char *), ::fscanf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, const char *), ::fscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const char *), ::fscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fscanf_name = "::fscanf";

const std::string& Function<int(*)(FILE *, const char *), ::fscanf>::GetName() const
{
	return __fscanf_name;
}

Object Function<int(*)(FILE *, const char *), ::fscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fscanf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::fscanf.
	struct __fscanf_registrar
	{
		__fscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const char *), ::fscanf>>());
		}
	} __fscanf_instance;
}



int Function<int(*)(FILE *, long, int), ::fseek>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, long, int), ::fseek>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, long, int), ::fseek>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "long";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fseek_name = "::fseek";

const std::string& Function<int(*)(FILE *, long, int), ::fseek>::GetName() const
{
	return __fseek_name;
}

Object Function<int(*)(FILE *, long, int), ::fseek>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fseek(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<long>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::fseek.
	struct __fseek_registrar
	{
		__fseek_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, long, int), ::fseek>>());
		}
	} __fseek_instance;
}



int Function<int(*)(FILE *, const fpos_t *), ::fsetpos>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, const fpos_t *), ::fsetpos>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const fpos_t *), ::fsetpos>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const fpos_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fsetpos_name = "::fsetpos";

const std::string& Function<int(*)(FILE *, const fpos_t *), ::fsetpos>::GetName() const
{
	return __fsetpos_name;
}

Object Function<int(*)(FILE *, const fpos_t *), ::fsetpos>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fsetpos(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const fpos_t *>>()));
}

namespace
{
	// Object to auto-register ::fsetpos.
	struct __fsetpos_registrar
	{
		__fsetpos_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const fpos_t *), ::fsetpos>>());
		}
	} __fsetpos_instance;
}



int Function<long(*)(FILE *), ::ftell>::GetParameterCount() const
{
	return 1;
}

Parameter Function<long(*)(FILE *), ::ftell>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(FILE *), ::ftell>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ftell_name = "::ftell";

const std::string& Function<long(*)(FILE *), ::ftell>::GetName() const
{
	return __ftell_name;
}

Object Function<long(*)(FILE *), ::ftell>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ftell(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::ftell.
	struct __ftell_registrar
	{
		__ftell_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(FILE *), ::ftell>>());
		}
	} __ftell_instance;
}



int Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__ptr";
		result.type = "const void *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__nitems";
		result.type = "size_t";
		break;
	case 3:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fwrite_name = "::fwrite";

const std::string& Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite>::GetName() const
{
	return __fwrite_name;
}

Object Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fwrite(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fwrite.
	struct __fwrite_registrar
	{
		__fwrite_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const void *, size_t, size_t, FILE *), ::fwrite>>());
		}
	} __fwrite_instance;
}



int Function<int(*)(FILE *), ::getc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::getc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::getc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getc_name = "::getc";

const std::string& Function<int(*)(FILE *), ::getc>::GetName() const
{
	return __getc_name;
}

Object Function<int(*)(FILE *), ::getc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getc(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::getc.
	struct __getc_registrar
	{
		__getc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::getc>>());
		}
	} __getc_instance;
}



int Function<int(*)(), ::getchar>::GetParameterCount() const
{
	return 0;
}

Parameter Function<int(*)(), ::getchar>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(), ::getchar>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __getchar_name = "::getchar";

const std::string& Function<int(*)(), ::getchar>::GetName() const
{
	return __getchar_name;
}

Object Function<int(*)(), ::getchar>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getchar());
}

namespace
{
	// Object to auto-register ::getchar.
	struct __getchar_registrar
	{
		__getchar_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(), ::getchar>>());
		}
	} __getchar_instance;
}



int Function<char *(*)(char *), ::gets>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(char *), ::gets>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *), ::gets>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __gets_name = "::gets";

const std::string& Function<char *(*)(char *), ::gets>::GetName() const
{
	return __gets_name;
}

Object Function<char *(*)(char *), ::gets>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::gets(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::gets.
	struct __gets_registrar
	{
		__gets_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *), ::gets>>());
		}
	} __gets_instance;
}



int Function<void(*)(const char *), ::perror>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(const char *), ::perror>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(const char *), ::perror>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __perror_name = "::perror";

const std::string& Function<void(*)(const char *), ::perror>::GetName() const
{
	return __perror_name;
}

Object Function<void(*)(const char *), ::perror>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::perror(args[0].GetT<std::decay_t<const char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::perror.
	struct __perror_registrar
	{
		__perror_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(const char *), ::perror>>());
		}
	} __perror_instance;
}



int Function<int(*)(const char *), ::printf>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::printf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::printf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __printf_name = "::printf";

const std::string& Function<int(*)(const char *), ::printf>::GetName() const
{
	return __printf_name;
}

Object Function<int(*)(const char *), ::printf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::printf(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::printf.
	struct __printf_registrar
	{
		__printf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::printf>>());
		}
	} __printf_instance;
}



int Function<int(*)(int, FILE *), ::putc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), ::putc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), ::putc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putc_name = "::putc";

const std::string& Function<int(*)(int, FILE *), ::putc>::GetName() const
{
	return __putc_name;
}

Object Function<int(*)(int, FILE *), ::putc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putc(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::putc.
	struct __putc_registrar
	{
		__putc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), ::putc>>());
		}
	} __putc_instance;
}



int Function<int(*)(int), ::putchar>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::putchar>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::putchar>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putchar_name = "::putchar";

const std::string& Function<int(*)(int), ::putchar>::GetName() const
{
	return __putchar_name;
}

Object Function<int(*)(int), ::putchar>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putchar(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::putchar.
	struct __putchar_registrar
	{
		__putchar_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::putchar>>());
		}
	} __putchar_instance;
}



int Function<int(*)(const char *), ::puts>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::puts>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::puts>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __puts_name = "::puts";

const std::string& Function<int(*)(const char *), ::puts>::GetName() const
{
	return __puts_name;
}

Object Function<int(*)(const char *), ::puts>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::puts(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::puts.
	struct __puts_registrar
	{
		__puts_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::puts>>());
		}
	} __puts_instance;
}



int Function<int(*)(const char *), ::remove>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::remove>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::remove>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __remove_name = "::remove";

const std::string& Function<int(*)(const char *), ::remove>::GetName() const
{
	return __remove_name;
}

Object Function<int(*)(const char *), ::remove>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::remove(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::remove.
	struct __remove_registrar
	{
		__remove_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::remove>>());
		}
	} __remove_instance;
}



int Function<int(*)(const char *, const char *), ::rename>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, const char *), ::rename>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *), ::rename>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__old";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__new";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __rename_name = "::rename";

const std::string& Function<int(*)(const char *, const char *), ::rename>::GetName() const
{
	return __rename_name;
}

Object Function<int(*)(const char *, const char *), ::rename>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::rename(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::rename.
	struct __rename_registrar
	{
		__rename_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *), ::rename>>());
		}
	} __rename_instance;
}



int Function<void(*)(FILE *), ::rewind>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(FILE *), ::rewind>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(FILE *), ::rewind>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __rewind_name = "::rewind";

const std::string& Function<void(*)(FILE *), ::rewind>::GetName() const
{
	return __rewind_name;
}

Object Function<void(*)(FILE *), ::rewind>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::rewind(args[0].GetT<std::decay_t<FILE *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::rewind.
	struct __rewind_registrar
	{
		__rewind_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(FILE *), ::rewind>>());
		}
	} __rewind_instance;
}



int Function<int(*)(const char *), ::scanf>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const char *), ::scanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *), ::scanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __scanf_name = "::scanf";

const std::string& Function<int(*)(const char *), ::scanf>::GetName() const
{
	return __scanf_name;
}

Object Function<int(*)(const char *), ::scanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::scanf(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::scanf.
	struct __scanf_registrar
	{
		__scanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *), ::scanf>>());
		}
	} __scanf_instance;
}



int Function<void(*)(FILE *, char *), ::setbuf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(FILE *, char *), ::setbuf>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(FILE *, char *), ::setbuf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setbuf_name = "::setbuf";

const std::string& Function<void(*)(FILE *, char *), ::setbuf>::GetName() const
{
	return __setbuf_name;
}

Object Function<void(*)(FILE *, char *), ::setbuf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::setbuf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::setbuf.
	struct __setbuf_registrar
	{
		__setbuf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(FILE *, char *), ::setbuf>>());
		}
	} __setbuf_instance;
}



int Function<int(*)(FILE *, char *, int, size_t), ::setvbuf>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(FILE *, char *, int, size_t), ::setvbuf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, char *, int, size_t), ::setvbuf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	case 3:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setvbuf_name = "::setvbuf";

const std::string& Function<int(*)(FILE *, char *, int, size_t), ::setvbuf>::GetName() const
{
	return __setvbuf_name;
}

Object Function<int(*)(FILE *, char *, int, size_t), ::setvbuf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setvbuf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<char *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::setvbuf.
	struct __setvbuf_registrar
	{
		__setvbuf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, char *, int, size_t), ::setvbuf>>());
		}
	} __setvbuf_instance;
}



int Function<int(*)(char *, const char *), ::sprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(char *, const char *), ::sprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, const char *), ::sprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __sprintf_name = "::sprintf";

const std::string& Function<int(*)(char *, const char *), ::sprintf>::GetName() const
{
	return __sprintf_name;
}

Object Function<int(*)(char *, const char *), ::sprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::sprintf(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::sprintf.
	struct __sprintf_registrar
	{
		__sprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, const char *), ::sprintf>>());
		}
	} __sprintf_instance;
}



int Function<int(*)(const char *, const char *), ::sscanf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, const char *), ::sscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *), ::sscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __sscanf_name = "::sscanf";

const std::string& Function<int(*)(const char *, const char *), ::sscanf>::GetName() const
{
	return __sscanf_name;
}

Object Function<int(*)(const char *, const char *), ::sscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::sscanf(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::sscanf.
	struct __sscanf_registrar
	{
		__sscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *), ::sscanf>>());
		}
	} __sscanf_instance;
}



int Function<FILE *(*)(), ::tmpfile>::GetParameterCount() const
{
	return 0;
}

Parameter Function<FILE *(*)(), ::tmpfile>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(), ::tmpfile>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __tmpfile_name = "::tmpfile";

const std::string& Function<FILE *(*)(), ::tmpfile>::GetName() const
{
	return __tmpfile_name;
}

Object Function<FILE *(*)(), ::tmpfile>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::tmpfile());
}

namespace
{
	// Object to auto-register ::tmpfile.
	struct __tmpfile_registrar
	{
		__tmpfile_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(), ::tmpfile>>());
		}
	} __tmpfile_instance;
}



int Function<char *(*)(char *), ::tmpnam>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(char *), ::tmpnam>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *), ::tmpnam>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __tmpnam_name = "::tmpnam";

const std::string& Function<char *(*)(char *), ::tmpnam>::GetName() const
{
	return __tmpnam_name;
}

Object Function<char *(*)(char *), ::tmpnam>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::tmpnam(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::tmpnam.
	struct __tmpnam_registrar
	{
		__tmpnam_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *), ::tmpnam>>());
		}
	} __tmpnam_instance;
}



int Function<int(*)(int, FILE *), ::ungetc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), ::ungetc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), ::ungetc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ungetc_name = "::ungetc";

const std::string& Function<int(*)(int, FILE *), ::ungetc>::GetName() const
{
	return __ungetc_name;
}

Object Function<int(*)(int, FILE *), ::ungetc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ungetc(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::ungetc.
	struct __ungetc_registrar
	{
		__ungetc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), ::ungetc>>());
		}
	} __ungetc_instance;
}



int Function<int(*)(FILE *, const char *, va_list), ::vfprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, const char *, va_list), ::vfprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const char *, va_list), ::vfprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vfprintf_name = "::vfprintf";

const std::string& Function<int(*)(FILE *, const char *, va_list), ::vfprintf>::GetName() const
{
	return __vfprintf_name;
}

Object Function<int(*)(FILE *, const char *, va_list), ::vfprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vfprintf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vfprintf.
	struct __vfprintf_registrar
	{
		__vfprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const char *, va_list), ::vfprintf>>());
		}
	} __vfprintf_instance;
}



int Function<int(*)(const char *, va_list), ::vprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, va_list), ::vprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, va_list), ::vprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vprintf_name = "::vprintf";

const std::string& Function<int(*)(const char *, va_list), ::vprintf>::GetName() const
{
	return __vprintf_name;
}

Object Function<int(*)(const char *, va_list), ::vprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vprintf(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vprintf.
	struct __vprintf_registrar
	{
		__vprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, va_list), ::vprintf>>());
		}
	} __vprintf_instance;
}



int Function<int(*)(char *, const char *, va_list), ::vsprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char *, const char *, va_list), ::vsprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, const char *, va_list), ::vsprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vsprintf_name = "::vsprintf";

const std::string& Function<int(*)(char *, const char *, va_list), ::vsprintf>::GetName() const
{
	return __vsprintf_name;
}

Object Function<int(*)(char *, const char *, va_list), ::vsprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vsprintf(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vsprintf.
	struct __vsprintf_registrar
	{
		__vsprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, const char *, va_list), ::vsprintf>>());
		}
	} __vsprintf_instance;
}



int Function<char *(*)(char *), ::ctermid>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(char *), ::ctermid>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *), ::ctermid>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ctermid_name = "::ctermid";

const std::string& Function<char *(*)(char *), ::ctermid>::GetName() const
{
	return __ctermid_name;
}

Object Function<char *(*)(char *), ::ctermid>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ctermid(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::ctermid.
	struct __ctermid_registrar
	{
		__ctermid_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *), ::ctermid>>());
		}
	} __ctermid_instance;
}



int Function<FILE *(*)(int, const char *), ::fdopen>::GetParameterCount() const
{
	return 2;
}

Parameter Function<FILE *(*)(int, const char *), ::fdopen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(int, const char *), ::fdopen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fdopen_name = "::fdopen";

const std::string& Function<FILE *(*)(int, const char *), ::fdopen>::GetName() const
{
	return __fdopen_name;
}

Object Function<FILE *(*)(int, const char *), ::fdopen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fdopen(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::fdopen.
	struct __fdopen_registrar
	{
		__fdopen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(int, const char *), ::fdopen>>());
		}
	} __fdopen_instance;
}



int Function<int(*)(FILE *), ::fileno>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::fileno>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::fileno>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fileno_name = "::fileno";

const std::string& Function<int(*)(FILE *), ::fileno>::GetName() const
{
	return __fileno_name;
}

Object Function<int(*)(FILE *), ::fileno>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fileno(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fileno.
	struct __fileno_registrar
	{
		__fileno_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::fileno>>());
		}
	} __fileno_instance;
}



int Function<int(*)(FILE *), ::pclose>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::pclose>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::pclose>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __pclose_name = "::pclose";

const std::string& Function<int(*)(FILE *), ::pclose>::GetName() const
{
	return __pclose_name;
}

Object Function<int(*)(FILE *), ::pclose>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::pclose(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::pclose.
	struct __pclose_registrar
	{
		__pclose_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::pclose>>());
		}
	} __pclose_instance;
}



int Function<FILE *(*)(const char *, const char *), ::popen>::GetParameterCount() const
{
	return 2;
}

Parameter Function<FILE *(*)(const char *, const char *), ::popen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(const char *, const char *), ::popen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __popen_name = "::popen";

const std::string& Function<FILE *(*)(const char *, const char *), ::popen>::GetName() const
{
	return __popen_name;
}

Object Function<FILE *(*)(const char *, const char *), ::popen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::popen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::popen.
	struct __popen_registrar
	{
		__popen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(const char *, const char *), ::popen>>());
		}
	} __popen_instance;
}



int Function<int(*)(FILE *), ::__srget>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::__srget>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::__srget>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____srget_name = "::__srget";

const std::string& Function<int(*)(FILE *), ::__srget>::GetName() const
{
	return ____srget_name;
}

Object Function<int(*)(FILE *), ::__srget>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::__srget(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::__srget.
	struct ____srget_registrar
	{
		____srget_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::__srget>>());
		}
	} ____srget_instance;
}



int Function<int(*)(FILE *, const char *, va_list), ::__svfscanf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, const char *, va_list), ::__svfscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const char *, va_list), ::__svfscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____svfscanf_name = "::__svfscanf";

const std::string& Function<int(*)(FILE *, const char *, va_list), ::__svfscanf>::GetName() const
{
	return ____svfscanf_name;
}

Object Function<int(*)(FILE *, const char *, va_list), ::__svfscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::__svfscanf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::__svfscanf.
	struct ____svfscanf_registrar
	{
		____svfscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const char *, va_list), ::__svfscanf>>());
		}
	} ____svfscanf_instance;
}



int Function<int(*)(int, FILE *), ::__swbuf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), ::__swbuf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), ::__swbuf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____swbuf_name = "::__swbuf";

const std::string& Function<int(*)(int, FILE *), ::__swbuf>::GetName() const
{
	return ____swbuf_name;
}

Object Function<int(*)(int, FILE *), ::__swbuf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::__swbuf(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::__swbuf.
	struct ____swbuf_registrar
	{
		____swbuf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), ::__swbuf>>());
		}
	} ____swbuf_instance;
}



int Function<int(*)(int, FILE *), __sputc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), __sputc>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), __sputc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	case 1:
		result.name = "_p";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __sputc_name = "__sputc";

const std::string& Function<int(*)(int, FILE *), __sputc>::GetName() const
{
	return __sputc_name;
}

Object Function<int(*)(int, FILE *), __sputc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(__sputc(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register __sputc.
	struct __sputc_registrar
	{
		__sputc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), __sputc>>());
		}
	} __sputc_instance;
}



int Function<void(*)(FILE *), ::flockfile>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(FILE *), ::flockfile>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(FILE *), ::flockfile>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __flockfile_name = "::flockfile";

const std::string& Function<void(*)(FILE *), ::flockfile>::GetName() const
{
	return __flockfile_name;
}

Object Function<void(*)(FILE *), ::flockfile>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::flockfile(args[0].GetT<std::decay_t<FILE *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::flockfile.
	struct __flockfile_registrar
	{
		__flockfile_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(FILE *), ::flockfile>>());
		}
	} __flockfile_instance;
}



int Function<int(*)(FILE *), ::ftrylockfile>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::ftrylockfile>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::ftrylockfile>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ftrylockfile_name = "::ftrylockfile";

const std::string& Function<int(*)(FILE *), ::ftrylockfile>::GetName() const
{
	return __ftrylockfile_name;
}

Object Function<int(*)(FILE *), ::ftrylockfile>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ftrylockfile(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::ftrylockfile.
	struct __ftrylockfile_registrar
	{
		__ftrylockfile_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::ftrylockfile>>());
		}
	} __ftrylockfile_instance;
}



int Function<void(*)(FILE *), ::funlockfile>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(FILE *), ::funlockfile>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(FILE *), ::funlockfile>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __funlockfile_name = "::funlockfile";

const std::string& Function<void(*)(FILE *), ::funlockfile>::GetName() const
{
	return __funlockfile_name;
}

Object Function<void(*)(FILE *), ::funlockfile>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::funlockfile(args[0].GetT<std::decay_t<FILE *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::funlockfile.
	struct __funlockfile_registrar
	{
		__funlockfile_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(FILE *), ::funlockfile>>());
		}
	} __funlockfile_instance;
}



int Function<int(*)(FILE *), ::getc_unlocked>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::getc_unlocked>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::getc_unlocked>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getc_unlocked_name = "::getc_unlocked";

const std::string& Function<int(*)(FILE *), ::getc_unlocked>::GetName() const
{
	return __getc_unlocked_name;
}

Object Function<int(*)(FILE *), ::getc_unlocked>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getc_unlocked(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::getc_unlocked.
	struct __getc_unlocked_registrar
	{
		__getc_unlocked_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::getc_unlocked>>());
		}
	} __getc_unlocked_instance;
}



int Function<int(*)(), ::getchar_unlocked>::GetParameterCount() const
{
	return 0;
}

Parameter Function<int(*)(), ::getchar_unlocked>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(), ::getchar_unlocked>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __getchar_unlocked_name = "::getchar_unlocked";

const std::string& Function<int(*)(), ::getchar_unlocked>::GetName() const
{
	return __getchar_unlocked_name;
}

Object Function<int(*)(), ::getchar_unlocked>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getchar_unlocked());
}

namespace
{
	// Object to auto-register ::getchar_unlocked.
	struct __getchar_unlocked_registrar
	{
		__getchar_unlocked_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(), ::getchar_unlocked>>());
		}
	} __getchar_unlocked_instance;
}



int Function<int(*)(int, FILE *), ::putc_unlocked>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), ::putc_unlocked>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), ::putc_unlocked>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putc_unlocked_name = "::putc_unlocked";

const std::string& Function<int(*)(int, FILE *), ::putc_unlocked>::GetName() const
{
	return __putc_unlocked_name;
}

Object Function<int(*)(int, FILE *), ::putc_unlocked>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putc_unlocked(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::putc_unlocked.
	struct __putc_unlocked_registrar
	{
		__putc_unlocked_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), ::putc_unlocked>>());
		}
	} __putc_unlocked_instance;
}



int Function<int(*)(int), ::putchar_unlocked>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ::putchar_unlocked>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ::putchar_unlocked>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putchar_unlocked_name = "::putchar_unlocked";

const std::string& Function<int(*)(int), ::putchar_unlocked>::GetName() const
{
	return __putchar_unlocked_name;
}

Object Function<int(*)(int), ::putchar_unlocked>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putchar_unlocked(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::putchar_unlocked.
	struct __putchar_unlocked_registrar
	{
		__putchar_unlocked_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ::putchar_unlocked>>());
		}
	} __putchar_unlocked_instance;
}



int Function<int(*)(FILE *), ::getw>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::getw>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::getw>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getw_name = "::getw";

const std::string& Function<int(*)(FILE *), ::getw>::GetName() const
{
	return __getw_name;
}

Object Function<int(*)(FILE *), ::getw>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getw(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::getw.
	struct __getw_registrar
	{
		__getw_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::getw>>());
		}
	} __getw_instance;
}



int Function<int(*)(int, FILE *), ::putw>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, FILE *), ::putw>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, FILE *), ::putw>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putw_name = "::putw";

const std::string& Function<int(*)(int, FILE *), ::putw>::GetName() const
{
	return __putw_name;
}

Object Function<int(*)(int, FILE *), ::putw>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putw(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::putw.
	struct __putw_registrar
	{
		__putw_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, FILE *), ::putw>>());
		}
	} __putw_instance;
}



int Function<char *(*)(const char *, const char *), ::tempnam>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const char *, const char *), ::tempnam>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, const char *), ::tempnam>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__dir";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__prefix";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __tempnam_name = "::tempnam";

const std::string& Function<char *(*)(const char *, const char *), ::tempnam>::GetName() const
{
	return __tempnam_name;
}

Object Function<char *(*)(const char *, const char *), ::tempnam>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::tempnam(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::tempnam.
	struct __tempnam_registrar
	{
		__tempnam_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, const char *), ::tempnam>>());
		}
	} __tempnam_instance;
}



int Function<int(*)(FILE *, off_t, int), ::fseeko>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, off_t, int), ::fseeko>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, off_t, int), ::fseeko>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "__offset";
		result.type = "off_t";
		break;
	case 2:
		result.name = "__whence";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fseeko_name = "::fseeko";

const std::string& Function<int(*)(FILE *, off_t, int), ::fseeko>::GetName() const
{
	return __fseeko_name;
}

Object Function<int(*)(FILE *, off_t, int), ::fseeko>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fseeko(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<off_t>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::fseeko.
	struct __fseeko_registrar
	{
		__fseeko_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, off_t, int), ::fseeko>>());
		}
	} __fseeko_instance;
}



int Function<off_t(*)(FILE *), ::ftello>::GetParameterCount() const
{
	return 1;
}

Parameter Function<off_t(*)(FILE *), ::ftello>::GetReturnType() const
{
	Parameter result;
	result.type = "off_t";
	return result;
}

Parameter Function<off_t(*)(FILE *), ::ftello>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ftello_name = "::ftello";

const std::string& Function<off_t(*)(FILE *), ::ftello>::GetName() const
{
	return __ftello_name;
}

Object Function<off_t(*)(FILE *), ::ftello>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ftello(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::ftello.
	struct __ftello_registrar
	{
		__ftello_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<off_t(*)(FILE *), ::ftello>>());
		}
	} __ftello_instance;
}



int Function<int(*)(char *, size_t, const char *), ::snprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char *, size_t, const char *), ::snprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, size_t, const char *), ::snprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "char *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__format";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __snprintf_name = "::snprintf";

const std::string& Function<int(*)(char *, size_t, const char *), ::snprintf>::GetName() const
{
	return __snprintf_name;
}

Object Function<int(*)(char *, size_t, const char *), ::snprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::snprintf(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::snprintf.
	struct __snprintf_registrar
	{
		__snprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, size_t, const char *), ::snprintf>>());
		}
	} __snprintf_instance;
}



int Function<int(*)(FILE *, const char *, va_list), ::vfscanf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, const char *, va_list), ::vfscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const char *, va_list), ::vfscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "__format";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vfscanf_name = "::vfscanf";

const std::string& Function<int(*)(FILE *, const char *, va_list), ::vfscanf>::GetName() const
{
	return __vfscanf_name;
}

Object Function<int(*)(FILE *, const char *, va_list), ::vfscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vfscanf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vfscanf.
	struct __vfscanf_registrar
	{
		__vfscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const char *, va_list), ::vfscanf>>());
		}
	} __vfscanf_instance;
}



int Function<int(*)(const char *, va_list), ::vscanf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const char *, va_list), ::vscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, va_list), ::vscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__format";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vscanf_name = "::vscanf";

const std::string& Function<int(*)(const char *, va_list), ::vscanf>::GetName() const
{
	return __vscanf_name;
}

Object Function<int(*)(const char *, va_list), ::vscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vscanf(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vscanf.
	struct __vscanf_registrar
	{
		__vscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, va_list), ::vscanf>>());
		}
	} __vscanf_instance;
}



int Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "char *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__format";
		result.type = "const char *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vsnprintf_name = "::vsnprintf";

const std::string& Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf>::GetName() const
{
	return __vsnprintf_name;
}

Object Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vsnprintf(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const char *>>(), args[3].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vsnprintf.
	struct __vsnprintf_registrar
	{
		__vsnprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char *, size_t, const char *, va_list), ::vsnprintf>>());
		}
	} __vsnprintf_instance;
}



int Function<int(*)(const char *, const char *, va_list), ::vsscanf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const char *, const char *, va_list), ::vsscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const char *, const char *, va_list), ::vsscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__str";
		result.type = "const char *";
		break;
	case 1:
		result.name = "__format";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vsscanf_name = "::vsscanf";

const std::string& Function<int(*)(const char *, const char *, va_list), ::vsscanf>::GetName() const
{
	return __vsscanf_name;
}

Object Function<int(*)(const char *, const char *, va_list), ::vsscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vsscanf(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vsscanf.
	struct __vsscanf_registrar
	{
		__vsscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const char *, const char *, va_list), ::vsscanf>>());
		}
	} __vsscanf_instance;
}



int Function<int(*)(int, const char *), ::dprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(int, const char *), ::dprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, const char *), ::dprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __dprintf_name = "::dprintf";

const std::string& Function<int(*)(int, const char *), ::dprintf>::GetName() const
{
	return __dprintf_name;
}

Object Function<int(*)(int, const char *), ::dprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::dprintf(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::dprintf.
	struct __dprintf_registrar
	{
		__dprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, const char *), ::dprintf>>());
		}
	} __dprintf_instance;
}



int Function<int(*)(int, const char *, va_list), ::vdprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(int, const char *, va_list), ::vdprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int, const char *, va_list), ::vdprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vdprintf_name = "::vdprintf";

const std::string& Function<int(*)(int, const char *, va_list), ::vdprintf>::GetName() const
{
	return __vdprintf_name;
}

Object Function<int(*)(int, const char *, va_list), ::vdprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vdprintf(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vdprintf.
	struct __vdprintf_registrar
	{
		__vdprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int, const char *, va_list), ::vdprintf>>());
		}
	} __vdprintf_instance;
}



int Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim>::GetParameterCount() const
{
	return 4;
}

Parameter Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim>::GetReturnType() const
{
	Parameter result;
	result.type = "ssize_t";
	return result;
}

Parameter Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__linep";
		result.type = "char **";
		break;
	case 1:
		result.name = "__linecapp";
		result.type = "size_t *";
		break;
	case 2:
		result.name = "__delimiter";
		result.type = "int";
		break;
	case 3:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getdelim_name = "::getdelim";

const std::string& Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim>::GetName() const
{
	return __getdelim_name;
}

Object Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getdelim(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<size_t *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::getdelim.
	struct __getdelim_registrar
	{
		__getdelim_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<ssize_t(*)(char **, size_t *, int, FILE *), ::getdelim>>());
		}
	} __getdelim_instance;
}



int Function<ssize_t(*)(char **, size_t *, FILE *), ::getline>::GetParameterCount() const
{
	return 3;
}

Parameter Function<ssize_t(*)(char **, size_t *, FILE *), ::getline>::GetReturnType() const
{
	Parameter result;
	result.type = "ssize_t";
	return result;
}

Parameter Function<ssize_t(*)(char **, size_t *, FILE *), ::getline>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__linep";
		result.type = "char **";
		break;
	case 1:
		result.name = "__linecapp";
		result.type = "size_t *";
		break;
	case 2:
		result.name = "__stream";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getline_name = "::getline";

const std::string& Function<ssize_t(*)(char **, size_t *, FILE *), ::getline>::GetName() const
{
	return __getline_name;
}

Object Function<ssize_t(*)(char **, size_t *, FILE *), ::getline>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getline(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<size_t *>>(), args[2].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::getline.
	struct __getline_registrar
	{
		__getline_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<ssize_t(*)(char **, size_t *, FILE *), ::getline>>());
		}
	} __getline_instance;
}



int Function<FILE *(*)(void *, size_t, const char *), ::fmemopen>::GetParameterCount() const
{
	return 3;
}

Parameter Function<FILE *(*)(void *, size_t, const char *), ::fmemopen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(void *, size_t, const char *), ::fmemopen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__buf";
		result.type = "void *";
		break;
	case 1:
		result.name = "__size";
		result.type = "size_t";
		break;
	case 2:
		result.name = "__mode";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fmemopen_name = "::fmemopen";

const std::string& Function<FILE *(*)(void *, size_t, const char *), ::fmemopen>::GetName() const
{
	return __fmemopen_name;
}

Object Function<FILE *(*)(void *, size_t, const char *), ::fmemopen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fmemopen(args[0].GetT<std::decay_t<void *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::fmemopen.
	struct __fmemopen_registrar
	{
		__fmemopen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(void *, size_t, const char *), ::fmemopen>>());
		}
	} __fmemopen_instance;
}



int Function<FILE *(*)(char **, size_t *), ::open_memstream>::GetParameterCount() const
{
	return 2;
}

Parameter Function<FILE *(*)(char **, size_t *), ::open_memstream>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(char **, size_t *), ::open_memstream>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__bufp";
		result.type = "char **";
		break;
	case 1:
		result.name = "__sizep";
		result.type = "size_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __open_memstream_name = "::open_memstream";

const std::string& Function<FILE *(*)(char **, size_t *), ::open_memstream>::GetName() const
{
	return __open_memstream_name;
}

Object Function<FILE *(*)(char **, size_t *), ::open_memstream>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::open_memstream(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<size_t *>>()));
}

namespace
{
	// Object to auto-register ::open_memstream.
	struct __open_memstream_registrar
	{
		__open_memstream_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(char **, size_t *), ::open_memstream>>());
		}
	} __open_memstream_instance;
}



int Function<int(*)(char **, const char *), ::asprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(char **, const char *), ::asprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char **, const char *), ::asprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __asprintf_name = "::asprintf";

const std::string& Function<int(*)(char **, const char *), ::asprintf>::GetName() const
{
	return __asprintf_name;
}

Object Function<int(*)(char **, const char *), ::asprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::asprintf(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::asprintf.
	struct __asprintf_registrar
	{
		__asprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char **, const char *), ::asprintf>>());
		}
	} __asprintf_instance;
}



int Function<char *(*)(char *), ::ctermid_r>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(char *), ::ctermid_r>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(char *), ::ctermid_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ctermid_r_name = "::ctermid_r";

const std::string& Function<char *(*)(char *), ::ctermid_r>::GetName() const
{
	return __ctermid_r_name;
}

Object Function<char *(*)(char *), ::ctermid_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ctermid_r(args[0].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::ctermid_r.
	struct __ctermid_r_registrar
	{
		__ctermid_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(char *), ::ctermid_r>>());
		}
	} __ctermid_r_instance;
}



int Function<char *(*)(FILE *, size_t *), ::fgetln>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(FILE *, size_t *), ::fgetln>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(FILE *, size_t *), ::fgetln>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgetln_name = "::fgetln";

const std::string& Function<char *(*)(FILE *, size_t *), ::fgetln>::GetName() const
{
	return __fgetln_name;
}

Object Function<char *(*)(FILE *, size_t *), ::fgetln>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgetln(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<size_t *>>()));
}

namespace
{
	// Object to auto-register ::fgetln.
	struct __fgetln_registrar
	{
		__fgetln_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(FILE *, size_t *), ::fgetln>>());
		}
	} __fgetln_instance;
}



int Function<const char *(*)(const char *, const char *), ::fmtcheck>::GetParameterCount() const
{
	return 2;
}

Parameter Function<const char *(*)(const char *, const char *), ::fmtcheck>::GetReturnType() const
{
	Parameter result;
	result.type = "const char *";
	return result;
}

Parameter Function<const char *(*)(const char *, const char *), ::fmtcheck>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fmtcheck_name = "::fmtcheck";

const std::string& Function<const char *(*)(const char *, const char *), ::fmtcheck>::GetName() const
{
	return __fmtcheck_name;
}

Object Function<const char *(*)(const char *, const char *), ::fmtcheck>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fmtcheck(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::fmtcheck.
	struct __fmtcheck_registrar
	{
		__fmtcheck_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<const char *(*)(const char *, const char *), ::fmtcheck>>());
		}
	} __fmtcheck_instance;
}



int Function<int(*)(FILE *), ::fpurge>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::fpurge>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::fpurge>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fpurge_name = "::fpurge";

const std::string& Function<int(*)(FILE *), ::fpurge>::GetName() const
{
	return __fpurge_name;
}

Object Function<int(*)(FILE *), ::fpurge>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fpurge(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fpurge.
	struct __fpurge_registrar
	{
		__fpurge_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::fpurge>>());
		}
	} __fpurge_instance;
}



int Function<void(*)(FILE *, char *, int), ::setbuffer>::GetParameterCount() const
{
	return 3;
}

Parameter Function<void(*)(FILE *, char *, int), ::setbuffer>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(FILE *, char *, int), ::setbuffer>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setbuffer_name = "::setbuffer";

const std::string& Function<void(*)(FILE *, char *, int), ::setbuffer>::GetName() const
{
	return __setbuffer_name;
}

Object Function<void(*)(FILE *, char *, int), ::setbuffer>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::setbuffer(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<char *>>(), args[2].GetT<std::decay_t<int>>());
	return Object();
}

namespace
{
	// Object to auto-register ::setbuffer.
	struct __setbuffer_registrar
	{
		__setbuffer_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(FILE *, char *, int), ::setbuffer>>());
		}
	} __setbuffer_instance;
}



int Function<int(*)(FILE *), ::setlinebuf>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(FILE *), ::setlinebuf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *), ::setlinebuf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __setlinebuf_name = "::setlinebuf";

const std::string& Function<int(*)(FILE *), ::setlinebuf>::GetName() const
{
	return __setlinebuf_name;
}

Object Function<int(*)(FILE *), ::setlinebuf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::setlinebuf(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::setlinebuf.
	struct __setlinebuf_registrar
	{
		__setlinebuf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *), ::setlinebuf>>());
		}
	} __setlinebuf_instance;
}



int Function<int(*)(char **, const char *, va_list), ::vasprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(char **, const char *, va_list), ::vasprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(char **, const char *, va_list), ::vasprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char **";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vasprintf_name = "::vasprintf";

const std::string& Function<int(*)(char **, const char *, va_list), ::vasprintf>::GetName() const
{
	return __vasprintf_name;
}

Object Function<int(*)(char **, const char *, va_list), ::vasprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vasprintf(args[0].GetT<std::decay_t<char **>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<va_list>>()));
}

namespace
{
	// Object to auto-register ::vasprintf.
	struct __vasprintf_registrar
	{
		__vasprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(char **, const char *, va_list), ::vasprintf>>());
		}
	} __vasprintf_instance;
}



int Function<FILE *(*)(const char *, const char *, int), ::zopen>::GetParameterCount() const
{
	return 3;
}

Parameter Function<FILE *(*)(const char *, const char *, int), ::zopen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(const char *, const char *, int), ::zopen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __zopen_name = "::zopen";

const std::string& Function<FILE *(*)(const char *, const char *, int), ::zopen>::GetName() const
{
	return __zopen_name;
}

Object Function<FILE *(*)(const char *, const char *, int), ::zopen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::zopen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::zopen.
	struct __zopen_registrar
	{
		__zopen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(const char *, const char *, int), ::zopen>>());
		}
	} __zopen_instance;
}



int Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen>::GetParameterCount() const
{
	return 5;
}

Parameter Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const void *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int (*)(void *, char *, int)";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int (*)(void *, const char *, int)";
		break;
	case 3:
		result.name = "nameless";
		result.type = "fpos_t (*)(void *, fpos_t, int)";
		break;
	case 4:
		result.name = "nameless";
		result.type = "int (*)(void *)";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __funopen_name = "::funopen";

const std::string& Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen>::GetName() const
{
	return __funopen_name;
}

Object Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::funopen(args[0].GetT<std::decay_t<const void *>>(), args[1].GetT<std::decay_t<int (*)(void *, char *, int)>>(), args[2].GetT<std::decay_t<int (*)(void *, const char *, int)>>(), args[3].GetT<std::decay_t<fpos_t (*)(void *, fpos_t, int)>>(), args[4].GetT<std::decay_t<int (*)(void *)>>()));
}

namespace
{
	// Object to auto-register ::funopen.
	struct __funopen_registrar
	{
		__funopen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *)), ::funopen>>());
		}
	} __funopen_instance;
}



const int Class<timespec>::FieldCount;
const int Class<timespec>::StaticFieldCount;
const int Class<timespec>::MethodCount;
const int Class<timespec>::StaticMethodCount;

int Class<timespec>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<timespec>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<timespec>())
	{
		timespec& o = r.GetT<timespec>();
		if (name == "tv_sec")
		{
			return Reference(o.tv_sec);
		}
		if (name == "tv_nsec")
		{
			return Reference(o.tv_nsec);
		}
	}
	else if (r.IsT<const timespec>())
	{
		const timespec& o = r.GetT<const timespec>();
		if (name == "tv_sec")
		{
			return Reference(o.tv_sec);
		}
		if (name == "tv_nsec")
		{
			return Reference(o.tv_nsec);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<timespec>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<timespec>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<timespec>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<timespec>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<timespec>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<timespec>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string timespec_name = "timespec";

const std::string& Class<timespec>::GetName() const
{
	return timespec_name;
}



namespace
{
	// Object to auto-register timespec.
	struct timespec_registrar
	{
		timespec_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<timespec>>());
		}
	} timespec_instance;
}


const int Class<tm>::FieldCount;
const int Class<tm>::StaticFieldCount;
const int Class<tm>::MethodCount;
const int Class<tm>::StaticMethodCount;

int Class<tm>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<tm>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<tm>())
	{
		tm& o = r.GetT<tm>();
		if (name == "tm_sec")
		{
			return Reference(o.tm_sec);
		}
		if (name == "tm_min")
		{
			return Reference(o.tm_min);
		}
		if (name == "tm_hour")
		{
			return Reference(o.tm_hour);
		}
		if (name == "tm_mday")
		{
			return Reference(o.tm_mday);
		}
		if (name == "tm_mon")
		{
			return Reference(o.tm_mon);
		}
		if (name == "tm_year")
		{
			return Reference(o.tm_year);
		}
		if (name == "tm_wday")
		{
			return Reference(o.tm_wday);
		}
		if (name == "tm_yday")
		{
			return Reference(o.tm_yday);
		}
		if (name == "tm_isdst")
		{
			return Reference(o.tm_isdst);
		}
		if (name == "tm_gmtoff")
		{
			return Reference(o.tm_gmtoff);
		}
		if (name == "tm_zone")
		{
			return Reference(o.tm_zone);
		}
	}
	else if (r.IsT<const tm>())
	{
		const tm& o = r.GetT<const tm>();
		if (name == "tm_sec")
		{
			return Reference(o.tm_sec);
		}
		if (name == "tm_min")
		{
			return Reference(o.tm_min);
		}
		if (name == "tm_hour")
		{
			return Reference(o.tm_hour);
		}
		if (name == "tm_mday")
		{
			return Reference(o.tm_mday);
		}
		if (name == "tm_mon")
		{
			return Reference(o.tm_mon);
		}
		if (name == "tm_year")
		{
			return Reference(o.tm_year);
		}
		if (name == "tm_wday")
		{
			return Reference(o.tm_wday);
		}
		if (name == "tm_yday")
		{
			return Reference(o.tm_yday);
		}
		if (name == "tm_isdst")
		{
			return Reference(o.tm_isdst);
		}
		if (name == "tm_gmtoff")
		{
			return Reference(o.tm_gmtoff);
		}
		if (name == "tm_zone")
		{
			return Reference(o.tm_zone);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<tm>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<tm>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<tm>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<tm>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<tm>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<tm>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string tm_name = "tm";

const std::string& Class<tm>::GetName() const
{
	return tm_name;
}



namespace
{
	// Object to auto-register tm.
	struct tm_registrar
	{
		tm_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<tm>>());
		}
	} tm_instance;
}


int Function<char *(*)(const struct tm *), ::asctime>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(const struct tm *), ::asctime>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const struct tm *), ::asctime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __asctime_name = "::asctime";

const std::string& Function<char *(*)(const struct tm *), ::asctime>::GetName() const
{
	return __asctime_name;
}

Object Function<char *(*)(const struct tm *), ::asctime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::asctime(args[0].GetT<std::decay_t<const struct tm *>>()));
}

namespace
{
	// Object to auto-register ::asctime.
	struct __asctime_registrar
	{
		__asctime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const struct tm *), ::asctime>>());
		}
	} __asctime_instance;
}



int Function<clock_t(*)(), ::clock>::GetParameterCount() const
{
	return 0;
}

Parameter Function<clock_t(*)(), ::clock>::GetReturnType() const
{
	Parameter result;
	result.type = "clock_t";
	return result;
}

Parameter Function<clock_t(*)(), ::clock>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __clock_name = "::clock";

const std::string& Function<clock_t(*)(), ::clock>::GetName() const
{
	return __clock_name;
}

Object Function<clock_t(*)(), ::clock>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::clock());
}

namespace
{
	// Object to auto-register ::clock.
	struct __clock_registrar
	{
		__clock_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<clock_t(*)(), ::clock>>());
		}
	} __clock_instance;
}



int Function<char *(*)(const time_t *), ::ctime>::GetParameterCount() const
{
	return 1;
}

Parameter Function<char *(*)(const time_t *), ::ctime>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const time_t *), ::ctime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const time_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ctime_name = "::ctime";

const std::string& Function<char *(*)(const time_t *), ::ctime>::GetName() const
{
	return __ctime_name;
}

Object Function<char *(*)(const time_t *), ::ctime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ctime(args[0].GetT<std::decay_t<const time_t *>>()));
}

namespace
{
	// Object to auto-register ::ctime.
	struct __ctime_registrar
	{
		__ctime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const time_t *), ::ctime>>());
		}
	} __ctime_instance;
}



int Function<double(*)(time_t, time_t), ::difftime>::GetParameterCount() const
{
	return 2;
}

Parameter Function<double(*)(time_t, time_t), ::difftime>::GetReturnType() const
{
	Parameter result;
	result.type = "double";
	return result;
}

Parameter Function<double(*)(time_t, time_t), ::difftime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "time_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "time_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __difftime_name = "::difftime";

const std::string& Function<double(*)(time_t, time_t), ::difftime>::GetName() const
{
	return __difftime_name;
}

Object Function<double(*)(time_t, time_t), ::difftime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::difftime(args[0].GetT<std::decay_t<time_t>>(), args[1].GetT<std::decay_t<time_t>>()));
}

namespace
{
	// Object to auto-register ::difftime.
	struct __difftime_registrar
	{
		__difftime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<double(*)(time_t, time_t), ::difftime>>());
		}
	} __difftime_instance;
}



int Function<struct tm *(*)(const char *), ::getdate>::GetParameterCount() const
{
	return 1;
}

Parameter Function<struct tm *(*)(const char *), ::getdate>::GetReturnType() const
{
	Parameter result;
	result.type = "struct tm *";
	return result;
}

Parameter Function<struct tm *(*)(const char *), ::getdate>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getdate_name = "::getdate";

const std::string& Function<struct tm *(*)(const char *), ::getdate>::GetName() const
{
	return __getdate_name;
}

Object Function<struct tm *(*)(const char *), ::getdate>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getdate(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::getdate.
	struct __getdate_registrar
	{
		__getdate_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<struct tm *(*)(const char *), ::getdate>>());
		}
	} __getdate_instance;
}



int Function<struct tm *(*)(const time_t *), ::gmtime>::GetParameterCount() const
{
	return 1;
}

Parameter Function<struct tm *(*)(const time_t *), ::gmtime>::GetReturnType() const
{
	Parameter result;
	result.type = "struct tm *";
	return result;
}

Parameter Function<struct tm *(*)(const time_t *), ::gmtime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const time_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __gmtime_name = "::gmtime";

const std::string& Function<struct tm *(*)(const time_t *), ::gmtime>::GetName() const
{
	return __gmtime_name;
}

Object Function<struct tm *(*)(const time_t *), ::gmtime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::gmtime(args[0].GetT<std::decay_t<const time_t *>>()));
}

namespace
{
	// Object to auto-register ::gmtime.
	struct __gmtime_registrar
	{
		__gmtime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<struct tm *(*)(const time_t *), ::gmtime>>());
		}
	} __gmtime_instance;
}



int Function<struct tm *(*)(const time_t *), ::localtime>::GetParameterCount() const
{
	return 1;
}

Parameter Function<struct tm *(*)(const time_t *), ::localtime>::GetReturnType() const
{
	Parameter result;
	result.type = "struct tm *";
	return result;
}

Parameter Function<struct tm *(*)(const time_t *), ::localtime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const time_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __localtime_name = "::localtime";

const std::string& Function<struct tm *(*)(const time_t *), ::localtime>::GetName() const
{
	return __localtime_name;
}

Object Function<struct tm *(*)(const time_t *), ::localtime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::localtime(args[0].GetT<std::decay_t<const time_t *>>()));
}

namespace
{
	// Object to auto-register ::localtime.
	struct __localtime_registrar
	{
		__localtime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<struct tm *(*)(const time_t *), ::localtime>>());
		}
	} __localtime_instance;
}



int Function<time_t(*)(struct tm *), ::mktime>::GetParameterCount() const
{
	return 1;
}

Parameter Function<time_t(*)(struct tm *), ::mktime>::GetReturnType() const
{
	Parameter result;
	result.type = "time_t";
	return result;
}

Parameter Function<time_t(*)(struct tm *), ::mktime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mktime_name = "::mktime";

const std::string& Function<time_t(*)(struct tm *), ::mktime>::GetName() const
{
	return __mktime_name;
}

Object Function<time_t(*)(struct tm *), ::mktime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mktime(args[0].GetT<std::decay_t<struct tm *>>()));
}

namespace
{
	// Object to auto-register ::mktime.
	struct __mktime_registrar
	{
		__mktime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<time_t(*)(struct tm *), ::mktime>>());
		}
	} __mktime_instance;
}



int Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "const struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strftime_name = "::strftime";

const std::string& Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime>::GetName() const
{
	return __strftime_name;
}

Object Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strftime(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const char *>>(), args[3].GetT<std::decay_t<const struct tm *>>()));
}

namespace
{
	// Object to auto-register ::strftime.
	struct __strftime_registrar
	{
		__strftime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, size_t, const char *, const struct tm *), ::strftime>>());
		}
	} __strftime_instance;
}



int Function<char *(*)(const char *, const char *, struct tm *), ::strptime>::GetParameterCount() const
{
	return 3;
}

Parameter Function<char *(*)(const char *, const char *, struct tm *), ::strptime>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const char *, const char *, struct tm *), ::strptime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __strptime_name = "::strptime";

const std::string& Function<char *(*)(const char *, const char *, struct tm *), ::strptime>::GetName() const
{
	return __strptime_name;
}

Object Function<char *(*)(const char *, const char *, struct tm *), ::strptime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::strptime(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<struct tm *>>()));
}

namespace
{
	// Object to auto-register ::strptime.
	struct __strptime_registrar
	{
		__strptime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const char *, const char *, struct tm *), ::strptime>>());
		}
	} __strptime_instance;
}



int Function<time_t(*)(time_t *), ::time>::GetParameterCount() const
{
	return 1;
}

Parameter Function<time_t(*)(time_t *), ::time>::GetReturnType() const
{
	Parameter result;
	result.type = "time_t";
	return result;
}

Parameter Function<time_t(*)(time_t *), ::time>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "time_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __time_name = "::time";

const std::string& Function<time_t(*)(time_t *), ::time>::GetName() const
{
	return __time_name;
}

Object Function<time_t(*)(time_t *), ::time>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::time(args[0].GetT<std::decay_t<time_t *>>()));
}

namespace
{
	// Object to auto-register ::time.
	struct __time_registrar
	{
		__time_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<time_t(*)(time_t *), ::time>>());
		}
	} __time_instance;
}



int Function<void(*)(), ::tzset>::GetParameterCount() const
{
	return 0;
}

Parameter Function<void(*)(), ::tzset>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(), ::tzset>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __tzset_name = "::tzset";

const std::string& Function<void(*)(), ::tzset>::GetName() const
{
	return __tzset_name;
}

Object Function<void(*)(), ::tzset>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::tzset();
	return Object();
}

namespace
{
	// Object to auto-register ::tzset.
	struct __tzset_registrar
	{
		__tzset_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(), ::tzset>>());
		}
	} __tzset_instance;
}



int Function<char *(*)(const struct tm *, char *), ::asctime_r>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const struct tm *, char *), ::asctime_r>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const struct tm *, char *), ::asctime_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const struct tm *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __asctime_r_name = "::asctime_r";

const std::string& Function<char *(*)(const struct tm *, char *), ::asctime_r>::GetName() const
{
	return __asctime_r_name;
}

Object Function<char *(*)(const struct tm *, char *), ::asctime_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::asctime_r(args[0].GetT<std::decay_t<const struct tm *>>(), args[1].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::asctime_r.
	struct __asctime_r_registrar
	{
		__asctime_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const struct tm *, char *), ::asctime_r>>());
		}
	} __asctime_r_instance;
}



int Function<char *(*)(const time_t *, char *), ::ctime_r>::GetParameterCount() const
{
	return 2;
}

Parameter Function<char *(*)(const time_t *, char *), ::ctime_r>::GetReturnType() const
{
	Parameter result;
	result.type = "char *";
	return result;
}

Parameter Function<char *(*)(const time_t *, char *), ::ctime_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const time_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ctime_r_name = "::ctime_r";

const std::string& Function<char *(*)(const time_t *, char *), ::ctime_r>::GetName() const
{
	return __ctime_r_name;
}

Object Function<char *(*)(const time_t *, char *), ::ctime_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ctime_r(args[0].GetT<std::decay_t<const time_t *>>(), args[1].GetT<std::decay_t<char *>>()));
}

namespace
{
	// Object to auto-register ::ctime_r.
	struct __ctime_r_registrar
	{
		__ctime_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<char *(*)(const time_t *, char *), ::ctime_r>>());
		}
	} __ctime_r_instance;
}



int Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r>::GetParameterCount() const
{
	return 2;
}

Parameter Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r>::GetReturnType() const
{
	Parameter result;
	result.type = "struct tm *";
	return result;
}

Parameter Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const time_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __gmtime_r_name = "::gmtime_r";

const std::string& Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r>::GetName() const
{
	return __gmtime_r_name;
}

Object Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::gmtime_r(args[0].GetT<std::decay_t<const time_t *>>(), args[1].GetT<std::decay_t<struct tm *>>()));
}

namespace
{
	// Object to auto-register ::gmtime_r.
	struct __gmtime_r_registrar
	{
		__gmtime_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<struct tm *(*)(const time_t *, struct tm *), ::gmtime_r>>());
		}
	} __gmtime_r_instance;
}



int Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r>::GetParameterCount() const
{
	return 2;
}

Parameter Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r>::GetReturnType() const
{
	Parameter result;
	result.type = "struct tm *";
	return result;
}

Parameter Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const time_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __localtime_r_name = "::localtime_r";

const std::string& Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r>::GetName() const
{
	return __localtime_r_name;
}

Object Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::localtime_r(args[0].GetT<std::decay_t<const time_t *>>(), args[1].GetT<std::decay_t<struct tm *>>()));
}

namespace
{
	// Object to auto-register ::localtime_r.
	struct __localtime_r_registrar
	{
		__localtime_r_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<struct tm *(*)(const time_t *, struct tm *), ::localtime_r>>());
		}
	} __localtime_r_instance;
}



int Function<time_t(*)(time_t), ::posix2time>::GetParameterCount() const
{
	return 1;
}

Parameter Function<time_t(*)(time_t), ::posix2time>::GetReturnType() const
{
	Parameter result;
	result.type = "time_t";
	return result;
}

Parameter Function<time_t(*)(time_t), ::posix2time>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "time_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __posix2time_name = "::posix2time";

const std::string& Function<time_t(*)(time_t), ::posix2time>::GetName() const
{
	return __posix2time_name;
}

Object Function<time_t(*)(time_t), ::posix2time>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::posix2time(args[0].GetT<std::decay_t<time_t>>()));
}

namespace
{
	// Object to auto-register ::posix2time.
	struct __posix2time_registrar
	{
		__posix2time_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<time_t(*)(time_t), ::posix2time>>());
		}
	} __posix2time_instance;
}



int Function<void(*)(), ::tzsetwall>::GetParameterCount() const
{
	return 0;
}

Parameter Function<void(*)(), ::tzsetwall>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(), ::tzsetwall>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __tzsetwall_name = "::tzsetwall";

const std::string& Function<void(*)(), ::tzsetwall>::GetName() const
{
	return __tzsetwall_name;
}

Object Function<void(*)(), ::tzsetwall>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::tzsetwall();
	return Object();
}

namespace
{
	// Object to auto-register ::tzsetwall.
	struct __tzsetwall_registrar
	{
		__tzsetwall_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(), ::tzsetwall>>());
		}
	} __tzsetwall_instance;
}



int Function<time_t(*)(time_t), ::time2posix>::GetParameterCount() const
{
	return 1;
}

Parameter Function<time_t(*)(time_t), ::time2posix>::GetReturnType() const
{
	Parameter result;
	result.type = "time_t";
	return result;
}

Parameter Function<time_t(*)(time_t), ::time2posix>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "time_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __time2posix_name = "::time2posix";

const std::string& Function<time_t(*)(time_t), ::time2posix>::GetName() const
{
	return __time2posix_name;
}

Object Function<time_t(*)(time_t), ::time2posix>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::time2posix(args[0].GetT<std::decay_t<time_t>>()));
}

namespace
{
	// Object to auto-register ::time2posix.
	struct __time2posix_registrar
	{
		__time2posix_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<time_t(*)(time_t), ::time2posix>>());
		}
	} __time2posix_instance;
}



int Function<time_t(*)(struct tm *const), ::timelocal>::GetParameterCount() const
{
	return 1;
}

Parameter Function<time_t(*)(struct tm *const), ::timelocal>::GetReturnType() const
{
	Parameter result;
	result.type = "time_t";
	return result;
}

Parameter Function<time_t(*)(struct tm *const), ::timelocal>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "struct tm *const";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __timelocal_name = "::timelocal";

const std::string& Function<time_t(*)(struct tm *const), ::timelocal>::GetName() const
{
	return __timelocal_name;
}

Object Function<time_t(*)(struct tm *const), ::timelocal>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::timelocal(args[0].GetT<std::decay_t<struct tm *const>>()));
}

namespace
{
	// Object to auto-register ::timelocal.
	struct __timelocal_registrar
	{
		__timelocal_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<time_t(*)(struct tm *const), ::timelocal>>());
		}
	} __timelocal_instance;
}



int Function<time_t(*)(struct tm *const), ::timegm>::GetParameterCount() const
{
	return 1;
}

Parameter Function<time_t(*)(struct tm *const), ::timegm>::GetReturnType() const
{
	Parameter result;
	result.type = "time_t";
	return result;
}

Parameter Function<time_t(*)(struct tm *const), ::timegm>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "struct tm *const";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __timegm_name = "::timegm";

const std::string& Function<time_t(*)(struct tm *const), ::timegm>::GetName() const
{
	return __timegm_name;
}

Object Function<time_t(*)(struct tm *const), ::timegm>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::timegm(args[0].GetT<std::decay_t<struct tm *const>>()));
}

namespace
{
	// Object to auto-register ::timegm.
	struct __timegm_registrar
	{
		__timegm_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<time_t(*)(struct tm *const), ::timegm>>());
		}
	} __timegm_instance;
}



int Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__rqtp";
		result.type = "const struct timespec *";
		break;
	case 1:
		result.name = "__rmtp";
		result.type = "struct timespec *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __nanosleep_name = "::nanosleep";

const std::string& Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep>::GetName() const
{
	return __nanosleep_name;
}

Object Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::nanosleep(args[0].GetT<std::decay_t<const struct timespec *>>(), args[1].GetT<std::decay_t<struct timespec *>>()));
}

namespace
{
	// Object to auto-register ::nanosleep.
	struct __nanosleep_registrar
	{
		__nanosleep_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const struct timespec *, struct timespec *), ::nanosleep>>());
		}
	} __nanosleep_instance;
}



int Function<int(*)(clockid_t, struct timespec *), ::clock_getres>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(clockid_t, struct timespec *), ::clock_getres>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(clockid_t, struct timespec *), ::clock_getres>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__clock_id";
		result.type = "clockid_t";
		break;
	case 1:
		result.name = "__res";
		result.type = "struct timespec *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __clock_getres_name = "::clock_getres";

const std::string& Function<int(*)(clockid_t, struct timespec *), ::clock_getres>::GetName() const
{
	return __clock_getres_name;
}

Object Function<int(*)(clockid_t, struct timespec *), ::clock_getres>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::clock_getres(args[0].GetT<std::decay_t<clockid_t>>(), args[1].GetT<std::decay_t<struct timespec *>>()));
}

namespace
{
	// Object to auto-register ::clock_getres.
	struct __clock_getres_registrar
	{
		__clock_getres_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(clockid_t, struct timespec *), ::clock_getres>>());
		}
	} __clock_getres_instance;
}



int Function<int(*)(clockid_t, struct timespec *), ::clock_gettime>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(clockid_t, struct timespec *), ::clock_gettime>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(clockid_t, struct timespec *), ::clock_gettime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__clock_id";
		result.type = "clockid_t";
		break;
	case 1:
		result.name = "__tp";
		result.type = "struct timespec *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __clock_gettime_name = "::clock_gettime";

const std::string& Function<int(*)(clockid_t, struct timespec *), ::clock_gettime>::GetName() const
{
	return __clock_gettime_name;
}

Object Function<int(*)(clockid_t, struct timespec *), ::clock_gettime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::clock_gettime(args[0].GetT<std::decay_t<clockid_t>>(), args[1].GetT<std::decay_t<struct timespec *>>()));
}

namespace
{
	// Object to auto-register ::clock_gettime.
	struct __clock_gettime_registrar
	{
		__clock_gettime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(clockid_t, struct timespec *), ::clock_gettime>>());
		}
	} __clock_gettime_instance;
}



int Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np>::GetParameterCount() const
{
	return 1;
}

Parameter Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np>::GetReturnType() const
{
	Parameter result;
	result.type = "__uint64_t";
	return result;
}

Parameter Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__clock_id";
		result.type = "clockid_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __clock_gettime_nsec_np_name = "::clock_gettime_nsec_np";

const std::string& Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np>::GetName() const
{
	return __clock_gettime_nsec_np_name;
}

Object Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::clock_gettime_nsec_np(args[0].GetT<std::decay_t<clockid_t>>()));
}

namespace
{
	// Object to auto-register ::clock_gettime_nsec_np.
	struct __clock_gettime_nsec_np_registrar
	{
		__clock_gettime_nsec_np_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<__uint64_t(*)(clockid_t), ::clock_gettime_nsec_np>>());
		}
	} __clock_gettime_nsec_np_instance;
}



int Function<int(*)(clockid_t, const struct timespec *), ::clock_settime>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(clockid_t, const struct timespec *), ::clock_settime>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(clockid_t, const struct timespec *), ::clock_settime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__clock_id";
		result.type = "clockid_t";
		break;
	case 1:
		result.name = "__tp";
		result.type = "const struct timespec *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __clock_settime_name = "::clock_settime";

const std::string& Function<int(*)(clockid_t, const struct timespec *), ::clock_settime>::GetName() const
{
	return __clock_settime_name;
}

Object Function<int(*)(clockid_t, const struct timespec *), ::clock_settime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::clock_settime(args[0].GetT<std::decay_t<clockid_t>>(), args[1].GetT<std::decay_t<const struct timespec *>>()));
}

namespace
{
	// Object to auto-register ::clock_settime.
	struct __clock_settime_registrar
	{
		__clock_settime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(clockid_t, const struct timespec *), ::clock_settime>>());
		}
	} __clock_settime_instance;
}



int Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype>::GetParameterCount() const
{
	return 1;
}

Parameter Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned long";
	return result;
}

Parameter Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "__darwin_ct_rune_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string _____runetype_name = "::___runetype";

const std::string& Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype>::GetName() const
{
	return _____runetype_name;
}

Object Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::___runetype(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>()));
}

namespace
{
	// Object to auto-register ::___runetype.
	struct _____runetype_registrar
	{
		_____runetype_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned long(*)(__darwin_ct_rune_t), ::___runetype>>());
		}
	} _____runetype_instance;
}



int Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower>::GetParameterCount() const
{
	return 1;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower>::GetReturnType() const
{
	Parameter result;
	result.type = "__darwin_ct_rune_t";
	return result;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "__darwin_ct_rune_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string _____tolower_name = "::___tolower";

const std::string& Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower>::GetName() const
{
	return _____tolower_name;
}

Object Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::___tolower(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>()));
}

namespace
{
	// Object to auto-register ::___tolower.
	struct _____tolower_registrar
	{
		_____tolower_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___tolower>>());
		}
	} _____tolower_instance;
}



int Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper>::GetParameterCount() const
{
	return 1;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper>::GetReturnType() const
{
	Parameter result;
	result.type = "__darwin_ct_rune_t";
	return result;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "__darwin_ct_rune_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string _____toupper_name = "::___toupper";

const std::string& Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper>::GetName() const
{
	return _____toupper_name;
}

Object Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::___toupper(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>()));
}

namespace
{
	// Object to auto-register ::___toupper.
	struct _____toupper_registrar
	{
		_____toupper_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::___toupper>>());
		}
	} _____toupper_instance;
}



int Function<int(*)(int), isascii>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isascii>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isascii>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isascii_name = "isascii";

const std::string& Function<int(*)(int), isascii>::GetName() const
{
	return isascii_name;
}

Object Function<int(*)(int), isascii>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isascii(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isascii.
	struct isascii_registrar
	{
		isascii_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isascii>>());
		}
	} isascii_instance;
}



int Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "__darwin_ct_rune_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "unsigned long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____maskrune_name = "::__maskrune";

const std::string& Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune>::GetName() const
{
	return ____maskrune_name;
}

Object Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::__maskrune(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>(), args[1].GetT<std::decay_t<unsigned long>>()));
}

namespace
{
	// Object to auto-register ::__maskrune.
	struct ____maskrune_registrar
	{
		____maskrune_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(__darwin_ct_rune_t, unsigned long), ::__maskrune>>());
		}
	} ____maskrune_instance;
}



int Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "__darwin_ct_rune_t";
		break;
	case 1:
		result.name = "_f";
		result.type = "unsigned long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __istype_name = "__istype";

const std::string& Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype>::GetName() const
{
	return __istype_name;
}

Object Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(__istype(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>(), args[1].GetT<std::decay_t<unsigned long>>()));
}

namespace
{
	// Object to auto-register __istype.
	struct __istype_registrar
	{
		__istype_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(__darwin_ct_rune_t, unsigned long), __istype>>());
		}
	} __istype_instance;
}



int Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype>::GetParameterCount() const
{
	return 2;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype>::GetReturnType() const
{
	Parameter result;
	result.type = "__darwin_ct_rune_t";
	return result;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "__darwin_ct_rune_t";
		break;
	case 1:
		result.name = "_f";
		result.type = "unsigned long";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __isctype_name = "__isctype";

const std::string& Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype>::GetName() const
{
	return __isctype_name;
}

Object Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(__isctype(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>(), args[1].GetT<std::decay_t<unsigned long>>()));
}

namespace
{
	// Object to auto-register __isctype.
	struct __isctype_registrar
	{
		__isctype_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t, unsigned long), __isctype>>());
		}
	} __isctype_instance;
}



int Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper>::GetParameterCount() const
{
	return 1;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper>::GetReturnType() const
{
	Parameter result;
	result.type = "__darwin_ct_rune_t";
	return result;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "__darwin_ct_rune_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____toupper_name = "::__toupper";

const std::string& Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper>::GetName() const
{
	return ____toupper_name;
}

Object Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::__toupper(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>()));
}

namespace
{
	// Object to auto-register ::__toupper.
	struct ____toupper_registrar
	{
		____toupper_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__toupper>>());
		}
	} ____toupper_instance;
}



int Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower>::GetParameterCount() const
{
	return 1;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower>::GetReturnType() const
{
	Parameter result;
	result.type = "__darwin_ct_rune_t";
	return result;
}

Parameter Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "__darwin_ct_rune_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____tolower_name = "::__tolower";

const std::string& Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower>::GetName() const
{
	return ____tolower_name;
}

Object Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::__tolower(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>()));
}

namespace
{
	// Object to auto-register ::__tolower.
	struct ____tolower_registrar
	{
		____tolower_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<__darwin_ct_rune_t(*)(__darwin_ct_rune_t), ::__tolower>>());
		}
	} ____tolower_instance;
}



int Function<int(*)(__darwin_ct_rune_t), __wcwidth>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(__darwin_ct_rune_t), __wcwidth>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(__darwin_ct_rune_t), __wcwidth>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "__darwin_ct_rune_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcwidth_name = "__wcwidth";

const std::string& Function<int(*)(__darwin_ct_rune_t), __wcwidth>::GetName() const
{
	return __wcwidth_name;
}

Object Function<int(*)(__darwin_ct_rune_t), __wcwidth>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(__wcwidth(args[0].GetT<std::decay_t<__darwin_ct_rune_t>>()));
}

namespace
{
	// Object to auto-register __wcwidth.
	struct __wcwidth_registrar
	{
		__wcwidth_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(__darwin_ct_rune_t), __wcwidth>>());
		}
	} __wcwidth_instance;
}



int Function<int(*)(int), isalnum>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isalnum>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isalnum>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isalnum_name = "isalnum";

const std::string& Function<int(*)(int), isalnum>::GetName() const
{
	return isalnum_name;
}

Object Function<int(*)(int), isalnum>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isalnum(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isalnum.
	struct isalnum_registrar
	{
		isalnum_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isalnum>>());
		}
	} isalnum_instance;
}



int Function<int(*)(int), isalpha>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isalpha>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isalpha>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isalpha_name = "isalpha";

const std::string& Function<int(*)(int), isalpha>::GetName() const
{
	return isalpha_name;
}

Object Function<int(*)(int), isalpha>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isalpha(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isalpha.
	struct isalpha_registrar
	{
		isalpha_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isalpha>>());
		}
	} isalpha_instance;
}



int Function<int(*)(int), isblank>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isblank>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isblank>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isblank_name = "isblank";

const std::string& Function<int(*)(int), isblank>::GetName() const
{
	return isblank_name;
}

Object Function<int(*)(int), isblank>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isblank(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isblank.
	struct isblank_registrar
	{
		isblank_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isblank>>());
		}
	} isblank_instance;
}



int Function<int(*)(int), iscntrl>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), iscntrl>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), iscntrl>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iscntrl_name = "iscntrl";

const std::string& Function<int(*)(int), iscntrl>::GetName() const
{
	return iscntrl_name;
}

Object Function<int(*)(int), iscntrl>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iscntrl(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register iscntrl.
	struct iscntrl_registrar
	{
		iscntrl_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), iscntrl>>());
		}
	} iscntrl_instance;
}



int Function<int(*)(int), isdigit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isdigit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isdigit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isdigit_name = "isdigit";

const std::string& Function<int(*)(int), isdigit>::GetName() const
{
	return isdigit_name;
}

Object Function<int(*)(int), isdigit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isdigit(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isdigit.
	struct isdigit_registrar
	{
		isdigit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isdigit>>());
		}
	} isdigit_instance;
}



int Function<int(*)(int), isgraph>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isgraph>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isgraph>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isgraph_name = "isgraph";

const std::string& Function<int(*)(int), isgraph>::GetName() const
{
	return isgraph_name;
}

Object Function<int(*)(int), isgraph>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isgraph(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isgraph.
	struct isgraph_registrar
	{
		isgraph_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isgraph>>());
		}
	} isgraph_instance;
}



int Function<int(*)(int), islower>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), islower>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), islower>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string islower_name = "islower";

const std::string& Function<int(*)(int), islower>::GetName() const
{
	return islower_name;
}

Object Function<int(*)(int), islower>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(islower(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register islower.
	struct islower_registrar
	{
		islower_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), islower>>());
		}
	} islower_instance;
}



int Function<int(*)(int), isprint>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isprint>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isprint>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isprint_name = "isprint";

const std::string& Function<int(*)(int), isprint>::GetName() const
{
	return isprint_name;
}

Object Function<int(*)(int), isprint>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isprint(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isprint.
	struct isprint_registrar
	{
		isprint_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isprint>>());
		}
	} isprint_instance;
}



int Function<int(*)(int), ispunct>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ispunct>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ispunct>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ispunct_name = "ispunct";

const std::string& Function<int(*)(int), ispunct>::GetName() const
{
	return ispunct_name;
}

Object Function<int(*)(int), ispunct>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(ispunct(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ispunct.
	struct ispunct_registrar
	{
		ispunct_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ispunct>>());
		}
	} ispunct_instance;
}



int Function<int(*)(int), isspace>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isspace>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isspace>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isspace_name = "isspace";

const std::string& Function<int(*)(int), isspace>::GetName() const
{
	return isspace_name;
}

Object Function<int(*)(int), isspace>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isspace(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isspace.
	struct isspace_registrar
	{
		isspace_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isspace>>());
		}
	} isspace_instance;
}



int Function<int(*)(int), isupper>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isupper>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isupper>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isupper_name = "isupper";

const std::string& Function<int(*)(int), isupper>::GetName() const
{
	return isupper_name;
}

Object Function<int(*)(int), isupper>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isupper(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isupper.
	struct isupper_registrar
	{
		isupper_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isupper>>());
		}
	} isupper_instance;
}



int Function<int(*)(int), isxdigit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isxdigit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isxdigit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isxdigit_name = "isxdigit";

const std::string& Function<int(*)(int), isxdigit>::GetName() const
{
	return isxdigit_name;
}

Object Function<int(*)(int), isxdigit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isxdigit(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isxdigit.
	struct isxdigit_registrar
	{
		isxdigit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isxdigit>>());
		}
	} isxdigit_instance;
}



int Function<int(*)(int), toascii>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), toascii>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), toascii>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string toascii_name = "toascii";

const std::string& Function<int(*)(int), toascii>::GetName() const
{
	return toascii_name;
}

Object Function<int(*)(int), toascii>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(toascii(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register toascii.
	struct toascii_registrar
	{
		toascii_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), toascii>>());
		}
	} toascii_instance;
}



int Function<int(*)(int), tolower>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), tolower>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), tolower>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string tolower_name = "tolower";

const std::string& Function<int(*)(int), tolower>::GetName() const
{
	return tolower_name;
}

Object Function<int(*)(int), tolower>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(tolower(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register tolower.
	struct tolower_registrar
	{
		tolower_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), tolower>>());
		}
	} tolower_instance;
}



int Function<int(*)(int), toupper>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), toupper>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), toupper>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string toupper_name = "toupper";

const std::string& Function<int(*)(int), toupper>::GetName() const
{
	return toupper_name;
}

Object Function<int(*)(int), toupper>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(toupper(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register toupper.
	struct toupper_registrar
	{
		toupper_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), toupper>>());
		}
	} toupper_instance;
}



int Function<int(*)(int), digittoint>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), digittoint>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), digittoint>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string digittoint_name = "digittoint";

const std::string& Function<int(*)(int), digittoint>::GetName() const
{
	return digittoint_name;
}

Object Function<int(*)(int), digittoint>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(digittoint(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register digittoint.
	struct digittoint_registrar
	{
		digittoint_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), digittoint>>());
		}
	} digittoint_instance;
}



int Function<int(*)(int), ishexnumber>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), ishexnumber>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), ishexnumber>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ishexnumber_name = "ishexnumber";

const std::string& Function<int(*)(int), ishexnumber>::GetName() const
{
	return ishexnumber_name;
}

Object Function<int(*)(int), ishexnumber>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(ishexnumber(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ishexnumber.
	struct ishexnumber_registrar
	{
		ishexnumber_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), ishexnumber>>());
		}
	} ishexnumber_instance;
}



int Function<int(*)(int), isideogram>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isideogram>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isideogram>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isideogram_name = "isideogram";

const std::string& Function<int(*)(int), isideogram>::GetName() const
{
	return isideogram_name;
}

Object Function<int(*)(int), isideogram>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isideogram(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isideogram.
	struct isideogram_registrar
	{
		isideogram_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isideogram>>());
		}
	} isideogram_instance;
}



int Function<int(*)(int), isnumber>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isnumber>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isnumber>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isnumber_name = "isnumber";

const std::string& Function<int(*)(int), isnumber>::GetName() const
{
	return isnumber_name;
}

Object Function<int(*)(int), isnumber>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isnumber(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isnumber.
	struct isnumber_registrar
	{
		isnumber_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isnumber>>());
		}
	} isnumber_instance;
}



int Function<int(*)(int), isphonogram>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isphonogram>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isphonogram>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isphonogram_name = "isphonogram";

const std::string& Function<int(*)(int), isphonogram>::GetName() const
{
	return isphonogram_name;
}

Object Function<int(*)(int), isphonogram>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isphonogram(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isphonogram.
	struct isphonogram_registrar
	{
		isphonogram_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isphonogram>>());
		}
	} isphonogram_instance;
}



int Function<int(*)(int), isrune>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isrune>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isrune>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isrune_name = "isrune";

const std::string& Function<int(*)(int), isrune>::GetName() const
{
	return isrune_name;
}

Object Function<int(*)(int), isrune>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isrune(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isrune.
	struct isrune_registrar
	{
		isrune_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isrune>>());
		}
	} isrune_instance;
}



int Function<int(*)(int), isspecial>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(int), isspecial>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(int), isspecial>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_c";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string isspecial_name = "isspecial";

const std::string& Function<int(*)(int), isspecial>::GetName() const
{
	return isspecial_name;
}

Object Function<int(*)(int), isspecial>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(isspecial(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register isspecial.
	struct isspecial_registrar
	{
		isspecial_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(int), isspecial>>());
		}
	} isspecial_instance;
}



int Function<int(*)(wint_t), iswalnum>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswalnum>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswalnum>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswalnum_name = "iswalnum";

const std::string& Function<int(*)(wint_t), iswalnum>::GetName() const
{
	return iswalnum_name;
}

Object Function<int(*)(wint_t), iswalnum>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswalnum(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswalnum.
	struct iswalnum_registrar
	{
		iswalnum_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswalnum>>());
		}
	} iswalnum_instance;
}



int Function<int(*)(wint_t), iswalpha>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswalpha>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswalpha>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswalpha_name = "iswalpha";

const std::string& Function<int(*)(wint_t), iswalpha>::GetName() const
{
	return iswalpha_name;
}

Object Function<int(*)(wint_t), iswalpha>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswalpha(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswalpha.
	struct iswalpha_registrar
	{
		iswalpha_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswalpha>>());
		}
	} iswalpha_instance;
}



int Function<int(*)(wint_t), iswcntrl>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswcntrl>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswcntrl>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswcntrl_name = "iswcntrl";

const std::string& Function<int(*)(wint_t), iswcntrl>::GetName() const
{
	return iswcntrl_name;
}

Object Function<int(*)(wint_t), iswcntrl>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswcntrl(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswcntrl.
	struct iswcntrl_registrar
	{
		iswcntrl_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswcntrl>>());
		}
	} iswcntrl_instance;
}



int Function<int(*)(wint_t, wctype_t), iswctype>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(wint_t, wctype_t), iswctype>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t, wctype_t), iswctype>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	case 1:
		result.name = "_charclass";
		result.type = "wctype_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswctype_name = "iswctype";

const std::string& Function<int(*)(wint_t, wctype_t), iswctype>::GetName() const
{
	return iswctype_name;
}

Object Function<int(*)(wint_t, wctype_t), iswctype>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswctype(args[0].GetT<std::decay_t<wint_t>>(), args[1].GetT<std::decay_t<wctype_t>>()));
}

namespace
{
	// Object to auto-register iswctype.
	struct iswctype_registrar
	{
		iswctype_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t, wctype_t), iswctype>>());
		}
	} iswctype_instance;
}



int Function<int(*)(wint_t), iswdigit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswdigit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswdigit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswdigit_name = "iswdigit";

const std::string& Function<int(*)(wint_t), iswdigit>::GetName() const
{
	return iswdigit_name;
}

Object Function<int(*)(wint_t), iswdigit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswdigit(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswdigit.
	struct iswdigit_registrar
	{
		iswdigit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswdigit>>());
		}
	} iswdigit_instance;
}



int Function<int(*)(wint_t), iswgraph>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswgraph>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswgraph>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswgraph_name = "iswgraph";

const std::string& Function<int(*)(wint_t), iswgraph>::GetName() const
{
	return iswgraph_name;
}

Object Function<int(*)(wint_t), iswgraph>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswgraph(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswgraph.
	struct iswgraph_registrar
	{
		iswgraph_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswgraph>>());
		}
	} iswgraph_instance;
}



int Function<int(*)(wint_t), iswlower>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswlower>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswlower>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswlower_name = "iswlower";

const std::string& Function<int(*)(wint_t), iswlower>::GetName() const
{
	return iswlower_name;
}

Object Function<int(*)(wint_t), iswlower>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswlower(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswlower.
	struct iswlower_registrar
	{
		iswlower_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswlower>>());
		}
	} iswlower_instance;
}



int Function<int(*)(wint_t), iswprint>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswprint>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswprint>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswprint_name = "iswprint";

const std::string& Function<int(*)(wint_t), iswprint>::GetName() const
{
	return iswprint_name;
}

Object Function<int(*)(wint_t), iswprint>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswprint(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswprint.
	struct iswprint_registrar
	{
		iswprint_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswprint>>());
		}
	} iswprint_instance;
}



int Function<int(*)(wint_t), iswpunct>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswpunct>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswpunct>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswpunct_name = "iswpunct";

const std::string& Function<int(*)(wint_t), iswpunct>::GetName() const
{
	return iswpunct_name;
}

Object Function<int(*)(wint_t), iswpunct>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswpunct(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswpunct.
	struct iswpunct_registrar
	{
		iswpunct_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswpunct>>());
		}
	} iswpunct_instance;
}



int Function<int(*)(wint_t), iswspace>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswspace>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswspace>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswspace_name = "iswspace";

const std::string& Function<int(*)(wint_t), iswspace>::GetName() const
{
	return iswspace_name;
}

Object Function<int(*)(wint_t), iswspace>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswspace(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswspace.
	struct iswspace_registrar
	{
		iswspace_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswspace>>());
		}
	} iswspace_instance;
}



int Function<int(*)(wint_t), iswupper>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswupper>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswupper>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswupper_name = "iswupper";

const std::string& Function<int(*)(wint_t), iswupper>::GetName() const
{
	return iswupper_name;
}

Object Function<int(*)(wint_t), iswupper>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswupper(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswupper.
	struct iswupper_registrar
	{
		iswupper_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswupper>>());
		}
	} iswupper_instance;
}



int Function<int(*)(wint_t), iswxdigit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswxdigit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswxdigit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswxdigit_name = "iswxdigit";

const std::string& Function<int(*)(wint_t), iswxdigit>::GetName() const
{
	return iswxdigit_name;
}

Object Function<int(*)(wint_t), iswxdigit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswxdigit(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswxdigit.
	struct iswxdigit_registrar
	{
		iswxdigit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswxdigit>>());
		}
	} iswxdigit_instance;
}



int Function<wint_t(*)(wint_t), towlower>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wint_t(*)(wint_t), towlower>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wint_t), towlower>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string towlower_name = "towlower";

const std::string& Function<wint_t(*)(wint_t), towlower>::GetName() const
{
	return towlower_name;
}

Object Function<wint_t(*)(wint_t), towlower>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(towlower(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register towlower.
	struct towlower_registrar
	{
		towlower_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wint_t), towlower>>());
		}
	} towlower_instance;
}



int Function<wint_t(*)(wint_t), towupper>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wint_t(*)(wint_t), towupper>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wint_t), towupper>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string towupper_name = "towupper";

const std::string& Function<wint_t(*)(wint_t), towupper>::GetName() const
{
	return towupper_name;
}

Object Function<wint_t(*)(wint_t), towupper>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(towupper(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register towupper.
	struct towupper_registrar
	{
		towupper_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wint_t), towupper>>());
		}
	} towupper_instance;
}



int Function<wctype_t(*)(const char *), ::wctype>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wctype_t(*)(const char *), ::wctype>::GetReturnType() const
{
	Parameter result;
	result.type = "wctype_t";
	return result;
}

Parameter Function<wctype_t(*)(const char *), ::wctype>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wctype_name = "::wctype";

const std::string& Function<wctype_t(*)(const char *), ::wctype>::GetName() const
{
	return __wctype_name;
}

Object Function<wctype_t(*)(const char *), ::wctype>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wctype(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::wctype.
	struct __wctype_registrar
	{
		__wctype_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wctype_t(*)(const char *), ::wctype>>());
		}
	} __wctype_instance;
}



int Function<wint_t(*)(int), ::btowc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wint_t(*)(int), ::btowc>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(int), ::btowc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __btowc_name = "::btowc";

const std::string& Function<wint_t(*)(int), ::btowc>::GetName() const
{
	return __btowc_name;
}

Object Function<wint_t(*)(int), ::btowc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::btowc(args[0].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::btowc.
	struct __btowc_registrar
	{
		__btowc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(int), ::btowc>>());
		}
	} __btowc_instance;
}



int Function<wint_t(*)(FILE *), ::fgetwc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wint_t(*)(FILE *), ::fgetwc>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(FILE *), ::fgetwc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgetwc_name = "::fgetwc";

const std::string& Function<wint_t(*)(FILE *), ::fgetwc>::GetName() const
{
	return __fgetwc_name;
}

Object Function<wint_t(*)(FILE *), ::fgetwc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgetwc(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fgetwc.
	struct __fgetwc_registrar
	{
		__fgetwc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(FILE *), ::fgetwc>>());
		}
	} __fgetwc_instance;
}



int Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	case 2:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgetws_name = "::fgetws";

const std::string& Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws>::GetName() const
{
	return __fgetws_name;
}

Object Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgetws(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fgetws.
	struct __fgetws_registrar
	{
		__fgetws_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, int, FILE *), ::fgetws>>());
		}
	} __fgetws_instance;
}



int Function<wint_t(*)(wchar_t, FILE *), ::fputwc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wint_t(*)(wchar_t, FILE *), ::fputwc>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wchar_t, FILE *), ::fputwc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fputwc_name = "::fputwc";

const std::string& Function<wint_t(*)(wchar_t, FILE *), ::fputwc>::GetName() const
{
	return __fputwc_name;
}

Object Function<wint_t(*)(wchar_t, FILE *), ::fputwc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fputwc(args[0].GetT<std::decay_t<wchar_t>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fputwc.
	struct __fputwc_registrar
	{
		__fputwc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wchar_t, FILE *), ::fputwc>>());
		}
	} __fputwc_instance;
}



int Function<int(*)(const wchar_t *, FILE *), ::fputws>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, FILE *), ::fputws>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, FILE *), ::fputws>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fputws_name = "::fputws";

const std::string& Function<int(*)(const wchar_t *, FILE *), ::fputws>::GetName() const
{
	return __fputws_name;
}

Object Function<int(*)(const wchar_t *, FILE *), ::fputws>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fputws(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::fputws.
	struct __fputws_registrar
	{
		__fputws_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, FILE *), ::fputws>>());
		}
	} __fputws_instance;
}



int Function<int(*)(FILE *, int), ::fwide>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, int), ::fwide>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, int), ::fwide>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fwide_name = "::fwide";

const std::string& Function<int(*)(FILE *, int), ::fwide>::GetName() const
{
	return __fwide_name;
}

Object Function<int(*)(FILE *, int), ::fwide>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fwide(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::fwide.
	struct __fwide_registrar
	{
		__fwide_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, int), ::fwide>>());
		}
	} __fwide_instance;
}



int Function<int(*)(FILE *, const wchar_t *), ::fwprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, const wchar_t *), ::fwprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const wchar_t *), ::fwprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fwprintf_name = "::fwprintf";

const std::string& Function<int(*)(FILE *, const wchar_t *), ::fwprintf>::GetName() const
{
	return __fwprintf_name;
}

Object Function<int(*)(FILE *, const wchar_t *), ::fwprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fwprintf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::fwprintf.
	struct __fwprintf_registrar
	{
		__fwprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const wchar_t *), ::fwprintf>>());
		}
	} __fwprintf_instance;
}



int Function<int(*)(FILE *, const wchar_t *), ::fwscanf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(FILE *, const wchar_t *), ::fwscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const wchar_t *), ::fwscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fwscanf_name = "::fwscanf";

const std::string& Function<int(*)(FILE *, const wchar_t *), ::fwscanf>::GetName() const
{
	return __fwscanf_name;
}

Object Function<int(*)(FILE *, const wchar_t *), ::fwscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fwscanf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::fwscanf.
	struct __fwscanf_registrar
	{
		__fwscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const wchar_t *), ::fwscanf>>());
		}
	} __fwscanf_instance;
}



int Function<wint_t(*)(FILE *), ::getwc>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wint_t(*)(FILE *), ::getwc>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(FILE *), ::getwc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __getwc_name = "::getwc";

const std::string& Function<wint_t(*)(FILE *), ::getwc>::GetName() const
{
	return __getwc_name;
}

Object Function<wint_t(*)(FILE *), ::getwc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getwc(args[0].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::getwc.
	struct __getwc_registrar
	{
		__getwc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(FILE *), ::getwc>>());
		}
	} __getwc_instance;
}



int Function<wint_t(*)(), ::getwchar>::GetParameterCount() const
{
	return 0;
}

Parameter Function<wint_t(*)(), ::getwchar>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(), ::getwchar>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __getwchar_name = "::getwchar";

const std::string& Function<wint_t(*)(), ::getwchar>::GetName() const
{
	return __getwchar_name;
}

Object Function<wint_t(*)(), ::getwchar>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::getwchar());
}

namespace
{
	// Object to auto-register ::getwchar.
	struct __getwchar_registrar
	{
		__getwchar_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(), ::getwchar>>());
		}
	} __getwchar_instance;
}



int Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbrlen_name = "::mbrlen";

const std::string& Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen>::GetName() const
{
	return __mbrlen_name;
}

Object Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbrlen(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::mbrlen.
	struct __mbrlen_registrar
	{
		__mbrlen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const char *, size_t, mbstate_t *), ::mbrlen>>());
		}
	} __mbrlen_instance;
}



int Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbrtowc_name = "::mbrtowc";

const std::string& Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc>::GetName() const
{
	return __mbrtowc_name;
}

Object Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbrtowc(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::mbrtowc.
	struct __mbrtowc_registrar
	{
		__mbrtowc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const char *, size_t, mbstate_t *), ::mbrtowc>>());
		}
	} __mbrtowc_instance;
}



int Function<int(*)(const mbstate_t *), ::mbsinit>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const mbstate_t *), ::mbsinit>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const mbstate_t *), ::mbsinit>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbsinit_name = "::mbsinit";

const std::string& Function<int(*)(const mbstate_t *), ::mbsinit>::GetName() const
{
	return __mbsinit_name;
}

Object Function<int(*)(const mbstate_t *), ::mbsinit>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbsinit(args[0].GetT<std::decay_t<const mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::mbsinit.
	struct __mbsinit_registrar
	{
		__mbsinit_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const mbstate_t *), ::mbsinit>>());
		}
	} __mbsinit_instance;
}



int Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbsrtowcs_name = "::mbsrtowcs";

const std::string& Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs>::GetName() const
{
	return __mbsrtowcs_name;
}

Object Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbsrtowcs(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const char **>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::mbsrtowcs.
	struct __mbsrtowcs_registrar
	{
		__mbsrtowcs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const char **, size_t, mbstate_t *), ::mbsrtowcs>>());
		}
	} __mbsrtowcs_instance;
}



int Function<wint_t(*)(wchar_t, FILE *), ::putwc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wint_t(*)(wchar_t, FILE *), ::putwc>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wchar_t, FILE *), ::putwc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putwc_name = "::putwc";

const std::string& Function<wint_t(*)(wchar_t, FILE *), ::putwc>::GetName() const
{
	return __putwc_name;
}

Object Function<wint_t(*)(wchar_t, FILE *), ::putwc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putwc(args[0].GetT<std::decay_t<wchar_t>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::putwc.
	struct __putwc_registrar
	{
		__putwc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wchar_t, FILE *), ::putwc>>());
		}
	} __putwc_instance;
}



int Function<wint_t(*)(wchar_t), ::putwchar>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wint_t(*)(wchar_t), ::putwchar>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wchar_t), ::putwchar>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __putwchar_name = "::putwchar";

const std::string& Function<wint_t(*)(wchar_t), ::putwchar>::GetName() const
{
	return __putwchar_name;
}

Object Function<wint_t(*)(wchar_t), ::putwchar>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::putwchar(args[0].GetT<std::decay_t<wchar_t>>()));
}

namespace
{
	// Object to auto-register ::putwchar.
	struct __putwchar_registrar
	{
		__putwchar_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wchar_t), ::putwchar>>());
		}
	} __putwchar_instance;
}



int Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __swprintf_name = "::swprintf";

const std::string& Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf>::GetName() const
{
	return __swprintf_name;
}

Object Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::swprintf(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::swprintf.
	struct __swprintf_registrar
	{
		__swprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wchar_t *, size_t, const wchar_t *), ::swprintf>>());
		}
	} __swprintf_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __swscanf_name = "::swscanf";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf>::GetName() const
{
	return __swscanf_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::swscanf(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::swscanf.
	struct __swscanf_registrar
	{
		__swscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *), ::swscanf>>());
		}
	} __swscanf_instance;
}



int Function<wint_t(*)(wint_t, FILE *), ::ungetwc>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wint_t(*)(wint_t, FILE *), ::ungetwc>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wint_t, FILE *), ::ungetwc>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wint_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __ungetwc_name = "::ungetwc";

const std::string& Function<wint_t(*)(wint_t, FILE *), ::ungetwc>::GetName() const
{
	return __ungetwc_name;
}

Object Function<wint_t(*)(wint_t, FILE *), ::ungetwc>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::ungetwc(args[0].GetT<std::decay_t<wint_t>>(), args[1].GetT<std::decay_t<FILE *>>()));
}

namespace
{
	// Object to auto-register ::ungetwc.
	struct __ungetwc_registrar
	{
		__ungetwc_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wint_t, FILE *), ::ungetwc>>());
		}
	} __ungetwc_instance;
}



int Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "__darwin_va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vfwprintf_name = "::vfwprintf";

const std::string& Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf>::GetName() const
{
	return __vfwprintf_name;
}

Object Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vfwprintf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<__darwin_va_list>>()));
}

namespace
{
	// Object to auto-register ::vfwprintf.
	struct __vfwprintf_registrar
	{
		__vfwprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwprintf>>());
		}
	} __vfwprintf_instance;
}



int Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf>::GetParameterCount() const
{
	return 4;
}

Parameter Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "__darwin_va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vswprintf_name = "::vswprintf";

const std::string& Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf>::GetName() const
{
	return __vswprintf_name;
}

Object Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vswprintf(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const wchar_t *>>(), args[3].GetT<std::decay_t<__darwin_va_list>>()));
}

namespace
{
	// Object to auto-register ::vswprintf.
	struct __vswprintf_registrar
	{
		__vswprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wchar_t *, size_t, const wchar_t *, __darwin_va_list), ::vswprintf>>());
		}
	} __vswprintf_instance;
}



int Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "__darwin_va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vwprintf_name = "::vwprintf";

const std::string& Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf>::GetName() const
{
	return __vwprintf_name;
}

Object Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vwprintf(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<__darwin_va_list>>()));
}

namespace
{
	// Object to auto-register ::vwprintf.
	struct __vwprintf_registrar
	{
		__vwprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, __darwin_va_list), ::vwprintf>>());
		}
	} __vwprintf_instance;
}



int Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcrtomb_name = "::wcrtomb";

const std::string& Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb>::GetName() const
{
	return __wcrtomb_name;
}

Object Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcrtomb(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<wchar_t>>(), args[2].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::wcrtomb.
	struct __wcrtomb_registrar
	{
		__wcrtomb_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, wchar_t, mbstate_t *), ::wcrtomb>>());
		}
	} __wcrtomb_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcscat_name = "::wcscat";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat>::GetName() const
{
	return __wcscat_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcscat(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcscat.
	struct __wcscat_registrar
	{
		__wcscat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscat>>());
		}
	} __wcscat_instance;
}



int Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcschr_name = "::wcschr";

const std::string& Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr>::GetName() const
{
	return __wcschr_name;
}

Object Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcschr(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t>>()));
}

namespace
{
	// Object to auto-register ::wcschr.
	struct __wcschr_registrar
	{
		__wcschr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcschr>>());
		}
	} __wcschr_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcscmp_name = "::wcscmp";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp>::GetName() const
{
	return __wcscmp_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcscmp(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcscmp.
	struct __wcscmp_registrar
	{
		__wcscmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *), ::wcscmp>>());
		}
	} __wcscmp_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcscoll_name = "::wcscoll";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll>::GetName() const
{
	return __wcscoll_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcscoll(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcscoll.
	struct __wcscoll_registrar
	{
		__wcscoll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *), ::wcscoll>>());
		}
	} __wcscoll_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcscpy_name = "::wcscpy";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy>::GetName() const
{
	return __wcscpy_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcscpy(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcscpy.
	struct __wcscpy_registrar
	{
		__wcscpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcscpy>>());
		}
	} __wcscpy_instance;
}



int Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn>::GetParameterCount() const
{
	return 2;
}

Parameter Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcscspn_name = "::wcscspn";

const std::string& Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn>::GetName() const
{
	return __wcscspn_name;
}

Object Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcscspn(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcscspn.
	struct __wcscspn_registrar
	{
		__wcscspn_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcscspn>>());
		}
	} __wcscspn_instance;
}



int Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 3:
		result.name = "nameless";
		result.type = "const struct tm *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsftime_name = "::wcsftime";

const std::string& Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime>::GetName() const
{
	return __wcsftime_name;
}

Object Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsftime(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<size_t>>(), args[2].GetT<std::decay_t<const wchar_t *>>(), args[3].GetT<std::decay_t<const struct tm *>>()));
}

namespace
{
	// Object to auto-register ::wcsftime.
	struct __wcsftime_registrar
	{
		__wcsftime_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, size_t, const wchar_t *, const struct tm *), ::wcsftime>>());
		}
	} __wcsftime_instance;
}



int Function<size_t(*)(const wchar_t *), ::wcslen>::GetParameterCount() const
{
	return 1;
}

Parameter Function<size_t(*)(const wchar_t *), ::wcslen>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const wchar_t *), ::wcslen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcslen_name = "::wcslen";

const std::string& Function<size_t(*)(const wchar_t *), ::wcslen>::GetName() const
{
	return __wcslen_name;
}

Object Function<size_t(*)(const wchar_t *), ::wcslen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcslen(args[0].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcslen.
	struct __wcslen_registrar
	{
		__wcslen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const wchar_t *), ::wcslen>>());
		}
	} __wcslen_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsncat_name = "::wcsncat";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat>::GetName() const
{
	return __wcsncat_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsncat(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcsncat.
	struct __wcsncat_registrar
	{
		__wcsncat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncat>>());
		}
	} __wcsncat_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsncmp_name = "::wcsncmp";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp>::GetName() const
{
	return __wcsncmp_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsncmp(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcsncmp.
	struct __wcsncmp_registrar
	{
		__wcsncmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncmp>>());
		}
	} __wcsncmp_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsncpy_name = "::wcsncpy";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy>::GetName() const
{
	return __wcsncpy_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsncpy(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcsncpy.
	struct __wcsncpy_registrar
	{
		__wcsncpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcsncpy>>());
		}
	} __wcsncpy_instance;
}



int Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcspbrk_name = "::wcspbrk";

const std::string& Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk>::GetName() const
{
	return __wcspbrk_name;
}

Object Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcspbrk(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcspbrk.
	struct __wcspbrk_registrar
	{
		__wcspbrk_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcspbrk>>());
		}
	} __wcspbrk_instance;
}



int Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsrchr_name = "::wcsrchr";

const std::string& Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr>::GetName() const
{
	return __wcsrchr_name;
}

Object Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsrchr(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t>>()));
}

namespace
{
	// Object to auto-register ::wcsrchr.
	struct __wcsrchr_registrar
	{
		__wcsrchr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(const wchar_t *, wchar_t), ::wcsrchr>>());
		}
	} __wcsrchr_instance;
}



int Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs>::GetParameterCount() const
{
	return 4;
}

Parameter Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsrtombs_name = "::wcsrtombs";

const std::string& Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs>::GetName() const
{
	return __wcsrtombs_name;
}

Object Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsrtombs(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const wchar_t **>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::wcsrtombs.
	struct __wcsrtombs_registrar
	{
		__wcsrtombs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, const wchar_t **, size_t, mbstate_t *), ::wcsrtombs>>());
		}
	} __wcsrtombs_instance;
}



int Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn>::GetParameterCount() const
{
	return 2;
}

Parameter Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsspn_name = "::wcsspn";

const std::string& Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn>::GetName() const
{
	return __wcsspn_name;
}

Object Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsspn(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcsspn.
	struct __wcsspn_registrar
	{
		__wcsspn_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const wchar_t *, const wchar_t *), ::wcsspn>>());
		}
	} __wcsspn_instance;
}



int Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsstr_name = "::wcsstr";

const std::string& Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr>::GetName() const
{
	return __wcsstr_name;
}

Object Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsstr(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcsstr.
	struct __wcsstr_registrar
	{
		__wcsstr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(const wchar_t *, const wchar_t *), ::wcsstr>>());
		}
	} __wcsstr_instance;
}



int Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsxfrm_name = "::wcsxfrm";

const std::string& Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm>::GetName() const
{
	return __wcsxfrm_name;
}

Object Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsxfrm(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcsxfrm.
	struct __wcsxfrm_registrar
	{
		__wcsxfrm_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcsxfrm>>());
		}
	} __wcsxfrm_instance;
}



int Function<int(*)(wint_t), ::wctob>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), ::wctob>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), ::wctob>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wctob_name = "::wctob";

const std::string& Function<int(*)(wint_t), ::wctob>::GetName() const
{
	return __wctob_name;
}

Object Function<int(*)(wint_t), ::wctob>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wctob(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register ::wctob.
	struct __wctob_registrar
	{
		__wctob_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), ::wctob>>());
		}
	} __wctob_instance;
}



int Function<double(*)(const wchar_t *, wchar_t **), ::wcstod>::GetParameterCount() const
{
	return 2;
}

Parameter Function<double(*)(const wchar_t *, wchar_t **), ::wcstod>::GetReturnType() const
{
	Parameter result;
	result.type = "double";
	return result;
}

Parameter Function<double(*)(const wchar_t *, wchar_t **), ::wcstod>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstod_name = "::wcstod";

const std::string& Function<double(*)(const wchar_t *, wchar_t **), ::wcstod>::GetName() const
{
	return __wcstod_name;
}

Object Function<double(*)(const wchar_t *, wchar_t **), ::wcstod>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstod(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>()));
}

namespace
{
	// Object to auto-register ::wcstod.
	struct __wcstod_registrar
	{
		__wcstod_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<double(*)(const wchar_t *, wchar_t **), ::wcstod>>());
		}
	} __wcstod_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstok_name = "::wcstok";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok>::GetName() const
{
	return __wcstok_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstok(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<wchar_t **>>()));
}

namespace
{
	// Object to auto-register ::wcstok.
	struct __wcstok_registrar
	{
		__wcstok_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *, wchar_t **), ::wcstok>>());
		}
	} __wcstok_instance;
}



int Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol>::GetParameterCount() const
{
	return 3;
}

Parameter Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol>::GetReturnType() const
{
	Parameter result;
	result.type = "long";
	return result;
}

Parameter Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstol_name = "::wcstol";

const std::string& Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol>::GetName() const
{
	return __wcstol_name;
}

Object Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstol(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::wcstol.
	struct __wcstol_registrar
	{
		__wcstol_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long(*)(const wchar_t *, wchar_t **, int), ::wcstol>>());
		}
	} __wcstol_instance;
}



int Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul>::GetParameterCount() const
{
	return 3;
}

Parameter Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned long";
	return result;
}

Parameter Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstoul_name = "::wcstoul";

const std::string& Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul>::GetName() const
{
	return __wcstoul_name;
}

Object Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstoul(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::wcstoul.
	struct __wcstoul_registrar
	{
		__wcstoul_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned long(*)(const wchar_t *, wchar_t **, int), ::wcstoul>>());
		}
	} __wcstoul_instance;
}



int Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wmemchr_name = "::wmemchr";

const std::string& Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr>::GetName() const
{
	return __wmemchr_name;
}

Object Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wmemchr(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wmemchr.
	struct __wmemchr_registrar
	{
		__wmemchr_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(const wchar_t *, wchar_t, size_t), ::wmemchr>>());
		}
	} __wmemchr_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wmemcmp_name = "::wmemcmp";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp>::GetName() const
{
	return __wmemcmp_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wmemcmp(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wmemcmp.
	struct __wmemcmp_registrar
	{
		__wmemcmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wmemcmp>>());
		}
	} __wmemcmp_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wmemcpy_name = "::wmemcpy";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy>::GetName() const
{
	return __wmemcpy_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wmemcpy(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wmemcpy.
	struct __wmemcpy_registrar
	{
		__wmemcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemcpy>>());
		}
	} __wmemcpy_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wmemmove_name = "::wmemmove";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove>::GetName() const
{
	return __wmemmove_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wmemmove(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wmemmove.
	struct __wmemmove_registrar
	{
		__wmemmove_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wmemmove>>());
		}
	} __wmemmove_instance;
}



int Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wmemset_name = "::wmemset";

const std::string& Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset>::GetName() const
{
	return __wmemset_name;
}

Object Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wmemset(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wmemset.
	struct __wmemset_registrar
	{
		__wmemset_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, wchar_t, size_t), ::wmemset>>());
		}
	} __wmemset_instance;
}



int Function<int(*)(const wchar_t *), ::wprintf>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const wchar_t *), ::wprintf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *), ::wprintf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wprintf_name = "::wprintf";

const std::string& Function<int(*)(const wchar_t *), ::wprintf>::GetName() const
{
	return __wprintf_name;
}

Object Function<int(*)(const wchar_t *), ::wprintf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wprintf(args[0].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wprintf.
	struct __wprintf_registrar
	{
		__wprintf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *), ::wprintf>>());
		}
	} __wprintf_instance;
}



int Function<int(*)(const wchar_t *), ::wscanf>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(const wchar_t *), ::wscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *), ::wscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wscanf_name = "::wscanf";

const std::string& Function<int(*)(const wchar_t *), ::wscanf>::GetName() const
{
	return __wscanf_name;
}

Object Function<int(*)(const wchar_t *), ::wscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wscanf(args[0].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wscanf.
	struct __wscanf_registrar
	{
		__wscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *), ::wscanf>>());
		}
	} __wscanf_instance;
}



int Function<int(*)(const wchar_t *, size_t), ::wcswidth>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, size_t), ::wcswidth>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, size_t), ::wcswidth>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcswidth_name = "::wcswidth";

const std::string& Function<int(*)(const wchar_t *, size_t), ::wcswidth>::GetName() const
{
	return __wcswidth_name;
}

Object Function<int(*)(const wchar_t *, size_t), ::wcswidth>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcswidth(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcswidth.
	struct __wcswidth_registrar
	{
		__wcswidth_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, size_t), ::wcswidth>>());
		}
	} __wcswidth_instance;
}



int Function<int(*)(wchar_t), ::wcwidth>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wchar_t), ::wcwidth>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wchar_t), ::wcwidth>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcwidth_name = "::wcwidth";

const std::string& Function<int(*)(wchar_t), ::wcwidth>::GetName() const
{
	return __wcwidth_name;
}

Object Function<int(*)(wchar_t), ::wcwidth>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcwidth(args[0].GetT<std::decay_t<wchar_t>>()));
}

namespace
{
	// Object to auto-register ::wcwidth.
	struct __wcwidth_registrar
	{
		__wcwidth_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wchar_t), ::wcwidth>>());
		}
	} __wcwidth_instance;
}



int Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "__darwin_va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vfwscanf_name = "::vfwscanf";

const std::string& Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf>::GetName() const
{
	return __vfwscanf_name;
}

Object Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vfwscanf(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<__darwin_va_list>>()));
}

namespace
{
	// Object to auto-register ::vfwscanf.
	struct __vfwscanf_registrar
	{
		__vfwscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(FILE *, const wchar_t *, __darwin_va_list), ::vfwscanf>>());
		}
	} __vfwscanf_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "__darwin_va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vswscanf_name = "::vswscanf";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf>::GetName() const
{
	return __vswscanf_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vswscanf(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<__darwin_va_list>>()));
}

namespace
{
	// Object to auto-register ::vswscanf.
	struct __vswscanf_registrar
	{
		__vswscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *, __darwin_va_list), ::vswscanf>>());
		}
	} __vswscanf_instance;
}



int Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "__darwin_va_list";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __vwscanf_name = "::vwscanf";

const std::string& Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf>::GetName() const
{
	return __vwscanf_name;
}

Object Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::vwscanf(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<__darwin_va_list>>()));
}

namespace
{
	// Object to auto-register ::vwscanf.
	struct __vwscanf_registrar
	{
		__vwscanf_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, __darwin_va_list), ::vwscanf>>());
		}
	} __vwscanf_instance;
}



int Function<float(*)(const wchar_t *, wchar_t **), ::wcstof>::GetParameterCount() const
{
	return 2;
}

Parameter Function<float(*)(const wchar_t *, wchar_t **), ::wcstof>::GetReturnType() const
{
	Parameter result;
	result.type = "float";
	return result;
}

Parameter Function<float(*)(const wchar_t *, wchar_t **), ::wcstof>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstof_name = "::wcstof";

const std::string& Function<float(*)(const wchar_t *, wchar_t **), ::wcstof>::GetName() const
{
	return __wcstof_name;
}

Object Function<float(*)(const wchar_t *, wchar_t **), ::wcstof>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstof(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>()));
}

namespace
{
	// Object to auto-register ::wcstof.
	struct __wcstof_registrar
	{
		__wcstof_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<float(*)(const wchar_t *, wchar_t **), ::wcstof>>());
		}
	} __wcstof_instance;
}



int Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold>::GetParameterCount() const
{
	return 2;
}

Parameter Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold>::GetReturnType() const
{
	Parameter result;
	result.type = "long double";
	return result;
}

Parameter Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstold_name = "::wcstold";

const std::string& Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold>::GetName() const
{
	return __wcstold_name;
}

Object Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstold(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>()));
}

namespace
{
	// Object to auto-register ::wcstold.
	struct __wcstold_registrar
	{
		__wcstold_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long double(*)(const wchar_t *, wchar_t **), ::wcstold>>());
		}
	} __wcstold_instance;
}



int Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll>::GetParameterCount() const
{
	return 3;
}

Parameter Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll>::GetReturnType() const
{
	Parameter result;
	result.type = "long long";
	return result;
}

Parameter Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstoll_name = "::wcstoll";

const std::string& Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll>::GetName() const
{
	return __wcstoll_name;
}

Object Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstoll(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::wcstoll.
	struct __wcstoll_registrar
	{
		__wcstoll_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<long long(*)(const wchar_t *, wchar_t **, int), ::wcstoll>>());
		}
	} __wcstoll_instance;
}



int Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull>::GetParameterCount() const
{
	return 3;
}

Parameter Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull>::GetReturnType() const
{
	Parameter result;
	result.type = "unsigned long long";
	return result;
}

Parameter Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wchar_t **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcstoull_name = "::wcstoull";

const std::string& Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull>::GetName() const
{
	return __wcstoull_name;
}

Object Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcstoull(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<wchar_t **>>(), args[2].GetT<std::decay_t<int>>()));
}

namespace
{
	// Object to auto-register ::wcstoull.
	struct __wcstoull_registrar
	{
		__wcstoull_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<unsigned long long(*)(const wchar_t *, wchar_t **, int), ::wcstoull>>());
		}
	} __wcstoull_instance;
}



int Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs>::GetParameterCount() const
{
	return 5;
}

Parameter Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 4:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __mbsnrtowcs_name = "::mbsnrtowcs";

const std::string& Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs>::GetName() const
{
	return __mbsnrtowcs_name;
}

Object Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::mbsnrtowcs(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const char **>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<size_t>>(), args[4].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::mbsnrtowcs.
	struct __mbsnrtowcs_registrar
	{
		__mbsnrtowcs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const char **, size_t, size_t, mbstate_t *), ::mbsnrtowcs>>());
		}
	} __mbsnrtowcs_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcpcpy_name = "::wcpcpy";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy>::GetName() const
{
	return __wcpcpy_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcpcpy(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcpcpy.
	struct __wcpcpy_registrar
	{
		__wcpcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *), ::wcpcpy>>());
		}
	} __wcpcpy_instance;
}



int Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcpncpy_name = "::wcpncpy";

const std::string& Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy>::GetName() const
{
	return __wcpncpy_name;
}

Object Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcpncpy(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcpncpy.
	struct __wcpncpy_registrar
	{
		__wcpncpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(wchar_t *, const wchar_t *, size_t), ::wcpncpy>>());
		}
	} __wcpncpy_instance;
}



int Function<wchar_t *(*)(const wchar_t *), ::wcsdup>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wchar_t *(*)(const wchar_t *), ::wcsdup>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(const wchar_t *), ::wcsdup>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsdup_name = "::wcsdup";

const std::string& Function<wchar_t *(*)(const wchar_t *), ::wcsdup>::GetName() const
{
	return __wcsdup_name;
}

Object Function<wchar_t *(*)(const wchar_t *), ::wcsdup>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsdup(args[0].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcsdup.
	struct __wcsdup_registrar
	{
		__wcsdup_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(const wchar_t *), ::wcsdup>>());
		}
	} __wcsdup_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp>::GetParameterCount() const
{
	return 2;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcscasecmp_name = "::wcscasecmp";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp>::GetName() const
{
	return __wcscasecmp_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcscasecmp(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>()));
}

namespace
{
	// Object to auto-register ::wcscasecmp.
	struct __wcscasecmp_registrar
	{
		__wcscasecmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *), ::wcscasecmp>>());
		}
	} __wcscasecmp_instance;
}



int Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp>::GetParameterCount() const
{
	return 3;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "n";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsncasecmp_name = "::wcsncasecmp";

const std::string& Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp>::GetName() const
{
	return __wcsncasecmp_name;
}

Object Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsncasecmp(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcsncasecmp.
	struct __wcsncasecmp_registrar
	{
		__wcsncasecmp_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(const wchar_t *, const wchar_t *, size_t), ::wcsncasecmp>>());
		}
	} __wcsncasecmp_instance;
}



int Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen>::GetParameterCount() const
{
	return 2;
}

Parameter Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsnlen_name = "::wcsnlen";

const std::string& Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen>::GetName() const
{
	return __wcsnlen_name;
}

Object Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsnlen(args[0].GetT<std::decay_t<const wchar_t *>>(), args[1].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcsnlen.
	struct __wcsnlen_registrar
	{
		__wcsnlen_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(const wchar_t *, size_t), ::wcsnlen>>());
		}
	} __wcsnlen_instance;
}



int Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs>::GetParameterCount() const
{
	return 5;
}

Parameter Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t **";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 3:
		result.name = "nameless";
		result.type = "size_t";
		break;
	case 4:
		result.name = "nameless";
		result.type = "mbstate_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcsnrtombs_name = "::wcsnrtombs";

const std::string& Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs>::GetName() const
{
	return __wcsnrtombs_name;
}

Object Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcsnrtombs(args[0].GetT<std::decay_t<char *>>(), args[1].GetT<std::decay_t<const wchar_t **>>(), args[2].GetT<std::decay_t<size_t>>(), args[3].GetT<std::decay_t<size_t>>(), args[4].GetT<std::decay_t<mbstate_t *>>()));
}

namespace
{
	// Object to auto-register ::wcsnrtombs.
	struct __wcsnrtombs_registrar
	{
		__wcsnrtombs_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(char *, const wchar_t **, size_t, size_t, mbstate_t *), ::wcsnrtombs>>());
		}
	} __wcsnrtombs_instance;
}



int Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream>::GetParameterCount() const
{
	return 2;
}

Parameter Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream>::GetReturnType() const
{
	Parameter result;
	result.type = "FILE *";
	return result;
}

Parameter Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "__bufp";
		result.type = "wchar_t **";
		break;
	case 1:
		result.name = "__sizep";
		result.type = "size_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __open_wmemstream_name = "::open_wmemstream";

const std::string& Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream>::GetName() const
{
	return __open_wmemstream_name;
}

Object Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::open_wmemstream(args[0].GetT<std::decay_t<wchar_t **>>(), args[1].GetT<std::decay_t<size_t *>>()));
}

namespace
{
	// Object to auto-register ::open_wmemstream.
	struct __open_wmemstream_registrar
	{
		__open_wmemstream_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<FILE *(*)(wchar_t **, size_t *), ::open_wmemstream>>());
		}
	} __open_wmemstream_instance;
}



int Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln>::GetReturnType() const
{
	Parameter result;
	result.type = "wchar_t *";
	return result;
}

Parameter Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "FILE *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "size_t *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __fgetwln_name = "::fgetwln";

const std::string& Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln>::GetName() const
{
	return __fgetwln_name;
}

Object Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::fgetwln(args[0].GetT<std::decay_t<FILE *>>(), args[1].GetT<std::decay_t<size_t *>>()));
}

namespace
{
	// Object to auto-register ::fgetwln.
	struct __fgetwln_registrar
	{
		__fgetwln_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wchar_t *(*)(FILE *, size_t *), ::fgetwln>>());
		}
	} __fgetwln_instance;
}



int Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcslcat_name = "::wcslcat";

const std::string& Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat>::GetName() const
{
	return __wcslcat_name;
}

Object Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcslcat(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcslcat.
	struct __wcslcat_registrar
	{
		__wcslcat_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcat>>());
		}
	} __wcslcat_instance;
}



int Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy>::GetParameterCount() const
{
	return 3;
}

Parameter Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy>::GetReturnType() const
{
	Parameter result;
	result.type = "size_t";
	return result;
}

Parameter Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wchar_t *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const wchar_t *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "size_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wcslcpy_name = "::wcslcpy";

const std::string& Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy>::GetName() const
{
	return __wcslcpy_name;
}

Object Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wcslcpy(args[0].GetT<std::decay_t<wchar_t *>>(), args[1].GetT<std::decay_t<const wchar_t *>>(), args[2].GetT<std::decay_t<size_t>>()));
}

namespace
{
	// Object to auto-register ::wcslcpy.
	struct __wcslcpy_registrar
	{
		__wcslcpy_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<size_t(*)(wchar_t *, const wchar_t *, size_t), ::wcslcpy>>());
		}
	} __wcslcpy_instance;
}



int Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn>::GetParameterCount() const
{
	return 4;
}

Parameter Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 1:
		result.name = "nameless";
		result.type = "const char *";
		break;
	case 2:
		result.name = "nameless";
		result.type = "int";
		break;
	case 3:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string ____assert_rtn_name = "::__assert_rtn";

const std::string& Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn>::GetName() const
{
	return ____assert_rtn_name;
}

Object Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::__assert_rtn(args[0].GetT<std::decay_t<const char *>>(), args[1].GetT<std::decay_t<const char *>>(), args[2].GetT<std::decay_t<int>>(), args[3].GetT<std::decay_t<const char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::__assert_rtn.
	struct ____assert_rtn_registrar
	{
		____assert_rtn_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(const char *, const char *, int, const char *), ::__assert_rtn>>());
		}
	} ____assert_rtn_instance;
}



int Function<int(*)(wint_t), iswblank>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswblank>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswblank>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswblank_name = "iswblank";

const std::string& Function<int(*)(wint_t), iswblank>::GetName() const
{
	return iswblank_name;
}

Object Function<int(*)(wint_t), iswblank>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswblank(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswblank.
	struct iswblank_registrar
	{
		iswblank_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswblank>>());
		}
	} iswblank_instance;
}



int Function<int(*)(wint_t), iswascii>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswascii>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswascii>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswascii_name = "iswascii";

const std::string& Function<int(*)(wint_t), iswascii>::GetName() const
{
	return iswascii_name;
}

Object Function<int(*)(wint_t), iswascii>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswascii(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswascii.
	struct iswascii_registrar
	{
		iswascii_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswascii>>());
		}
	} iswascii_instance;
}



int Function<int(*)(wint_t), iswhexnumber>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswhexnumber>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswhexnumber>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswhexnumber_name = "iswhexnumber";

const std::string& Function<int(*)(wint_t), iswhexnumber>::GetName() const
{
	return iswhexnumber_name;
}

Object Function<int(*)(wint_t), iswhexnumber>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswhexnumber(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswhexnumber.
	struct iswhexnumber_registrar
	{
		iswhexnumber_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswhexnumber>>());
		}
	} iswhexnumber_instance;
}



int Function<int(*)(wint_t), iswideogram>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswideogram>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswideogram>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswideogram_name = "iswideogram";

const std::string& Function<int(*)(wint_t), iswideogram>::GetName() const
{
	return iswideogram_name;
}

Object Function<int(*)(wint_t), iswideogram>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswideogram(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswideogram.
	struct iswideogram_registrar
	{
		iswideogram_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswideogram>>());
		}
	} iswideogram_instance;
}



int Function<int(*)(wint_t), iswnumber>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswnumber>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswnumber>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswnumber_name = "iswnumber";

const std::string& Function<int(*)(wint_t), iswnumber>::GetName() const
{
	return iswnumber_name;
}

Object Function<int(*)(wint_t), iswnumber>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswnumber(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswnumber.
	struct iswnumber_registrar
	{
		iswnumber_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswnumber>>());
		}
	} iswnumber_instance;
}



int Function<int(*)(wint_t), iswphonogram>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswphonogram>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswphonogram>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswphonogram_name = "iswphonogram";

const std::string& Function<int(*)(wint_t), iswphonogram>::GetName() const
{
	return iswphonogram_name;
}

Object Function<int(*)(wint_t), iswphonogram>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswphonogram(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswphonogram.
	struct iswphonogram_registrar
	{
		iswphonogram_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswphonogram>>());
		}
	} iswphonogram_instance;
}



int Function<int(*)(wint_t), iswrune>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswrune>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswrune>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswrune_name = "iswrune";

const std::string& Function<int(*)(wint_t), iswrune>::GetName() const
{
	return iswrune_name;
}

Object Function<int(*)(wint_t), iswrune>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswrune(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswrune.
	struct iswrune_registrar
	{
		iswrune_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswrune>>());
		}
	} iswrune_instance;
}



int Function<int(*)(wint_t), iswspecial>::GetParameterCount() const
{
	return 1;
}

Parameter Function<int(*)(wint_t), iswspecial>::GetReturnType() const
{
	Parameter result;
	result.type = "int";
	return result;
}

Parameter Function<int(*)(wint_t), iswspecial>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "_wc";
		result.type = "wint_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string iswspecial_name = "iswspecial";

const std::string& Function<int(*)(wint_t), iswspecial>::GetName() const
{
	return iswspecial_name;
}

Object Function<int(*)(wint_t), iswspecial>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(iswspecial(args[0].GetT<std::decay_t<wint_t>>()));
}

namespace
{
	// Object to auto-register iswspecial.
	struct iswspecial_registrar
	{
		iswspecial_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<int(*)(wint_t), iswspecial>>());
		}
	} iswspecial_instance;
}



int Function<wint_t(*)(wint_t, wctype_t), ::nextwctype>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wint_t(*)(wint_t, wctype_t), ::nextwctype>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wint_t, wctype_t), ::nextwctype>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wint_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wctype_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __nextwctype_name = "::nextwctype";

const std::string& Function<wint_t(*)(wint_t, wctype_t), ::nextwctype>::GetName() const
{
	return __nextwctype_name;
}

Object Function<wint_t(*)(wint_t, wctype_t), ::nextwctype>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::nextwctype(args[0].GetT<std::decay_t<wint_t>>(), args[1].GetT<std::decay_t<wctype_t>>()));
}

namespace
{
	// Object to auto-register ::nextwctype.
	struct __nextwctype_registrar
	{
		__nextwctype_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wint_t, wctype_t), ::nextwctype>>());
		}
	} __nextwctype_instance;
}



int Function<wint_t(*)(wint_t, wctrans_t), ::towctrans>::GetParameterCount() const
{
	return 2;
}

Parameter Function<wint_t(*)(wint_t, wctrans_t), ::towctrans>::GetReturnType() const
{
	Parameter result;
	result.type = "wint_t";
	return result;
}

Parameter Function<wint_t(*)(wint_t, wctrans_t), ::towctrans>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "wint_t";
		break;
	case 1:
		result.name = "nameless";
		result.type = "wctrans_t";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __towctrans_name = "::towctrans";

const std::string& Function<wint_t(*)(wint_t, wctrans_t), ::towctrans>::GetName() const
{
	return __towctrans_name;
}

Object Function<wint_t(*)(wint_t, wctrans_t), ::towctrans>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::towctrans(args[0].GetT<std::decay_t<wint_t>>(), args[1].GetT<std::decay_t<wctrans_t>>()));
}

namespace
{
	// Object to auto-register ::towctrans.
	struct __towctrans_registrar
	{
		__towctrans_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wint_t(*)(wint_t, wctrans_t), ::towctrans>>());
		}
	} __towctrans_instance;
}



int Function<wctrans_t(*)(const char *), ::wctrans>::GetParameterCount() const
{
	return 1;
}

Parameter Function<wctrans_t(*)(const char *), ::wctrans>::GetReturnType() const
{
	Parameter result;
	result.type = "wctrans_t";
	return result;
}

Parameter Function<wctrans_t(*)(const char *), ::wctrans>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "nameless";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __wctrans_name = "::wctrans";

const std::string& Function<wctrans_t(*)(const char *), ::wctrans>::GetName() const
{
	return __wctrans_name;
}

Object Function<wctrans_t(*)(const char *), ::wctrans>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::wctrans(args[0].GetT<std::decay_t<const char *>>()));
}

namespace
{
	// Object to auto-register ::wctrans.
	struct __wctrans_registrar
	{
		__wctrans_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<wctrans_t(*)(const char *), ::wctrans>>());
		}
	} __wctrans_instance;
}



int Function<void(*)(std::string), foo::bar>::GetParameterCount() const
{
	return 1;
}

Parameter Function<void(*)(std::string), foo::bar>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(std::string), foo::bar>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "s";
		result.type = "std::string";
		break;
	default:
		break;
	}

	return result;
}

static const std::string foo__bar_name = "foo::bar";

const std::string& Function<void(*)(std::string), foo::bar>::GetName() const
{
	return foo__bar_name;
}

Object Function<void(*)(std::string), foo::bar>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	foo::bar(args[0].GetT<std::decay_t<std::string>>());
	return Object();
}

namespace
{
	// Object to auto-register foo::bar.
	struct foo__bar_registrar
	{
		foo__bar_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(std::string), foo::bar>>());
		}
	} foo__bar_instance;
}



const int Class<foo::Bar>::FieldCount;
const int Class<foo::Bar>::StaticFieldCount;
const int Class<foo::Bar>::MethodCount;
const int Class<foo::Bar>::StaticMethodCount;

int Class<foo::Bar>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<foo::Bar>::GetField(const Reference& r, const std::string& name) const
{
	if (r.IsT<foo::Bar>())
	{
		foo::Bar& o = r.GetT<foo::Bar>();
		if (name == "vec")
		{
			return Reference(o.vec);
		}
	}
	else if (r.IsT<const foo::Bar>())
	{
		const foo::Bar& o = r.GetT<const foo::Bar>();
		if (name == "vec")
		{
			return Reference(o.vec);
		}
	}
	else
	{
		throw Exception("Invalid Reference passed to GetField().");
	}
	throw Exception("Invalid name passed to GetField().");
}

int Class<foo::Bar>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<foo::Bar>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<foo::Bar>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<foo::Bar>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<foo::Bar>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<foo::Bar>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string foo__Bar_name = "foo::Bar";

const std::string& Class<foo::Bar>::GetName() const
{
	return foo__Bar_name;
}



namespace
{
	// Object to auto-register foo::Bar.
	struct foo__Bar_registrar
	{
		foo__Bar_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<foo::Bar>>());
		}
	} foo__Bar_instance;
}


const int Class<Logger>::FieldCount;
const int Class<Logger>::StaticFieldCount;
const int Class<Logger>::MethodCount;
const int Class<Logger>::StaticMethodCount;

int Class<Logger>::GetFieldCount() const
{
	return FieldCount;
}

Reference Class<Logger>::GetField(const Reference& r, const std::string& name) const
{
	throw Exception("Invalid name passed to GetField().");
}

int Class<Logger>::GetStaticFieldCount() const
{
	return StaticFieldCount;
}

Reference Class<Logger>::GetStaticField(const std::string& name) const
{
	throw Exception("Invalid name passed to GetStaticField().");
}

int Class<Logger>::GetMethodCount() const
{
	return MethodCount;
}

std::vector<std::unique_ptr<IMethod>> Class<Logger>::GetMethod(const std::string& name) const
{
	std::vector<std::unique_ptr<IMethod>> results;

	return results;
}

int Class<Logger>::GetStaticMethodCount() const
{
	return StaticMethodCount;
}

std::vector<std::unique_ptr<IFunction>> Class<Logger>::GetStaticMethod(
		const std::string& name) const
{
	std::vector<std::unique_ptr<IFunction>> results;

	return results;
}

static const std::string Logger_name = "Logger";

const std::string& Class<Logger>::GetName() const
{
	return Logger_name;
}



namespace
{
	// Object to auto-register Logger.
	struct Logger_registrar
	{
		Logger_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Class<Logger>>());
		}
	} Logger_instance;
}


int Function<Logger *(*)(), ::log_create>::GetParameterCount() const
{
	return 0;
}

Parameter Function<Logger *(*)(), ::log_create>::GetReturnType() const
{
	Parameter result;
	result.type = "Logger *";
	return result;
}

Parameter Function<Logger *(*)(), ::log_create>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;
	return result;
}

static const std::string __log_create_name = "::log_create";

const std::string& Function<Logger *(*)(), ::log_create>::GetName() const
{
	return __log_create_name;
}

Object Function<Logger *(*)(), ::log_create>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	return Object(::log_create());
}

namespace
{
	// Object to auto-register ::log_create.
	struct __log_create_registrar
	{
		__log_create_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<Logger *(*)(), ::log_create>>());
		}
	} __log_create_instance;
}



int Function<void(*)(Logger *, const char *), ::log_write>::GetParameterCount() const
{
	return 2;
}

Parameter Function<void(*)(Logger *, const char *), ::log_write>::GetReturnType() const
{
	Parameter result;
	result.type = "void";
	return result;
}

Parameter Function<void(*)(Logger *, const char *), ::log_write>::GetParameter(int i) const
{
	if (i < 0 || i >= GetParameterCount())
	{
		throw Exception("Argument out of range.");
	}

	Parameter result;

	switch (i)
	{
	case 0:
		result.name = "log";
		result.type = "Logger *";
		break;
	case 1:
		result.name = "msg";
		result.type = "const char *";
		break;
	default:
		break;
	}

	return result;
}

static const std::string __log_write_name = "::log_write";

const std::string& Function<void(*)(Logger *, const char *), ::log_write>::GetName() const
{
	return __log_write_name;
}

Object Function<void(*)(Logger *, const char *), ::log_write>::Invoke(const std::vector<Object>& args)
{
	if (args.size() != GetParameterCount())
	{
		throw Exception("Invoke(): bad argument count.");
	}

	::log_write(args[0].GetT<std::decay_t<Logger *>>(), args[1].GetT<std::decay_t<const char *>>());
	return Object();
}

namespace
{
	// Object to auto-register ::log_write.
	struct __log_write_registrar
	{
		__log_write_registrar()
		{
			::reflang::registry::internal::Register(
					std::make_unique<Function<void(*)(Logger *, const char *), ::log_write>>());
		}
	} __log_write_instance;
}


}  // namespace reflang
